// This file is generated by rust-protobuf 3.7.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `kymera_mappings.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_1;

// @@protoc_insertion_point(message:kymera_mappings.TestConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TestConfig {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.TestConfig.test_name)
    pub test_name: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.TestConfig.test_cases)
    pub test_cases: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.TestConfig.expected_results)
    pub expected_results: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.TestConfig.automated)
    pub automated: bool,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.TestConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestConfig {
    fn default() -> &'a TestConfig {
        <TestConfig as ::protobuf::Message>::default_instance()
    }
}

impl TestConfig {
    pub fn new() -> TestConfig {
        ::std::default::Default::default()
    }

    // string test_name = 1;

    pub fn test_name(&self) -> &str {
        &self.test_name
    }

    pub fn clear_test_name(&mut self) {
        self.test_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_test_name(&mut self, v: ::std::string::String) {
        self.test_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_name(&mut self) -> &mut ::std::string::String {
        &mut self.test_name
    }

    // Take field
    pub fn take_test_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.test_name, ::std::string::String::new())
    }

    // repeated string test_cases = 2;

    pub fn test_cases(&self) -> &[::std::string::String] {
        &self.test_cases
    }

    pub fn clear_test_cases(&mut self) {
        self.test_cases.clear();
    }

    // Param is passed by value, moved
    pub fn set_test_cases(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.test_cases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_test_cases(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.test_cases
    }

    // Take field
    pub fn take_test_cases(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.test_cases, ::std::vec::Vec::new())
    }

    // repeated .kymera_mappings.TestConfig.ExpectedResultsEntry expected_results = 3;

    pub fn expected_results(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.expected_results
    }

    pub fn clear_expected_results(&mut self) {
        self.expected_results.clear();
    }

    // Param is passed by value, moved
    pub fn set_expected_results(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.expected_results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expected_results(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.expected_results
    }

    // Take field
    pub fn take_expected_results(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.expected_results, ::std::collections::HashMap::new())
    }

    // bool automated = 4;

    pub fn automated(&self) -> bool {
        self.automated
    }

    pub fn clear_automated(&mut self) {
        self.automated = false;
    }

    // Param is passed by value, moved
    pub fn set_automated(&mut self, v: bool) {
        self.automated = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "test_name",
            |m: &TestConfig| { &m.test_name },
            |m: &mut TestConfig| { &mut m.test_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "test_cases",
            |m: &TestConfig| { &m.test_cases },
            |m: &mut TestConfig| { &mut m.test_cases },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "expected_results",
            |m: &TestConfig| { &m.expected_results },
            |m: &mut TestConfig| { &mut m.expected_results },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "automated",
            |m: &TestConfig| { &m.automated },
            |m: &mut TestConfig| { &mut m.automated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestConfig>(
            "TestConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestConfig {
    const NAME: &'static str = "TestConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.test_name = is.read_string()?;
                },
                18 => {
                    self.test_cases.push(is.read_string()?);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.expected_results.insert(key, value);
                },
                32 => {
                    self.automated = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.test_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.test_name);
        }
        for value in &self.test_cases {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for (k, v) in &self.expected_results {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if self.automated != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.test_name.is_empty() {
            os.write_string(1, &self.test_name)?;
        }
        for v in &self.test_cases {
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.expected_results {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        if self.automated != false {
            os.write_bool(4, self.automated)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestConfig {
        TestConfig::new()
    }

    fn clear(&mut self) {
        self.test_name.clear();
        self.test_cases.clear();
        self.expected_results.clear();
        self.automated = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestConfig {
        static instance: ::protobuf::rt::Lazy<TestConfig> = ::protobuf::rt::Lazy::new();
        instance.get(TestConfig::new)
    }
}

impl ::protobuf::MessageFull for TestConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:kymera_mappings.TestExample)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TestExample {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.TestExample.test_case)
    pub test_case: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.TestExample.inputs)
    pub inputs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.TestExample.expected_outputs)
    pub expected_outputs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.TestExample.validation_steps)
    pub validation_steps: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.TestExample.test_config)
    pub test_config: ::protobuf::MessageField<TestConfig>,
    // @@protoc_insertion_point(field:kymera_mappings.TestExample.testing_guidelines)
    pub testing_guidelines: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.TestExample.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestExample {
    fn default() -> &'a TestExample {
        <TestExample as ::protobuf::Message>::default_instance()
    }
}

impl TestExample {
    pub fn new() -> TestExample {
        ::std::default::Default::default()
    }

    // string test_case = 1;

    pub fn test_case(&self) -> &str {
        &self.test_case
    }

    pub fn clear_test_case(&mut self) {
        self.test_case.clear();
    }

    // Param is passed by value, moved
    pub fn set_test_case(&mut self, v: ::std::string::String) {
        self.test_case = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_case(&mut self) -> &mut ::std::string::String {
        &mut self.test_case
    }

    // Take field
    pub fn take_test_case(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.test_case, ::std::string::String::new())
    }

    // repeated .kymera_mappings.TestExample.InputsEntry inputs = 2;

    pub fn inputs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.inputs
    }

    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.inputs, ::std::collections::HashMap::new())
    }

    // repeated .kymera_mappings.TestExample.ExpectedOutputsEntry expected_outputs = 3;

    pub fn expected_outputs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.expected_outputs
    }

    pub fn clear_expected_outputs(&mut self) {
        self.expected_outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_expected_outputs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.expected_outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expected_outputs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.expected_outputs
    }

    // Take field
    pub fn take_expected_outputs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.expected_outputs, ::std::collections::HashMap::new())
    }

    // repeated string validation_steps = 4;

    pub fn validation_steps(&self) -> &[::std::string::String] {
        &self.validation_steps
    }

    pub fn clear_validation_steps(&mut self) {
        self.validation_steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_validation_steps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.validation_steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_validation_steps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.validation_steps
    }

    // Take field
    pub fn take_validation_steps(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.validation_steps, ::std::vec::Vec::new())
    }

    // .kymera_mappings.TestConfig test_config = 5;

    pub fn test_config(&self) -> &TestConfig {
        self.test_config.as_ref().unwrap_or_else(|| <TestConfig as ::protobuf::Message>::default_instance())
    }

    pub fn clear_test_config(&mut self) {
        self.test_config.clear();
    }

    pub fn has_test_config(&self) -> bool {
        self.test_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_config(&mut self, v: TestConfig) {
        self.test_config = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_config(&mut self) -> &mut TestConfig {
        self.test_config.mut_or_insert_default()
    }

    // Take field
    pub fn take_test_config(&mut self) -> TestConfig {
        self.test_config.take().unwrap_or_else(|| TestConfig::new())
    }

    // repeated string testing_guidelines = 6;

    pub fn testing_guidelines(&self) -> &[::std::string::String] {
        &self.testing_guidelines
    }

    pub fn clear_testing_guidelines(&mut self) {
        self.testing_guidelines.clear();
    }

    // Param is passed by value, moved
    pub fn set_testing_guidelines(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.testing_guidelines = v;
    }

    // Mutable pointer to the field.
    pub fn mut_testing_guidelines(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.testing_guidelines
    }

    // Take field
    pub fn take_testing_guidelines(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.testing_guidelines, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "test_case",
            |m: &TestExample| { &m.test_case },
            |m: &mut TestExample| { &mut m.test_case },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "inputs",
            |m: &TestExample| { &m.inputs },
            |m: &mut TestExample| { &mut m.inputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "expected_outputs",
            |m: &TestExample| { &m.expected_outputs },
            |m: &mut TestExample| { &mut m.expected_outputs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "validation_steps",
            |m: &TestExample| { &m.validation_steps },
            |m: &mut TestExample| { &mut m.validation_steps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TestConfig>(
            "test_config",
            |m: &TestExample| { &m.test_config },
            |m: &mut TestExample| { &mut m.test_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "testing_guidelines",
            |m: &TestExample| { &m.testing_guidelines },
            |m: &mut TestExample| { &mut m.testing_guidelines },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestExample>(
            "TestExample",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestExample {
    const NAME: &'static str = "TestExample";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.test_case = is.read_string()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.inputs.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.expected_outputs.insert(key, value);
                },
                34 => {
                    self.validation_steps.push(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.test_config)?;
                },
                50 => {
                    self.testing_guidelines.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.test_case.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.test_case);
        }
        for (k, v) in &self.inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.expected_outputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.validation_steps {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.test_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.testing_guidelines {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.test_case.is_empty() {
            os.write_string(1, &self.test_case)?;
        }
        for (k, v) in &self.inputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for (k, v) in &self.expected_outputs {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.validation_steps {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.test_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.testing_guidelines {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestExample {
        TestExample::new()
    }

    fn clear(&mut self) {
        self.test_case.clear();
        self.inputs.clear();
        self.expected_outputs.clear();
        self.validation_steps.clear();
        self.test_config.clear();
        self.testing_guidelines.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestExample {
        static instance: ::protobuf::rt::Lazy<TestExample> = ::protobuf::rt::Lazy::new();
        instance.get(TestExample::new)
    }
}

impl ::protobuf::MessageFull for TestExample {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestExample").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestExample {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestExample {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:kymera_mappings.BaseMapping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BaseMapping {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.BaseMapping.source_construct)
    pub source_construct: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.BaseMapping.target_construct)
    pub target_construct: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.BaseMapping.direct_mapping)
    pub direct_mapping: bool,
    // @@protoc_insertion_point(field:kymera_mappings.BaseMapping.examples)
    pub examples: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.BaseMapping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BaseMapping {
    fn default() -> &'a BaseMapping {
        <BaseMapping as ::protobuf::Message>::default_instance()
    }
}

impl BaseMapping {
    pub fn new() -> BaseMapping {
        ::std::default::Default::default()
    }

    // string source_construct = 1;

    pub fn source_construct(&self) -> &str {
        &self.source_construct
    }

    pub fn clear_source_construct(&mut self) {
        self.source_construct.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_construct(&mut self, v: ::std::string::String) {
        self.source_construct = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_construct(&mut self) -> &mut ::std::string::String {
        &mut self.source_construct
    }

    // Take field
    pub fn take_source_construct(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_construct, ::std::string::String::new())
    }

    // string target_construct = 2;

    pub fn target_construct(&self) -> &str {
        &self.target_construct
    }

    pub fn clear_target_construct(&mut self) {
        self.target_construct.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_construct(&mut self, v: ::std::string::String) {
        self.target_construct = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_construct(&mut self) -> &mut ::std::string::String {
        &mut self.target_construct
    }

    // Take field
    pub fn take_target_construct(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_construct, ::std::string::String::new())
    }

    // bool direct_mapping = 3;

    pub fn direct_mapping(&self) -> bool {
        self.direct_mapping
    }

    pub fn clear_direct_mapping(&mut self) {
        self.direct_mapping = false;
    }

    // Param is passed by value, moved
    pub fn set_direct_mapping(&mut self, v: bool) {
        self.direct_mapping = v;
    }

    // repeated .kymera_mappings.BaseMapping.ExamplesEntry examples = 4;

    pub fn examples(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.examples
    }

    pub fn clear_examples(&mut self) {
        self.examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_examples(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_examples(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.examples
    }

    // Take field
    pub fn take_examples(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.examples, ::std::collections::HashMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_construct",
            |m: &BaseMapping| { &m.source_construct },
            |m: &mut BaseMapping| { &mut m.source_construct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_construct",
            |m: &BaseMapping| { &m.target_construct },
            |m: &mut BaseMapping| { &mut m.target_construct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direct_mapping",
            |m: &BaseMapping| { &m.direct_mapping },
            |m: &mut BaseMapping| { &mut m.direct_mapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "examples",
            |m: &BaseMapping| { &m.examples },
            |m: &mut BaseMapping| { &mut m.examples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BaseMapping>(
            "BaseMapping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BaseMapping {
    const NAME: &'static str = "BaseMapping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source_construct = is.read_string()?;
                },
                18 => {
                    self.target_construct = is.read_string()?;
                },
                24 => {
                    self.direct_mapping = is.read_bool()?;
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.examples.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.source_construct.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.source_construct);
        }
        if !self.target_construct.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.target_construct);
        }
        if self.direct_mapping != false {
            my_size += 1 + 1;
        }
        for (k, v) in &self.examples {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.source_construct.is_empty() {
            os.write_string(1, &self.source_construct)?;
        }
        if !self.target_construct.is_empty() {
            os.write_string(2, &self.target_construct)?;
        }
        if self.direct_mapping != false {
            os.write_bool(3, self.direct_mapping)?;
        }
        for (k, v) in &self.examples {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BaseMapping {
        BaseMapping::new()
    }

    fn clear(&mut self) {
        self.source_construct.clear();
        self.target_construct.clear();
        self.direct_mapping = false;
        self.examples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BaseMapping {
        static instance: ::protobuf::rt::Lazy<BaseMapping> = ::protobuf::rt::Lazy::new();
        instance.get(BaseMapping::new)
    }
}

impl ::protobuf::MessageFull for BaseMapping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BaseMapping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BaseMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BaseMapping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:kymera_mappings.ExampleOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExampleOption {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.examples)
    pub examples: ::std::vec::Vec<example_option::ExamplesEntry>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.notes)
    pub notes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.base_mapping)
    pub base_mapping: ::protobuf::MessageField<BaseMapping>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.type_examples)
    pub type_examples: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.error_examples)
    pub error_examples: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.ffi_examples)
    pub ffi_examples: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.test_examples)
    pub test_examples: ::std::vec::Vec<TestExample>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.ExampleOption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExampleOption {
    fn default() -> &'a ExampleOption {
        <ExampleOption as ::protobuf::Message>::default_instance()
    }
}

impl ExampleOption {
    pub fn new() -> ExampleOption {
        ::std::default::Default::default()
    }

    // repeated .kymera_mappings.ExampleOption.ExamplesEntry examples = 1;

    pub fn examples(&self) -> &[example_option::ExamplesEntry] {
        &self.examples
    }

    pub fn clear_examples(&mut self) {
        self.examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_examples(&mut self, v: ::std::vec::Vec<example_option::ExamplesEntry>) {
        self.examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_examples(&mut self) -> &mut ::std::vec::Vec<example_option::ExamplesEntry> {
        &mut self.examples
    }

    // Take field
    pub fn take_examples(&mut self) -> ::std::vec::Vec<example_option::ExamplesEntry> {
        ::std::mem::replace(&mut self.examples, ::std::vec::Vec::new())
    }

    // repeated string notes = 2;

    pub fn notes(&self) -> &[::std::string::String] {
        &self.notes
    }

    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.notes, ::std::vec::Vec::new())
    }

    // .kymera_mappings.BaseMapping base_mapping = 3;

    pub fn base_mapping(&self) -> &BaseMapping {
        self.base_mapping.as_ref().unwrap_or_else(|| <BaseMapping as ::protobuf::Message>::default_instance())
    }

    pub fn clear_base_mapping(&mut self) {
        self.base_mapping.clear();
    }

    pub fn has_base_mapping(&self) -> bool {
        self.base_mapping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_mapping(&mut self, v: BaseMapping) {
        self.base_mapping = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_mapping(&mut self) -> &mut BaseMapping {
        self.base_mapping.mut_or_insert_default()
    }

    // Take field
    pub fn take_base_mapping(&mut self) -> BaseMapping {
        self.base_mapping.take().unwrap_or_else(|| BaseMapping::new())
    }

    // repeated string type_examples = 4;

    pub fn type_examples(&self) -> &[::std::string::String] {
        &self.type_examples
    }

    pub fn clear_type_examples(&mut self) {
        self.type_examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_examples(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.type_examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_type_examples(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.type_examples
    }

    // Take field
    pub fn take_type_examples(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.type_examples, ::std::vec::Vec::new())
    }

    // repeated string error_examples = 5;

    pub fn error_examples(&self) -> &[::std::string::String] {
        &self.error_examples
    }

    pub fn clear_error_examples(&mut self) {
        self.error_examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_examples(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.error_examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_error_examples(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.error_examples
    }

    // Take field
    pub fn take_error_examples(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.error_examples, ::std::vec::Vec::new())
    }

    // repeated string ffi_examples = 6;

    pub fn ffi_examples(&self) -> &[::std::string::String] {
        &self.ffi_examples
    }

    pub fn clear_ffi_examples(&mut self) {
        self.ffi_examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_ffi_examples(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.ffi_examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ffi_examples(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.ffi_examples
    }

    // Take field
    pub fn take_ffi_examples(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.ffi_examples, ::std::vec::Vec::new())
    }

    // repeated .kymera_mappings.TestExample test_examples = 7;

    pub fn test_examples(&self) -> &[TestExample] {
        &self.test_examples
    }

    pub fn clear_test_examples(&mut self) {
        self.test_examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_test_examples(&mut self, v: ::std::vec::Vec<TestExample>) {
        self.test_examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_test_examples(&mut self) -> &mut ::std::vec::Vec<TestExample> {
        &mut self.test_examples
    }

    // Take field
    pub fn take_test_examples(&mut self) -> ::std::vec::Vec<TestExample> {
        ::std::mem::replace(&mut self.test_examples, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "examples",
            |m: &ExampleOption| { &m.examples },
            |m: &mut ExampleOption| { &mut m.examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notes",
            |m: &ExampleOption| { &m.notes },
            |m: &mut ExampleOption| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, BaseMapping>(
            "base_mapping",
            |m: &ExampleOption| { &m.base_mapping },
            |m: &mut ExampleOption| { &mut m.base_mapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "type_examples",
            |m: &ExampleOption| { &m.type_examples },
            |m: &mut ExampleOption| { &mut m.type_examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "error_examples",
            |m: &ExampleOption| { &m.error_examples },
            |m: &mut ExampleOption| { &mut m.error_examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ffi_examples",
            |m: &ExampleOption| { &m.ffi_examples },
            |m: &mut ExampleOption| { &mut m.ffi_examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "test_examples",
            |m: &ExampleOption| { &m.test_examples },
            |m: &mut ExampleOption| { &mut m.test_examples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExampleOption>(
            "ExampleOption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExampleOption {
    const NAME: &'static str = "ExampleOption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.examples.push(is.read_message()?);
                },
                18 => {
                    self.notes.push(is.read_string()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_mapping)?;
                },
                34 => {
                    self.type_examples.push(is.read_string()?);
                },
                42 => {
                    self.error_examples.push(is.read_string()?);
                },
                50 => {
                    self.ffi_examples.push(is.read_string()?);
                },
                58 => {
                    self.test_examples.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.examples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.notes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.base_mapping.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.type_examples {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.error_examples {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.ffi_examples {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.test_examples {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.examples {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.notes {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.base_mapping.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.type_examples {
            os.write_string(4, &v)?;
        };
        for v in &self.error_examples {
            os.write_string(5, &v)?;
        };
        for v in &self.ffi_examples {
            os.write_string(6, &v)?;
        };
        for v in &self.test_examples {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExampleOption {
        ExampleOption::new()
    }

    fn clear(&mut self) {
        self.examples.clear();
        self.notes.clear();
        self.base_mapping.clear();
        self.type_examples.clear();
        self.error_examples.clear();
        self.ffi_examples.clear();
        self.test_examples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExampleOption {
        static instance: ExampleOption = ExampleOption {
            examples: ::std::vec::Vec::new(),
            notes: ::std::vec::Vec::new(),
            base_mapping: ::protobuf::MessageField::none(),
            type_examples: ::std::vec::Vec::new(),
            error_examples: ::std::vec::Vec::new(),
            ffi_examples: ::std::vec::Vec::new(),
            test_examples: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExampleOption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExampleOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExampleOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExampleOption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExampleOption`
pub mod example_option {
    // @@protoc_insertion_point(message:kymera_mappings.ExampleOption.ExamplesEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ExamplesEntry {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.ExamplesEntry.key)
        pub key: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleOption.ExamplesEntry.value)
        pub value: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleOption.ExamplesEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExamplesEntry {
        fn default() -> &'a ExamplesEntry {
            <ExamplesEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl ExamplesEntry {
        pub fn new() -> ExamplesEntry {
            ::std::default::Default::default()
        }

        // string key = 1;

        pub fn key(&self) -> &str {
            &self.key
        }

        pub fn clear_key(&mut self) {
            self.key.clear();
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            &mut self.key
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.key, ::std::string::String::new())
        }

        // string value = 2;

        pub fn value(&self) -> &str {
            &self.value
        }

        pub fn clear_value(&mut self) {
            self.value.clear();
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            &mut self.value
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.value, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "key",
                |m: &ExamplesEntry| { &m.key },
                |m: &mut ExamplesEntry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "value",
                |m: &ExamplesEntry| { &m.value },
                |m: &mut ExamplesEntry| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExamplesEntry>(
                "ExampleOption.ExamplesEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ExamplesEntry {
        const NAME: &'static str = "ExamplesEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.key = is.read_string()?;
                    },
                    18 => {
                        self.value = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.key.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.key);
            }
            if !self.value.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.value);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.key.is_empty() {
                os.write_string(1, &self.key)?;
            }
            if !self.value.is_empty() {
                os.write_string(2, &self.value)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExamplesEntry {
            ExamplesEntry::new()
        }

        fn clear(&mut self) {
            self.key.clear();
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExamplesEntry {
            static instance: ExamplesEntry = ExamplesEntry {
                key: ::std::string::String::new(),
                value: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ExamplesEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleOption.ExamplesEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ExamplesEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ExamplesEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.AIASystemV2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AIASystemV2 {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AIASystemV2 {
    fn default() -> &'a AIASystemV2 {
        <AIASystemV2 as ::protobuf::Message>::default_instance()
    }
}

impl AIASystemV2 {
    pub fn new() -> AIASystemV2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AIASystemV2>(
            "AIASystemV2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AIASystemV2 {
    const NAME: &'static str = "AIASystemV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AIASystemV2 {
        AIASystemV2::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AIASystemV2 {
        static instance: AIASystemV2 = AIASystemV2 {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AIASystemV2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AIASystemV2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AIASystemV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AIASystemV2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AIASystemV2`
pub mod aiasystem_v2 {
    // @@protoc_insertion_point(message:kymera_mappings.AIASystemV2.CoreAIEngine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CoreAIEngine {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.CoreAIEngine.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CoreAIEngine {
        fn default() -> &'a CoreAIEngine {
            <CoreAIEngine as ::protobuf::Message>::default_instance()
        }
    }

    impl CoreAIEngine {
        pub fn new() -> CoreAIEngine {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoreAIEngine>(
                "AIASystemV2.CoreAIEngine",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CoreAIEngine {
        const NAME: &'static str = "CoreAIEngine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CoreAIEngine {
            CoreAIEngine::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CoreAIEngine {
            static instance: CoreAIEngine = CoreAIEngine {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CoreAIEngine {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("AIASystemV2.CoreAIEngine").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CoreAIEngine {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CoreAIEngine {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CoreAIEngine`
    pub mod core_aiengine {
        // @@protoc_insertion_point(message:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ModelArchitecture {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.engine_type)
            pub engine_type: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.model_version)
            pub model_version: u32,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.architecture_name)
            pub architecture_name: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.parameters)
            pub parameters: ::std::collections::HashMap<::std::string::String, f32>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.capabilities)
            pub capabilities: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.quantum_ready)
            pub quantum_ready: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.extension_points)
            pub extension_points: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.custom_configs)
            pub custom_configs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ModelArchitecture {
            fn default() -> &'a ModelArchitecture {
                <ModelArchitecture as ::protobuf::Message>::default_instance()
            }
        }

        impl ModelArchitecture {
            pub fn new() -> ModelArchitecture {
                ::std::default::Default::default()
            }

            // string engine_type = 1;

            pub fn engine_type(&self) -> &str {
                &self.engine_type
            }

            pub fn clear_engine_type(&mut self) {
                self.engine_type.clear();
            }

            // Param is passed by value, moved
            pub fn set_engine_type(&mut self, v: ::std::string::String) {
                self.engine_type = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_engine_type(&mut self) -> &mut ::std::string::String {
                &mut self.engine_type
            }

            // Take field
            pub fn take_engine_type(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.engine_type, ::std::string::String::new())
            }

            // uint32 model_version = 2;

            pub fn model_version(&self) -> u32 {
                self.model_version
            }

            pub fn clear_model_version(&mut self) {
                self.model_version = 0;
            }

            // Param is passed by value, moved
            pub fn set_model_version(&mut self, v: u32) {
                self.model_version = v;
            }

            // string architecture_name = 3;

            pub fn architecture_name(&self) -> &str {
                &self.architecture_name
            }

            pub fn clear_architecture_name(&mut self) {
                self.architecture_name.clear();
            }

            // Param is passed by value, moved
            pub fn set_architecture_name(&mut self, v: ::std::string::String) {
                self.architecture_name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_architecture_name(&mut self) -> &mut ::std::string::String {
                &mut self.architecture_name
            }

            // Take field
            pub fn take_architecture_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.architecture_name, ::std::string::String::new())
            }

            // repeated .kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.ParametersEntry parameters = 4;

            pub fn parameters(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
                &self.parameters
            }

            pub fn clear_parameters(&mut self) {
                self.parameters.clear();
            }

            // Param is passed by value, moved
            pub fn set_parameters(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
                self.parameters = v;
            }

            // Mutable pointer to the field.
            pub fn mut_parameters(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
                &mut self.parameters
            }

            // Take field
            pub fn take_parameters(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
                ::std::mem::replace(&mut self.parameters, ::std::collections::HashMap::new())
            }

            // repeated string capabilities = 5;

            pub fn capabilities(&self) -> &[::std::string::String] {
                &self.capabilities
            }

            pub fn clear_capabilities(&mut self) {
                self.capabilities.clear();
            }

            // Param is passed by value, moved
            pub fn set_capabilities(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.capabilities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_capabilities(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.capabilities
            }

            // Take field
            pub fn take_capabilities(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.capabilities, ::std::vec::Vec::new())
            }

            // bool quantum_ready = 6;

            pub fn quantum_ready(&self) -> bool {
                self.quantum_ready
            }

            pub fn clear_quantum_ready(&mut self) {
                self.quantum_ready = false;
            }

            // Param is passed by value, moved
            pub fn set_quantum_ready(&mut self, v: bool) {
                self.quantum_ready = v;
            }

            // repeated string extension_points = 7;

            pub fn extension_points(&self) -> &[::std::string::String] {
                &self.extension_points
            }

            pub fn clear_extension_points(&mut self) {
                self.extension_points.clear();
            }

            // Param is passed by value, moved
            pub fn set_extension_points(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.extension_points = v;
            }

            // Mutable pointer to the field.
            pub fn mut_extension_points(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.extension_points
            }

            // Take field
            pub fn take_extension_points(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.extension_points, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AIASystemV2.CoreAIEngine.ModelArchitecture.CustomConfigsEntry custom_configs = 8;

            pub fn custom_configs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.custom_configs
            }

            pub fn clear_custom_configs(&mut self) {
                self.custom_configs.clear();
            }

            // Param is passed by value, moved
            pub fn set_custom_configs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.custom_configs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_custom_configs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.custom_configs
            }

            // Take field
            pub fn take_custom_configs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.custom_configs, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(8);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "engine_type",
                    |m: &ModelArchitecture| { &m.engine_type },
                    |m: &mut ModelArchitecture| { &mut m.engine_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "model_version",
                    |m: &ModelArchitecture| { &m.model_version },
                    |m: &mut ModelArchitecture| { &mut m.model_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "architecture_name",
                    |m: &ModelArchitecture| { &m.architecture_name },
                    |m: &mut ModelArchitecture| { &mut m.architecture_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "parameters",
                    |m: &ModelArchitecture| { &m.parameters },
                    |m: &mut ModelArchitecture| { &mut m.parameters },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "capabilities",
                    |m: &ModelArchitecture| { &m.capabilities },
                    |m: &mut ModelArchitecture| { &mut m.capabilities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "quantum_ready",
                    |m: &ModelArchitecture| { &m.quantum_ready },
                    |m: &mut ModelArchitecture| { &mut m.quantum_ready },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "extension_points",
                    |m: &ModelArchitecture| { &m.extension_points },
                    |m: &mut ModelArchitecture| { &mut m.extension_points },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "custom_configs",
                    |m: &ModelArchitecture| { &m.custom_configs },
                    |m: &mut ModelArchitecture| { &mut m.custom_configs },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelArchitecture>(
                    "AIASystemV2.CoreAIEngine.ModelArchitecture",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ModelArchitecture {
            const NAME: &'static str = "ModelArchitecture";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.engine_type = is.read_string()?;
                        },
                        16 => {
                            self.model_version = is.read_uint32()?;
                        },
                        26 => {
                            self.architecture_name = is.read_string()?;
                        },
                        34 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    21 => value = is.read_float()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.parameters.insert(key, value);
                        },
                        42 => {
                            self.capabilities.push(is.read_string()?);
                        },
                        48 => {
                            self.quantum_ready = is.read_bool()?;
                        },
                        58 => {
                            self.extension_points.push(is.read_string()?);
                        },
                        66 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.custom_configs.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.engine_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.engine_type);
                }
                if self.model_version != 0 {
                    my_size += ::protobuf::rt::uint32_size(2, self.model_version);
                }
                if !self.architecture_name.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.architecture_name);
                }
                for (k, v) in &self.parameters {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                for value in &self.capabilities {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                if self.quantum_ready != false {
                    my_size += 1 + 1;
                }
                for value in &self.extension_points {
                    my_size += ::protobuf::rt::string_size(7, &value);
                };
                for (k, v) in &self.custom_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.engine_type.is_empty() {
                    os.write_string(1, &self.engine_type)?;
                }
                if self.model_version != 0 {
                    os.write_uint32(2, self.model_version)?;
                }
                if !self.architecture_name.is_empty() {
                    os.write_string(3, &self.architecture_name)?;
                }
                for (k, v) in &self.parameters {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    os.write_raw_varint32(34)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_float(2, *v)?;
                };
                for v in &self.capabilities {
                    os.write_string(5, &v)?;
                };
                if self.quantum_ready != false {
                    os.write_bool(6, self.quantum_ready)?;
                }
                for v in &self.extension_points {
                    os.write_string(7, &v)?;
                };
                for (k, v) in &self.custom_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(66)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ModelArchitecture {
                ModelArchitecture::new()
            }

            fn clear(&mut self) {
                self.engine_type.clear();
                self.model_version = 0;
                self.architecture_name.clear();
                self.parameters.clear();
                self.capabilities.clear();
                self.quantum_ready = false;
                self.extension_points.clear();
                self.custom_configs.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ModelArchitecture {
                static instance: ::protobuf::rt::Lazy<ModelArchitecture> = ::protobuf::rt::Lazy::new();
                instance.get(ModelArchitecture::new)
            }
        }

        impl ::protobuf::MessageFull for ModelArchitecture {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AIASystemV2.CoreAIEngine.ModelArchitecture").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ModelArchitecture {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ModelArchitecture {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DistributedCompute {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.distributed_enabled)
            pub distributed_enabled: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.compute_nodes)
            pub compute_nodes: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.node_capabilities)
            pub node_capabilities: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.min_node_count)
            pub min_node_count: u32,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.max_node_count)
            pub max_node_count: u32,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.fallback_strategies)
            pub fallback_strategies: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DistributedCompute {
            fn default() -> &'a DistributedCompute {
                <DistributedCompute as ::protobuf::Message>::default_instance()
            }
        }

        impl DistributedCompute {
            pub fn new() -> DistributedCompute {
                ::std::default::Default::default()
            }

            // bool distributed_enabled = 1;

            pub fn distributed_enabled(&self) -> bool {
                self.distributed_enabled
            }

            pub fn clear_distributed_enabled(&mut self) {
                self.distributed_enabled = false;
            }

            // Param is passed by value, moved
            pub fn set_distributed_enabled(&mut self, v: bool) {
                self.distributed_enabled = v;
            }

            // repeated string compute_nodes = 2;

            pub fn compute_nodes(&self) -> &[::std::string::String] {
                &self.compute_nodes
            }

            pub fn clear_compute_nodes(&mut self) {
                self.compute_nodes.clear();
            }

            // Param is passed by value, moved
            pub fn set_compute_nodes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.compute_nodes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compute_nodes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.compute_nodes
            }

            // Take field
            pub fn take_compute_nodes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.compute_nodes, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AIASystemV2.CoreAIEngine.DistributedCompute.NodeCapabilitiesEntry node_capabilities = 3;

            pub fn node_capabilities(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.node_capabilities
            }

            pub fn clear_node_capabilities(&mut self) {
                self.node_capabilities.clear();
            }

            // Param is passed by value, moved
            pub fn set_node_capabilities(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.node_capabilities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_node_capabilities(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.node_capabilities
            }

            // Take field
            pub fn take_node_capabilities(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.node_capabilities, ::std::collections::HashMap::new())
            }

            // uint32 min_node_count = 4;

            pub fn min_node_count(&self) -> u32 {
                self.min_node_count
            }

            pub fn clear_min_node_count(&mut self) {
                self.min_node_count = 0;
            }

            // Param is passed by value, moved
            pub fn set_min_node_count(&mut self, v: u32) {
                self.min_node_count = v;
            }

            // uint32 max_node_count = 5;

            pub fn max_node_count(&self) -> u32 {
                self.max_node_count
            }

            pub fn clear_max_node_count(&mut self) {
                self.max_node_count = 0;
            }

            // Param is passed by value, moved
            pub fn set_max_node_count(&mut self, v: u32) {
                self.max_node_count = v;
            }

            // repeated string fallback_strategies = 6;

            pub fn fallback_strategies(&self) -> &[::std::string::String] {
                &self.fallback_strategies
            }

            pub fn clear_fallback_strategies(&mut self) {
                self.fallback_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_fallback_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.fallback_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_fallback_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.fallback_strategies
            }

            // Take field
            pub fn take_fallback_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.fallback_strategies, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "distributed_enabled",
                    |m: &DistributedCompute| { &m.distributed_enabled },
                    |m: &mut DistributedCompute| { &mut m.distributed_enabled },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "compute_nodes",
                    |m: &DistributedCompute| { &m.compute_nodes },
                    |m: &mut DistributedCompute| { &mut m.compute_nodes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "node_capabilities",
                    |m: &DistributedCompute| { &m.node_capabilities },
                    |m: &mut DistributedCompute| { &mut m.node_capabilities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "min_node_count",
                    |m: &DistributedCompute| { &m.min_node_count },
                    |m: &mut DistributedCompute| { &mut m.min_node_count },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "max_node_count",
                    |m: &DistributedCompute| { &m.max_node_count },
                    |m: &mut DistributedCompute| { &mut m.max_node_count },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "fallback_strategies",
                    |m: &DistributedCompute| { &m.fallback_strategies },
                    |m: &mut DistributedCompute| { &mut m.fallback_strategies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DistributedCompute>(
                    "AIASystemV2.CoreAIEngine.DistributedCompute",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DistributedCompute {
            const NAME: &'static str = "DistributedCompute";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.distributed_enabled = is.read_bool()?;
                        },
                        18 => {
                            self.compute_nodes.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.node_capabilities.insert(key, value);
                        },
                        32 => {
                            self.min_node_count = is.read_uint32()?;
                        },
                        40 => {
                            self.max_node_count = is.read_uint32()?;
                        },
                        50 => {
                            self.fallback_strategies.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.distributed_enabled != false {
                    my_size += 1 + 1;
                }
                for value in &self.compute_nodes {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.node_capabilities {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.min_node_count != 0 {
                    my_size += ::protobuf::rt::uint32_size(4, self.min_node_count);
                }
                if self.max_node_count != 0 {
                    my_size += ::protobuf::rt::uint32_size(5, self.max_node_count);
                }
                for value in &self.fallback_strategies {
                    my_size += ::protobuf::rt::string_size(6, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.distributed_enabled != false {
                    os.write_bool(1, self.distributed_enabled)?;
                }
                for v in &self.compute_nodes {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.node_capabilities {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.min_node_count != 0 {
                    os.write_uint32(4, self.min_node_count)?;
                }
                if self.max_node_count != 0 {
                    os.write_uint32(5, self.max_node_count)?;
                }
                for v in &self.fallback_strategies {
                    os.write_string(6, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DistributedCompute {
                DistributedCompute::new()
            }

            fn clear(&mut self) {
                self.distributed_enabled = false;
                self.compute_nodes.clear();
                self.node_capabilities.clear();
                self.min_node_count = 0;
                self.max_node_count = 0;
                self.fallback_strategies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DistributedCompute {
                static instance: ::protobuf::rt::Lazy<DistributedCompute> = ::protobuf::rt::Lazy::new();
                instance.get(DistributedCompute::new)
            }
        }

        impl ::protobuf::MessageFull for DistributedCompute {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AIASystemV2.CoreAIEngine.DistributedCompute").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DistributedCompute {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DistributedCompute {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct OptimizationEngine {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.level)
            pub level: ::protobuf::EnumOrUnknown<optimization_engine::OptimizationLevel>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.optimization_targets)
            pub optimization_targets: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.performance_metrics)
            pub performance_metrics: ::std::collections::HashMap<::std::string::String, f32>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.auto_tuning)
            pub auto_tuning: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.constraint_rules)
            pub constraint_rules: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a OptimizationEngine {
            fn default() -> &'a OptimizationEngine {
                <OptimizationEngine as ::protobuf::Message>::default_instance()
            }
        }

        impl OptimizationEngine {
            pub fn new() -> OptimizationEngine {
                ::std::default::Default::default()
            }

            // .kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel level = 1;

            pub fn level(&self) -> optimization_engine::OptimizationLevel {
                self.level.enum_value_or_default()
            }

            pub fn clear_level(&mut self) {
                self.level = ::protobuf::EnumOrUnknown::new(optimization_engine::OptimizationLevel::BASIC);
            }

            // Param is passed by value, moved
            pub fn set_level(&mut self, v: optimization_engine::OptimizationLevel) {
                self.level = ::protobuf::EnumOrUnknown::new(v);
            }

            // repeated string optimization_targets = 2;

            pub fn optimization_targets(&self) -> &[::std::string::String] {
                &self.optimization_targets
            }

            pub fn clear_optimization_targets(&mut self) {
                self.optimization_targets.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_targets(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimization_targets = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_targets(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimization_targets
            }

            // Take field
            pub fn take_optimization_targets(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimization_targets, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.PerformanceMetricsEntry performance_metrics = 3;

            pub fn performance_metrics(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
                &self.performance_metrics
            }

            pub fn clear_performance_metrics(&mut self) {
                self.performance_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_performance_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
                self.performance_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_performance_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
                &mut self.performance_metrics
            }

            // Take field
            pub fn take_performance_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
                ::std::mem::replace(&mut self.performance_metrics, ::std::collections::HashMap::new())
            }

            // bool auto_tuning = 4;

            pub fn auto_tuning(&self) -> bool {
                self.auto_tuning
            }

            pub fn clear_auto_tuning(&mut self) {
                self.auto_tuning = false;
            }

            // Param is passed by value, moved
            pub fn set_auto_tuning(&mut self, v: bool) {
                self.auto_tuning = v;
            }

            // repeated string constraint_rules = 5;

            pub fn constraint_rules(&self) -> &[::std::string::String] {
                &self.constraint_rules
            }

            pub fn clear_constraint_rules(&mut self) {
                self.constraint_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_constraint_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.constraint_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_constraint_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.constraint_rules
            }

            // Take field
            pub fn take_constraint_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.constraint_rules, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "level",
                    |m: &OptimizationEngine| { &m.level },
                    |m: &mut OptimizationEngine| { &mut m.level },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimization_targets",
                    |m: &OptimizationEngine| { &m.optimization_targets },
                    |m: &mut OptimizationEngine| { &mut m.optimization_targets },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "performance_metrics",
                    |m: &OptimizationEngine| { &m.performance_metrics },
                    |m: &mut OptimizationEngine| { &mut m.performance_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "auto_tuning",
                    |m: &OptimizationEngine| { &m.auto_tuning },
                    |m: &mut OptimizationEngine| { &mut m.auto_tuning },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "constraint_rules",
                    |m: &OptimizationEngine| { &m.constraint_rules },
                    |m: &mut OptimizationEngine| { &mut m.constraint_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptimizationEngine>(
                    "AIASystemV2.CoreAIEngine.OptimizationEngine",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for OptimizationEngine {
            const NAME: &'static str = "OptimizationEngine";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.level = is.read_enum_or_unknown()?;
                        },
                        18 => {
                            self.optimization_targets.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    21 => value = is.read_float()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.performance_metrics.insert(key, value);
                        },
                        32 => {
                            self.auto_tuning = is.read_bool()?;
                        },
                        42 => {
                            self.constraint_rules.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.level != ::protobuf::EnumOrUnknown::new(optimization_engine::OptimizationLevel::BASIC) {
                    my_size += ::protobuf::rt::int32_size(1, self.level.value());
                }
                for value in &self.optimization_targets {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.performance_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.auto_tuning != false {
                    my_size += 1 + 1;
                }
                for value in &self.constraint_rules {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.level != ::protobuf::EnumOrUnknown::new(optimization_engine::OptimizationLevel::BASIC) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.level))?;
                }
                for v in &self.optimization_targets {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.performance_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_float(2, *v)?;
                };
                if self.auto_tuning != false {
                    os.write_bool(4, self.auto_tuning)?;
                }
                for v in &self.constraint_rules {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> OptimizationEngine {
                OptimizationEngine::new()
            }

            fn clear(&mut self) {
                self.level = ::protobuf::EnumOrUnknown::new(optimization_engine::OptimizationLevel::BASIC);
                self.optimization_targets.clear();
                self.performance_metrics.clear();
                self.auto_tuning = false;
                self.constraint_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static OptimizationEngine {
                static instance: ::protobuf::rt::Lazy<OptimizationEngine> = ::protobuf::rt::Lazy::new();
                instance.get(OptimizationEngine::new)
            }
        }

        impl ::protobuf::MessageFull for OptimizationEngine {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AIASystemV2.CoreAIEngine.OptimizationEngine").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for OptimizationEngine {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for OptimizationEngine {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `OptimizationEngine`
        pub mod optimization_engine {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel)
            pub enum OptimizationLevel {
                // @@protoc_insertion_point(enum_value:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel.BASIC)
                BASIC = 0,
                // @@protoc_insertion_point(enum_value:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel.INTERMEDIATE)
                INTERMEDIATE = 1,
                // @@protoc_insertion_point(enum_value:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel.ADVANCED)
                ADVANCED = 2,
                // @@protoc_insertion_point(enum_value:kymera_mappings.AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel.QUANTUM_ENHANCED)
                QUANTUM_ENHANCED = 3,
            }

            impl ::protobuf::Enum for OptimizationLevel {
                const NAME: &'static str = "OptimizationLevel";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<OptimizationLevel> {
                    match value {
                        0 => ::std::option::Option::Some(OptimizationLevel::BASIC),
                        1 => ::std::option::Option::Some(OptimizationLevel::INTERMEDIATE),
                        2 => ::std::option::Option::Some(OptimizationLevel::ADVANCED),
                        3 => ::std::option::Option::Some(OptimizationLevel::QUANTUM_ENHANCED),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<OptimizationLevel> {
                    match str {
                        "BASIC" => ::std::option::Option::Some(OptimizationLevel::BASIC),
                        "INTERMEDIATE" => ::std::option::Option::Some(OptimizationLevel::INTERMEDIATE),
                        "ADVANCED" => ::std::option::Option::Some(OptimizationLevel::ADVANCED),
                        "QUANTUM_ENHANCED" => ::std::option::Option::Some(OptimizationLevel::QUANTUM_ENHANCED),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [OptimizationLevel] = &[
                    OptimizationLevel::BASIC,
                    OptimizationLevel::INTERMEDIATE,
                    OptimizationLevel::ADVANCED,
                    OptimizationLevel::QUANTUM_ENHANCED,
                ];
            }

            impl ::protobuf::EnumFull for OptimizationLevel {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for OptimizationLevel {
                fn default() -> Self {
                    OptimizationLevel::BASIC
                }
            }

            impl OptimizationLevel {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OptimizationLevel>("AIASystemV2.CoreAIEngine.OptimizationEngine.OptimizationLevel")
                }
            }
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.AIASystemV2.AdvancedGeneration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdvancedGeneration {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.AdvancedGeneration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdvancedGeneration {
        fn default() -> &'a AdvancedGeneration {
            <AdvancedGeneration as ::protobuf::Message>::default_instance()
        }
    }

    impl AdvancedGeneration {
        pub fn new() -> AdvancedGeneration {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdvancedGeneration>(
                "AIASystemV2.AdvancedGeneration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AdvancedGeneration {
        const NAME: &'static str = "AdvancedGeneration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdvancedGeneration {
            AdvancedGeneration::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdvancedGeneration {
            static instance: AdvancedGeneration = AdvancedGeneration {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AdvancedGeneration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("AIASystemV2.AdvancedGeneration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdvancedGeneration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AdvancedGeneration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AdvancedGeneration`
    pub mod advanced_generation {
        // @@protoc_insertion_point(message:kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CodeSynthesis {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.synthesis_patterns)
            pub synthesis_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.pattern_implementations)
            pub pattern_implementations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.incremental_generation)
            pub incremental_generation: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.validation_rules)
            pub validation_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.generation_contexts)
            pub generation_contexts: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CodeSynthesis {
            fn default() -> &'a CodeSynthesis {
                <CodeSynthesis as ::protobuf::Message>::default_instance()
            }
        }

        impl CodeSynthesis {
            pub fn new() -> CodeSynthesis {
                ::std::default::Default::default()
            }

            // repeated string synthesis_patterns = 1;

            pub fn synthesis_patterns(&self) -> &[::std::string::String] {
                &self.synthesis_patterns
            }

            pub fn clear_synthesis_patterns(&mut self) {
                self.synthesis_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_synthesis_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.synthesis_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_synthesis_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.synthesis_patterns
            }

            // Take field
            pub fn take_synthesis_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.synthesis_patterns, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.PatternImplementationsEntry pattern_implementations = 2;

            pub fn pattern_implementations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.pattern_implementations
            }

            pub fn clear_pattern_implementations(&mut self) {
                self.pattern_implementations.clear();
            }

            // Param is passed by value, moved
            pub fn set_pattern_implementations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.pattern_implementations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_pattern_implementations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.pattern_implementations
            }

            // Take field
            pub fn take_pattern_implementations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.pattern_implementations, ::std::collections::HashMap::new())
            }

            // bool incremental_generation = 3;

            pub fn incremental_generation(&self) -> bool {
                self.incremental_generation
            }

            pub fn clear_incremental_generation(&mut self) {
                self.incremental_generation = false;
            }

            // Param is passed by value, moved
            pub fn set_incremental_generation(&mut self, v: bool) {
                self.incremental_generation = v;
            }

            // repeated string validation_rules = 4;

            pub fn validation_rules(&self) -> &[::std::string::String] {
                &self.validation_rules
            }

            pub fn clear_validation_rules(&mut self) {
                self.validation_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_validation_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.validation_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_validation_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.validation_rules
            }

            // Take field
            pub fn take_validation_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.validation_rules, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynthesis.GenerationContextsEntry generation_contexts = 5;

            pub fn generation_contexts(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.generation_contexts
            }

            pub fn clear_generation_contexts(&mut self) {
                self.generation_contexts.clear();
            }

            // Param is passed by value, moved
            pub fn set_generation_contexts(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.generation_contexts = v;
            }

            // Mutable pointer to the field.
            pub fn mut_generation_contexts(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.generation_contexts
            }

            // Take field
            pub fn take_generation_contexts(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.generation_contexts, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "synthesis_patterns",
                    |m: &CodeSynthesis| { &m.synthesis_patterns },
                    |m: &mut CodeSynthesis| { &mut m.synthesis_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "pattern_implementations",
                    |m: &CodeSynthesis| { &m.pattern_implementations },
                    |m: &mut CodeSynthesis| { &mut m.pattern_implementations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "incremental_generation",
                    |m: &CodeSynthesis| { &m.incremental_generation },
                    |m: &mut CodeSynthesis| { &mut m.incremental_generation },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "validation_rules",
                    |m: &CodeSynthesis| { &m.validation_rules },
                    |m: &mut CodeSynthesis| { &mut m.validation_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "generation_contexts",
                    |m: &CodeSynthesis| { &m.generation_contexts },
                    |m: &mut CodeSynthesis| { &mut m.generation_contexts },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeSynthesis>(
                    "AIASystemV2.AdvancedGeneration.CodeSynthesis",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CodeSynthesis {
            const NAME: &'static str = "CodeSynthesis";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.synthesis_patterns.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.pattern_implementations.insert(key, value);
                        },
                        24 => {
                            self.incremental_generation = is.read_bool()?;
                        },
                        34 => {
                            self.validation_rules.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.generation_contexts.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.synthesis_patterns {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.pattern_implementations {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.incremental_generation != false {
                    my_size += 1 + 1;
                }
                for value in &self.validation_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.generation_contexts {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.synthesis_patterns {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.pattern_implementations {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.incremental_generation != false {
                    os.write_bool(3, self.incremental_generation)?;
                }
                for v in &self.validation_rules {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.generation_contexts {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CodeSynthesis {
                CodeSynthesis::new()
            }

            fn clear(&mut self) {
                self.synthesis_patterns.clear();
                self.pattern_implementations.clear();
                self.incremental_generation = false;
                self.validation_rules.clear();
                self.generation_contexts.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CodeSynthesis {
                static instance: ::protobuf::rt::Lazy<CodeSynthesis> = ::protobuf::rt::Lazy::new();
                instance.get(CodeSynthesis::new)
            }
        }

        impl ::protobuf::MessageFull for CodeSynthesis {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AIASystemV2.AdvancedGeneration.CodeSynthesis").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CodeSynthesis {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CodeSynthesis {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.AIASystemV2.AdvancedGeneration.SecurityAwareness)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SecurityAwareness {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.SecurityAwareness.security_patterns)
            pub security_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.SecurityAwareness.vulnerability_checks)
            pub vulnerability_checks: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.SecurityAwareness.runtime_scanning)
            pub runtime_scanning: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AIASystemV2.AdvancedGeneration.SecurityAwareness.mitigation_strategies)
            pub mitigation_strategies: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AIASystemV2.AdvancedGeneration.SecurityAwareness.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SecurityAwareness {
            fn default() -> &'a SecurityAwareness {
                <SecurityAwareness as ::protobuf::Message>::default_instance()
            }
        }

        impl SecurityAwareness {
            pub fn new() -> SecurityAwareness {
                ::std::default::Default::default()
            }

            // repeated string security_patterns = 1;

            pub fn security_patterns(&self) -> &[::std::string::String] {
                &self.security_patterns
            }

            pub fn clear_security_patterns(&mut self) {
                self.security_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_security_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.security_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_security_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.security_patterns
            }

            // Take field
            pub fn take_security_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.security_patterns, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AIASystemV2.AdvancedGeneration.SecurityAwareness.VulnerabilityChecksEntry vulnerability_checks = 2;

            pub fn vulnerability_checks(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.vulnerability_checks
            }

            pub fn clear_vulnerability_checks(&mut self) {
                self.vulnerability_checks.clear();
            }

            // Param is passed by value, moved
            pub fn set_vulnerability_checks(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.vulnerability_checks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_vulnerability_checks(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.vulnerability_checks
            }

            // Take field
            pub fn take_vulnerability_checks(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.vulnerability_checks, ::std::collections::HashMap::new())
            }

            // bool runtime_scanning = 3;

            pub fn runtime_scanning(&self) -> bool {
                self.runtime_scanning
            }

            pub fn clear_runtime_scanning(&mut self) {
                self.runtime_scanning = false;
            }

            // Param is passed by value, moved
            pub fn set_runtime_scanning(&mut self, v: bool) {
                self.runtime_scanning = v;
            }

            // repeated string mitigation_strategies = 4;

            pub fn mitigation_strategies(&self) -> &[::std::string::String] {
                &self.mitigation_strategies
            }

            pub fn clear_mitigation_strategies(&mut self) {
                self.mitigation_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_mitigation_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.mitigation_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_mitigation_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.mitigation_strategies
            }

            // Take field
            pub fn take_mitigation_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.mitigation_strategies, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "security_patterns",
                    |m: &SecurityAwareness| { &m.security_patterns },
                    |m: &mut SecurityAwareness| { &mut m.security_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "vulnerability_checks",
                    |m: &SecurityAwareness| { &m.vulnerability_checks },
                    |m: &mut SecurityAwareness| { &mut m.vulnerability_checks },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "runtime_scanning",
                    |m: &SecurityAwareness| { &m.runtime_scanning },
                    |m: &mut SecurityAwareness| { &mut m.runtime_scanning },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "mitigation_strategies",
                    |m: &SecurityAwareness| { &m.mitigation_strategies },
                    |m: &mut SecurityAwareness| { &mut m.mitigation_strategies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityAwareness>(
                    "AIASystemV2.AdvancedGeneration.SecurityAwareness",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SecurityAwareness {
            const NAME: &'static str = "SecurityAwareness";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.security_patterns.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.vulnerability_checks.insert(key, value);
                        },
                        24 => {
                            self.runtime_scanning = is.read_bool()?;
                        },
                        34 => {
                            self.mitigation_strategies.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.security_patterns {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.vulnerability_checks {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.runtime_scanning != false {
                    my_size += 1 + 1;
                }
                for value in &self.mitigation_strategies {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.security_patterns {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.vulnerability_checks {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.runtime_scanning != false {
                    os.write_bool(3, self.runtime_scanning)?;
                }
                for v in &self.mitigation_strategies {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SecurityAwareness {
                SecurityAwareness::new()
            }

            fn clear(&mut self) {
                self.security_patterns.clear();
                self.vulnerability_checks.clear();
                self.runtime_scanning = false;
                self.mitigation_strategies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SecurityAwareness {
                static instance: ::protobuf::rt::Lazy<SecurityAwareness> = ::protobuf::rt::Lazy::new();
                instance.get(SecurityAwareness::new)
            }
        }

        impl ::protobuf::MessageFull for SecurityAwareness {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AIASystemV2.AdvancedGeneration.SecurityAwareness").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SecurityAwareness {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SecurityAwareness {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.QuantumEnhancedSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QuantumEnhancedSystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.QuantumEnhancedSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QuantumEnhancedSystem {
    fn default() -> &'a QuantumEnhancedSystem {
        <QuantumEnhancedSystem as ::protobuf::Message>::default_instance()
    }
}

impl QuantumEnhancedSystem {
    pub fn new() -> QuantumEnhancedSystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuantumEnhancedSystem>(
            "QuantumEnhancedSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QuantumEnhancedSystem {
    const NAME: &'static str = "QuantumEnhancedSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QuantumEnhancedSystem {
        QuantumEnhancedSystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QuantumEnhancedSystem {
        static instance: QuantumEnhancedSystem = QuantumEnhancedSystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QuantumEnhancedSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QuantumEnhancedSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QuantumEnhancedSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuantumEnhancedSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `QuantumEnhancedSystem`
pub mod quantum_enhanced_system {
    // @@protoc_insertion_point(message:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QuantumProcessor {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QuantumProcessor {
        fn default() -> &'a QuantumProcessor {
            <QuantumProcessor as ::protobuf::Message>::default_instance()
        }
    }

    impl QuantumProcessor {
        pub fn new() -> QuantumProcessor {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuantumProcessor>(
                "QuantumEnhancedSystem.QuantumProcessor",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QuantumProcessor {
        const NAME: &'static str = "QuantumProcessor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QuantumProcessor {
            QuantumProcessor::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QuantumProcessor {
            static instance: QuantumProcessor = QuantumProcessor {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QuantumProcessor {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QuantumEnhancedSystem.QuantumProcessor").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QuantumProcessor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QuantumProcessor {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `QuantumProcessor`
    pub mod quantum_processor {
        // @@protoc_insertion_point(message:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Architecture {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.processor_type)
            pub processor_type: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.qubit_count)
            pub qubit_count: u32,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.coherence_time_us)
            pub coherence_time_us: f64,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.error_rates)
            pub error_rates: ::std::collections::HashMap<::std::string::String, f32>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.error_correction)
            pub error_correction: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.quantum_operations)
            pub quantum_operations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.topology)
            pub topology: ::std::collections::HashMap<::std::string::String, u32>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Architecture {
            fn default() -> &'a Architecture {
                <Architecture as ::protobuf::Message>::default_instance()
            }
        }

        impl Architecture {
            pub fn new() -> Architecture {
                ::std::default::Default::default()
            }

            // string processor_type = 1;

            pub fn processor_type(&self) -> &str {
                &self.processor_type
            }

            pub fn clear_processor_type(&mut self) {
                self.processor_type.clear();
            }

            // Param is passed by value, moved
            pub fn set_processor_type(&mut self, v: ::std::string::String) {
                self.processor_type = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_processor_type(&mut self) -> &mut ::std::string::String {
                &mut self.processor_type
            }

            // Take field
            pub fn take_processor_type(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.processor_type, ::std::string::String::new())
            }

            // uint32 qubit_count = 2;

            pub fn qubit_count(&self) -> u32 {
                self.qubit_count
            }

            pub fn clear_qubit_count(&mut self) {
                self.qubit_count = 0;
            }

            // Param is passed by value, moved
            pub fn set_qubit_count(&mut self, v: u32) {
                self.qubit_count = v;
            }

            // double coherence_time_us = 3;

            pub fn coherence_time_us(&self) -> f64 {
                self.coherence_time_us
            }

            pub fn clear_coherence_time_us(&mut self) {
                self.coherence_time_us = 0.;
            }

            // Param is passed by value, moved
            pub fn set_coherence_time_us(&mut self, v: f64) {
                self.coherence_time_us = v;
            }

            // repeated .kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.ErrorRatesEntry error_rates = 4;

            pub fn error_rates(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
                &self.error_rates
            }

            pub fn clear_error_rates(&mut self) {
                self.error_rates.clear();
            }

            // Param is passed by value, moved
            pub fn set_error_rates(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
                self.error_rates = v;
            }

            // Mutable pointer to the field.
            pub fn mut_error_rates(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
                &mut self.error_rates
            }

            // Take field
            pub fn take_error_rates(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
                ::std::mem::replace(&mut self.error_rates, ::std::collections::HashMap::new())
            }

            // bool error_correction = 5;

            pub fn error_correction(&self) -> bool {
                self.error_correction
            }

            pub fn clear_error_correction(&mut self) {
                self.error_correction = false;
            }

            // Param is passed by value, moved
            pub fn set_error_correction(&mut self, v: bool) {
                self.error_correction = v;
            }

            // repeated string quantum_operations = 6;

            pub fn quantum_operations(&self) -> &[::std::string::String] {
                &self.quantum_operations
            }

            pub fn clear_quantum_operations(&mut self) {
                self.quantum_operations.clear();
            }

            // Param is passed by value, moved
            pub fn set_quantum_operations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.quantum_operations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_quantum_operations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.quantum_operations
            }

            // Take field
            pub fn take_quantum_operations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.quantum_operations, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.TopologyEntry topology = 7;

            pub fn topology(&self) -> &::std::collections::HashMap<::std::string::String, u32> {
                &self.topology
            }

            pub fn clear_topology(&mut self) {
                self.topology.clear();
            }

            // Param is passed by value, moved
            pub fn set_topology(&mut self, v: ::std::collections::HashMap<::std::string::String, u32>) {
                self.topology = v;
            }

            // Mutable pointer to the field.
            pub fn mut_topology(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u32> {
                &mut self.topology
            }

            // Take field
            pub fn take_topology(&mut self) -> ::std::collections::HashMap<::std::string::String, u32> {
                ::std::mem::replace(&mut self.topology, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(7);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "processor_type",
                    |m: &Architecture| { &m.processor_type },
                    |m: &mut Architecture| { &mut m.processor_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "qubit_count",
                    |m: &Architecture| { &m.qubit_count },
                    |m: &mut Architecture| { &mut m.qubit_count },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "coherence_time_us",
                    |m: &Architecture| { &m.coherence_time_us },
                    |m: &mut Architecture| { &mut m.coherence_time_us },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "error_rates",
                    |m: &Architecture| { &m.error_rates },
                    |m: &mut Architecture| { &mut m.error_rates },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "error_correction",
                    |m: &Architecture| { &m.error_correction },
                    |m: &mut Architecture| { &mut m.error_correction },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "quantum_operations",
                    |m: &Architecture| { &m.quantum_operations },
                    |m: &mut Architecture| { &mut m.quantum_operations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "topology",
                    |m: &Architecture| { &m.topology },
                    |m: &mut Architecture| { &mut m.topology },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Architecture>(
                    "QuantumEnhancedSystem.QuantumProcessor.Architecture",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Architecture {
            const NAME: &'static str = "Architecture";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.processor_type = is.read_string()?;
                        },
                        16 => {
                            self.qubit_count = is.read_uint32()?;
                        },
                        25 => {
                            self.coherence_time_us = is.read_double()?;
                        },
                        34 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    21 => value = is.read_float()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.error_rates.insert(key, value);
                        },
                        40 => {
                            self.error_correction = is.read_bool()?;
                        },
                        50 => {
                            self.quantum_operations.push(is.read_string()?);
                        },
                        58 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    16 => value = is.read_uint32()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.topology.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.processor_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.processor_type);
                }
                if self.qubit_count != 0 {
                    my_size += ::protobuf::rt::uint32_size(2, self.qubit_count);
                }
                if self.coherence_time_us != 0. {
                    my_size += 1 + 8;
                }
                for (k, v) in &self.error_rates {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.error_correction != false {
                    my_size += 1 + 1;
                }
                for value in &self.quantum_operations {
                    my_size += ::protobuf::rt::string_size(6, &value);
                };
                for (k, v) in &self.topology {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.processor_type.is_empty() {
                    os.write_string(1, &self.processor_type)?;
                }
                if self.qubit_count != 0 {
                    os.write_uint32(2, self.qubit_count)?;
                }
                if self.coherence_time_us != 0. {
                    os.write_double(3, self.coherence_time_us)?;
                }
                for (k, v) in &self.error_rates {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    os.write_raw_varint32(34)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_float(2, *v)?;
                };
                if self.error_correction != false {
                    os.write_bool(5, self.error_correction)?;
                }
                for v in &self.quantum_operations {
                    os.write_string(6, &v)?;
                };
                for (k, v) in &self.topology {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    os.write_raw_varint32(58)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_uint32(2, *v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Architecture {
                Architecture::new()
            }

            fn clear(&mut self) {
                self.processor_type.clear();
                self.qubit_count = 0;
                self.coherence_time_us = 0.;
                self.error_rates.clear();
                self.error_correction = false;
                self.quantum_operations.clear();
                self.topology.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Architecture {
                static instance: ::protobuf::rt::Lazy<Architecture> = ::protobuf::rt::Lazy::new();
                instance.get(Architecture::new)
            }
        }

        impl ::protobuf::MessageFull for Architecture {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QuantumEnhancedSystem.QuantumProcessor.Architecture").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Architecture {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Architecture {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct QuantumCompiler {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.optimization_passes)
            pub optimization_passes: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.compilation_rules)
            pub compilation_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.circuit_optimization)
            pub circuit_optimization: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.mapping_strategies)
            pub mapping_strategies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.error_mitigation)
            pub error_mitigation: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a QuantumCompiler {
            fn default() -> &'a QuantumCompiler {
                <QuantumCompiler as ::protobuf::Message>::default_instance()
            }
        }

        impl QuantumCompiler {
            pub fn new() -> QuantumCompiler {
                ::std::default::Default::default()
            }

            // repeated string optimization_passes = 1;

            pub fn optimization_passes(&self) -> &[::std::string::String] {
                &self.optimization_passes
            }

            pub fn clear_optimization_passes(&mut self) {
                self.optimization_passes.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_passes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimization_passes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_passes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimization_passes
            }

            // Take field
            pub fn take_optimization_passes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimization_passes, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.CompilationRulesEntry compilation_rules = 2;

            pub fn compilation_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.compilation_rules
            }

            pub fn clear_compilation_rules(&mut self) {
                self.compilation_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_compilation_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.compilation_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compilation_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.compilation_rules
            }

            // Take field
            pub fn take_compilation_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.compilation_rules, ::std::collections::HashMap::new())
            }

            // bool circuit_optimization = 3;

            pub fn circuit_optimization(&self) -> bool {
                self.circuit_optimization
            }

            pub fn clear_circuit_optimization(&mut self) {
                self.circuit_optimization = false;
            }

            // Param is passed by value, moved
            pub fn set_circuit_optimization(&mut self, v: bool) {
                self.circuit_optimization = v;
            }

            // repeated string mapping_strategies = 4;

            pub fn mapping_strategies(&self) -> &[::std::string::String] {
                &self.mapping_strategies
            }

            pub fn clear_mapping_strategies(&mut self) {
                self.mapping_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_mapping_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.mapping_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_mapping_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.mapping_strategies
            }

            // Take field
            pub fn take_mapping_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.mapping_strategies, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler.ErrorMitigationEntry error_mitigation = 5;

            pub fn error_mitigation(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.error_mitigation
            }

            pub fn clear_error_mitigation(&mut self) {
                self.error_mitigation.clear();
            }

            // Param is passed by value, moved
            pub fn set_error_mitigation(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.error_mitigation = v;
            }

            // Mutable pointer to the field.
            pub fn mut_error_mitigation(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.error_mitigation
            }

            // Take field
            pub fn take_error_mitigation(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.error_mitigation, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimization_passes",
                    |m: &QuantumCompiler| { &m.optimization_passes },
                    |m: &mut QuantumCompiler| { &mut m.optimization_passes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "compilation_rules",
                    |m: &QuantumCompiler| { &m.compilation_rules },
                    |m: &mut QuantumCompiler| { &mut m.compilation_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "circuit_optimization",
                    |m: &QuantumCompiler| { &m.circuit_optimization },
                    |m: &mut QuantumCompiler| { &mut m.circuit_optimization },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "mapping_strategies",
                    |m: &QuantumCompiler| { &m.mapping_strategies },
                    |m: &mut QuantumCompiler| { &mut m.mapping_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "error_mitigation",
                    |m: &QuantumCompiler| { &m.error_mitigation },
                    |m: &mut QuantumCompiler| { &mut m.error_mitigation },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuantumCompiler>(
                    "QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for QuantumCompiler {
            const NAME: &'static str = "QuantumCompiler";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.optimization_passes.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.compilation_rules.insert(key, value);
                        },
                        24 => {
                            self.circuit_optimization = is.read_bool()?;
                        },
                        34 => {
                            self.mapping_strategies.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.error_mitigation.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.optimization_passes {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.compilation_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.circuit_optimization != false {
                    my_size += 1 + 1;
                }
                for value in &self.mapping_strategies {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.error_mitigation {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.optimization_passes {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.compilation_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.circuit_optimization != false {
                    os.write_bool(3, self.circuit_optimization)?;
                }
                for v in &self.mapping_strategies {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.error_mitigation {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> QuantumCompiler {
                QuantumCompiler::new()
            }

            fn clear(&mut self) {
                self.optimization_passes.clear();
                self.compilation_rules.clear();
                self.circuit_optimization = false;
                self.mapping_strategies.clear();
                self.error_mitigation.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static QuantumCompiler {
                static instance: ::protobuf::rt::Lazy<QuantumCompiler> = ::protobuf::rt::Lazy::new();
                instance.get(QuantumCompiler::new)
            }
        }

        impl ::protobuf::MessageFull for QuantumCompiler {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QuantumEnhancedSystem.QuantumProcessor.QuantumCompiler").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for QuantumCompiler {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for QuantumCompiler {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HybridAlgorithms {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HybridAlgorithms {
        fn default() -> &'a HybridAlgorithms {
            <HybridAlgorithms as ::protobuf::Message>::default_instance()
        }
    }

    impl HybridAlgorithms {
        pub fn new() -> HybridAlgorithms {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HybridAlgorithms>(
                "QuantumEnhancedSystem.HybridAlgorithms",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HybridAlgorithms {
        const NAME: &'static str = "HybridAlgorithms";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HybridAlgorithms {
            HybridAlgorithms::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HybridAlgorithms {
            static instance: HybridAlgorithms = HybridAlgorithms {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HybridAlgorithms {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QuantumEnhancedSystem.HybridAlgorithms").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HybridAlgorithms {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HybridAlgorithms {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `HybridAlgorithms`
    pub mod hybrid_algorithms {
        // @@protoc_insertion_point(message:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct QuantumClassicalInterface {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface.classical_subroutines)
            pub classical_subroutines: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface.quantum_subroutines)
            pub quantum_subroutines: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface.adaptive_execution)
            pub adaptive_execution: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface.feedback_mechanisms)
            pub feedback_mechanisms: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a QuantumClassicalInterface {
            fn default() -> &'a QuantumClassicalInterface {
                <QuantumClassicalInterface as ::protobuf::Message>::default_instance()
            }
        }

        impl QuantumClassicalInterface {
            pub fn new() -> QuantumClassicalInterface {
                ::std::default::Default::default()
            }

            // repeated string classical_subroutines = 1;

            pub fn classical_subroutines(&self) -> &[::std::string::String] {
                &self.classical_subroutines
            }

            pub fn clear_classical_subroutines(&mut self) {
                self.classical_subroutines.clear();
            }

            // Param is passed by value, moved
            pub fn set_classical_subroutines(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.classical_subroutines = v;
            }

            // Mutable pointer to the field.
            pub fn mut_classical_subroutines(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.classical_subroutines
            }

            // Take field
            pub fn take_classical_subroutines(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.classical_subroutines, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface.QuantumSubroutinesEntry quantum_subroutines = 2;

            pub fn quantum_subroutines(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.quantum_subroutines
            }

            pub fn clear_quantum_subroutines(&mut self) {
                self.quantum_subroutines.clear();
            }

            // Param is passed by value, moved
            pub fn set_quantum_subroutines(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.quantum_subroutines = v;
            }

            // Mutable pointer to the field.
            pub fn mut_quantum_subroutines(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.quantum_subroutines
            }

            // Take field
            pub fn take_quantum_subroutines(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.quantum_subroutines, ::std::collections::HashMap::new())
            }

            // bool adaptive_execution = 3;

            pub fn adaptive_execution(&self) -> bool {
                self.adaptive_execution
            }

            pub fn clear_adaptive_execution(&mut self) {
                self.adaptive_execution = false;
            }

            // Param is passed by value, moved
            pub fn set_adaptive_execution(&mut self, v: bool) {
                self.adaptive_execution = v;
            }

            // repeated string feedback_mechanisms = 4;

            pub fn feedback_mechanisms(&self) -> &[::std::string::String] {
                &self.feedback_mechanisms
            }

            pub fn clear_feedback_mechanisms(&mut self) {
                self.feedback_mechanisms.clear();
            }

            // Param is passed by value, moved
            pub fn set_feedback_mechanisms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.feedback_mechanisms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_feedback_mechanisms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.feedback_mechanisms
            }

            // Take field
            pub fn take_feedback_mechanisms(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.feedback_mechanisms, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "classical_subroutines",
                    |m: &QuantumClassicalInterface| { &m.classical_subroutines },
                    |m: &mut QuantumClassicalInterface| { &mut m.classical_subroutines },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "quantum_subroutines",
                    |m: &QuantumClassicalInterface| { &m.quantum_subroutines },
                    |m: &mut QuantumClassicalInterface| { &mut m.quantum_subroutines },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "adaptive_execution",
                    |m: &QuantumClassicalInterface| { &m.adaptive_execution },
                    |m: &mut QuantumClassicalInterface| { &mut m.adaptive_execution },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "feedback_mechanisms",
                    |m: &QuantumClassicalInterface| { &m.feedback_mechanisms },
                    |m: &mut QuantumClassicalInterface| { &mut m.feedback_mechanisms },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuantumClassicalInterface>(
                    "QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for QuantumClassicalInterface {
            const NAME: &'static str = "QuantumClassicalInterface";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.classical_subroutines.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.quantum_subroutines.insert(key, value);
                        },
                        24 => {
                            self.adaptive_execution = is.read_bool()?;
                        },
                        34 => {
                            self.feedback_mechanisms.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.classical_subroutines {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.quantum_subroutines {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.adaptive_execution != false {
                    my_size += 1 + 1;
                }
                for value in &self.feedback_mechanisms {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.classical_subroutines {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.quantum_subroutines {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.adaptive_execution != false {
                    os.write_bool(3, self.adaptive_execution)?;
                }
                for v in &self.feedback_mechanisms {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> QuantumClassicalInterface {
                QuantumClassicalInterface::new()
            }

            fn clear(&mut self) {
                self.classical_subroutines.clear();
                self.quantum_subroutines.clear();
                self.adaptive_execution = false;
                self.feedback_mechanisms.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static QuantumClassicalInterface {
                static instance: ::protobuf::rt::Lazy<QuantumClassicalInterface> = ::protobuf::rt::Lazy::new();
                instance.get(QuantumClassicalInterface::new)
            }
        }

        impl ::protobuf::MessageFull for QuantumClassicalInterface {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterface").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for QuantumClassicalInterface {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for QuantumClassicalInterface {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct OptimizationStrategies {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies.variational_algorithms)
            pub variational_algorithms: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies.optimization_params)
            pub optimization_params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies.noise_resilient)
            pub noise_resilient: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies.convergence_criteria)
            pub convergence_criteria: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a OptimizationStrategies {
            fn default() -> &'a OptimizationStrategies {
                <OptimizationStrategies as ::protobuf::Message>::default_instance()
            }
        }

        impl OptimizationStrategies {
            pub fn new() -> OptimizationStrategies {
                ::std::default::Default::default()
            }

            // repeated string variational_algorithms = 1;

            pub fn variational_algorithms(&self) -> &[::std::string::String] {
                &self.variational_algorithms
            }

            pub fn clear_variational_algorithms(&mut self) {
                self.variational_algorithms.clear();
            }

            // Param is passed by value, moved
            pub fn set_variational_algorithms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.variational_algorithms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_variational_algorithms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.variational_algorithms
            }

            // Take field
            pub fn take_variational_algorithms(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.variational_algorithms, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies.OptimizationParamsEntry optimization_params = 2;

            pub fn optimization_params(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.optimization_params
            }

            pub fn clear_optimization_params(&mut self) {
                self.optimization_params.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_params(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.optimization_params = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.optimization_params
            }

            // Take field
            pub fn take_optimization_params(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.optimization_params, ::std::collections::HashMap::new())
            }

            // bool noise_resilient = 3;

            pub fn noise_resilient(&self) -> bool {
                self.noise_resilient
            }

            pub fn clear_noise_resilient(&mut self) {
                self.noise_resilient = false;
            }

            // Param is passed by value, moved
            pub fn set_noise_resilient(&mut self, v: bool) {
                self.noise_resilient = v;
            }

            // repeated string convergence_criteria = 4;

            pub fn convergence_criteria(&self) -> &[::std::string::String] {
                &self.convergence_criteria
            }

            pub fn clear_convergence_criteria(&mut self) {
                self.convergence_criteria.clear();
            }

            // Param is passed by value, moved
            pub fn set_convergence_criteria(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.convergence_criteria = v;
            }

            // Mutable pointer to the field.
            pub fn mut_convergence_criteria(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.convergence_criteria
            }

            // Take field
            pub fn take_convergence_criteria(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.convergence_criteria, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "variational_algorithms",
                    |m: &OptimizationStrategies| { &m.variational_algorithms },
                    |m: &mut OptimizationStrategies| { &mut m.variational_algorithms },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "optimization_params",
                    |m: &OptimizationStrategies| { &m.optimization_params },
                    |m: &mut OptimizationStrategies| { &mut m.optimization_params },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "noise_resilient",
                    |m: &OptimizationStrategies| { &m.noise_resilient },
                    |m: &mut OptimizationStrategies| { &mut m.noise_resilient },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "convergence_criteria",
                    |m: &OptimizationStrategies| { &m.convergence_criteria },
                    |m: &mut OptimizationStrategies| { &mut m.convergence_criteria },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptimizationStrategies>(
                    "QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for OptimizationStrategies {
            const NAME: &'static str = "OptimizationStrategies";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.variational_algorithms.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.optimization_params.insert(key, value);
                        },
                        24 => {
                            self.noise_resilient = is.read_bool()?;
                        },
                        34 => {
                            self.convergence_criteria.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.variational_algorithms {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.optimization_params {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.noise_resilient != false {
                    my_size += 1 + 1;
                }
                for value in &self.convergence_criteria {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.variational_algorithms {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.optimization_params {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.noise_resilient != false {
                    os.write_bool(3, self.noise_resilient)?;
                }
                for v in &self.convergence_criteria {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> OptimizationStrategies {
                OptimizationStrategies::new()
            }

            fn clear(&mut self) {
                self.variational_algorithms.clear();
                self.optimization_params.clear();
                self.noise_resilient = false;
                self.convergence_criteria.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static OptimizationStrategies {
                static instance: ::protobuf::rt::Lazy<OptimizationStrategies> = ::protobuf::rt::Lazy::new();
                instance.get(OptimizationStrategies::new)
            }
        }

        impl ::protobuf::MessageFull for OptimizationStrategies {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QuantumEnhancedSystem.HybridAlgorithms.OptimizationStrategies").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for OptimizationStrategies {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for OptimizationStrategies {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NeuralArchitectureSystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NeuralArchitectureSystem {
    fn default() -> &'a NeuralArchitectureSystem {
        <NeuralArchitectureSystem as ::protobuf::Message>::default_instance()
    }
}

impl NeuralArchitectureSystem {
    pub fn new() -> NeuralArchitectureSystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NeuralArchitectureSystem>(
            "NeuralArchitectureSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NeuralArchitectureSystem {
    const NAME: &'static str = "NeuralArchitectureSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NeuralArchitectureSystem {
        NeuralArchitectureSystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NeuralArchitectureSystem {
        static instance: NeuralArchitectureSystem = NeuralArchitectureSystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NeuralArchitectureSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NeuralArchitectureSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NeuralArchitectureSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `NeuralArchitectureSystem`
pub mod neural_architecture_system {
    // @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AdvancedNetworks {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AdvancedNetworks {
        fn default() -> &'a AdvancedNetworks {
            <AdvancedNetworks as ::protobuf::Message>::default_instance()
        }
    }

    impl AdvancedNetworks {
        pub fn new() -> AdvancedNetworks {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdvancedNetworks>(
                "NeuralArchitectureSystem.AdvancedNetworks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AdvancedNetworks {
        const NAME: &'static str = "AdvancedNetworks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AdvancedNetworks {
            AdvancedNetworks::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AdvancedNetworks {
            static instance: AdvancedNetworks = AdvancedNetworks {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AdvancedNetworks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem.AdvancedNetworks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AdvancedNetworks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AdvancedNetworks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AdvancedNetworks`
    pub mod advanced_networks {
        // @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct LayerDefinitions {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.layer_types)
            pub layer_types: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.layer_configs)
            pub layer_configs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.dynamic_architecture)
            pub dynamic_architecture: bool,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.activation_functions)
            pub activation_functions: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.initialization_rules)
            pub initialization_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a LayerDefinitions {
            fn default() -> &'a LayerDefinitions {
                <LayerDefinitions as ::protobuf::Message>::default_instance()
            }
        }

        impl LayerDefinitions {
            pub fn new() -> LayerDefinitions {
                ::std::default::Default::default()
            }

            // repeated string layer_types = 1;

            pub fn layer_types(&self) -> &[::std::string::String] {
                &self.layer_types
            }

            pub fn clear_layer_types(&mut self) {
                self.layer_types.clear();
            }

            // Param is passed by value, moved
            pub fn set_layer_types(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.layer_types = v;
            }

            // Mutable pointer to the field.
            pub fn mut_layer_types(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.layer_types
            }

            // Take field
            pub fn take_layer_types(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.layer_types, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.LayerConfigsEntry layer_configs = 2;

            pub fn layer_configs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.layer_configs
            }

            pub fn clear_layer_configs(&mut self) {
                self.layer_configs.clear();
            }

            // Param is passed by value, moved
            pub fn set_layer_configs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.layer_configs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_layer_configs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.layer_configs
            }

            // Take field
            pub fn take_layer_configs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.layer_configs, ::std::collections::HashMap::new())
            }

            // bool dynamic_architecture = 3;

            pub fn dynamic_architecture(&self) -> bool {
                self.dynamic_architecture
            }

            pub fn clear_dynamic_architecture(&mut self) {
                self.dynamic_architecture = false;
            }

            // Param is passed by value, moved
            pub fn set_dynamic_architecture(&mut self, v: bool) {
                self.dynamic_architecture = v;
            }

            // repeated string activation_functions = 4;

            pub fn activation_functions(&self) -> &[::std::string::String] {
                &self.activation_functions
            }

            pub fn clear_activation_functions(&mut self) {
                self.activation_functions.clear();
            }

            // Param is passed by value, moved
            pub fn set_activation_functions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.activation_functions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_activation_functions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.activation_functions
            }

            // Take field
            pub fn take_activation_functions(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.activation_functions, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions.InitializationRulesEntry initialization_rules = 5;

            pub fn initialization_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.initialization_rules
            }

            pub fn clear_initialization_rules(&mut self) {
                self.initialization_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_initialization_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.initialization_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_initialization_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.initialization_rules
            }

            // Take field
            pub fn take_initialization_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.initialization_rules, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "layer_types",
                    |m: &LayerDefinitions| { &m.layer_types },
                    |m: &mut LayerDefinitions| { &mut m.layer_types },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "layer_configs",
                    |m: &LayerDefinitions| { &m.layer_configs },
                    |m: &mut LayerDefinitions| { &mut m.layer_configs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "dynamic_architecture",
                    |m: &LayerDefinitions| { &m.dynamic_architecture },
                    |m: &mut LayerDefinitions| { &mut m.dynamic_architecture },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "activation_functions",
                    |m: &LayerDefinitions| { &m.activation_functions },
                    |m: &mut LayerDefinitions| { &mut m.activation_functions },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "initialization_rules",
                    |m: &LayerDefinitions| { &m.initialization_rules },
                    |m: &mut LayerDefinitions| { &mut m.initialization_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LayerDefinitions>(
                    "NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for LayerDefinitions {
            const NAME: &'static str = "LayerDefinitions";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.layer_types.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.layer_configs.insert(key, value);
                        },
                        24 => {
                            self.dynamic_architecture = is.read_bool()?;
                        },
                        34 => {
                            self.activation_functions.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.initialization_rules.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.layer_types {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.layer_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.dynamic_architecture != false {
                    my_size += 1 + 1;
                }
                for value in &self.activation_functions {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.initialization_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.layer_types {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.layer_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.dynamic_architecture != false {
                    os.write_bool(3, self.dynamic_architecture)?;
                }
                for v in &self.activation_functions {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.initialization_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> LayerDefinitions {
                LayerDefinitions::new()
            }

            fn clear(&mut self) {
                self.layer_types.clear();
                self.layer_configs.clear();
                self.dynamic_architecture = false;
                self.activation_functions.clear();
                self.initialization_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static LayerDefinitions {
                static instance: ::protobuf::rt::Lazy<LayerDefinitions> = ::protobuf::rt::Lazy::new();
                instance.get(LayerDefinitions::new)
            }
        }

        impl ::protobuf::MessageFull for LayerDefinitions {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem.AdvancedNetworks.LayerDefinitions").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for LayerDefinitions {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for LayerDefinitions {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TrainingSystem {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.training_algorithms)
            pub training_algorithms: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.learning_parameters)
            pub learning_parameters: ::std::collections::HashMap<::std::string::String, f32>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.distributed_training)
            pub distributed_training: bool,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.optimization_methods)
            pub optimization_methods: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.regularization)
            pub regularization: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TrainingSystem {
            fn default() -> &'a TrainingSystem {
                <TrainingSystem as ::protobuf::Message>::default_instance()
            }
        }

        impl TrainingSystem {
            pub fn new() -> TrainingSystem {
                ::std::default::Default::default()
            }

            // repeated string training_algorithms = 1;

            pub fn training_algorithms(&self) -> &[::std::string::String] {
                &self.training_algorithms
            }

            pub fn clear_training_algorithms(&mut self) {
                self.training_algorithms.clear();
            }

            // Param is passed by value, moved
            pub fn set_training_algorithms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.training_algorithms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_training_algorithms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.training_algorithms
            }

            // Take field
            pub fn take_training_algorithms(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.training_algorithms, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.LearningParametersEntry learning_parameters = 2;

            pub fn learning_parameters(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
                &self.learning_parameters
            }

            pub fn clear_learning_parameters(&mut self) {
                self.learning_parameters.clear();
            }

            // Param is passed by value, moved
            pub fn set_learning_parameters(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
                self.learning_parameters = v;
            }

            // Mutable pointer to the field.
            pub fn mut_learning_parameters(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
                &mut self.learning_parameters
            }

            // Take field
            pub fn take_learning_parameters(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
                ::std::mem::replace(&mut self.learning_parameters, ::std::collections::HashMap::new())
            }

            // bool distributed_training = 3;

            pub fn distributed_training(&self) -> bool {
                self.distributed_training
            }

            pub fn clear_distributed_training(&mut self) {
                self.distributed_training = false;
            }

            // Param is passed by value, moved
            pub fn set_distributed_training(&mut self, v: bool) {
                self.distributed_training = v;
            }

            // repeated string optimization_methods = 4;

            pub fn optimization_methods(&self) -> &[::std::string::String] {
                &self.optimization_methods
            }

            pub fn clear_optimization_methods(&mut self) {
                self.optimization_methods.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_methods(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimization_methods = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_methods(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimization_methods
            }

            // Take field
            pub fn take_optimization_methods(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimization_methods, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.RegularizationEntry regularization = 5;

            pub fn regularization(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.regularization
            }

            pub fn clear_regularization(&mut self) {
                self.regularization.clear();
            }

            // Param is passed by value, moved
            pub fn set_regularization(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.regularization = v;
            }

            // Mutable pointer to the field.
            pub fn mut_regularization(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.regularization
            }

            // Take field
            pub fn take_regularization(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.regularization, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "training_algorithms",
                    |m: &TrainingSystem| { &m.training_algorithms },
                    |m: &mut TrainingSystem| { &mut m.training_algorithms },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "learning_parameters",
                    |m: &TrainingSystem| { &m.learning_parameters },
                    |m: &mut TrainingSystem| { &mut m.learning_parameters },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "distributed_training",
                    |m: &TrainingSystem| { &m.distributed_training },
                    |m: &mut TrainingSystem| { &mut m.distributed_training },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimization_methods",
                    |m: &TrainingSystem| { &m.optimization_methods },
                    |m: &mut TrainingSystem| { &mut m.optimization_methods },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "regularization",
                    |m: &TrainingSystem| { &m.regularization },
                    |m: &mut TrainingSystem| { &mut m.regularization },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TrainingSystem>(
                    "NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TrainingSystem {
            const NAME: &'static str = "TrainingSystem";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.training_algorithms.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    21 => value = is.read_float()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.learning_parameters.insert(key, value);
                        },
                        24 => {
                            self.distributed_training = is.read_bool()?;
                        },
                        34 => {
                            self.optimization_methods.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.regularization.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.training_algorithms {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.learning_parameters {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.distributed_training != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimization_methods {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.regularization {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.training_algorithms {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.learning_parameters {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_float(2, *v)?;
                };
                if self.distributed_training != false {
                    os.write_bool(3, self.distributed_training)?;
                }
                for v in &self.optimization_methods {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.regularization {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TrainingSystem {
                TrainingSystem::new()
            }

            fn clear(&mut self) {
                self.training_algorithms.clear();
                self.learning_parameters.clear();
                self.distributed_training = false;
                self.optimization_methods.clear();
                self.regularization.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TrainingSystem {
                static instance: ::protobuf::rt::Lazy<TrainingSystem> = ::protobuf::rt::Lazy::new();
                instance.get(TrainingSystem::new)
            }
        }

        impl ::protobuf::MessageFull for TrainingSystem {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TrainingSystem {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TrainingSystem {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MetaLearning {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning.meta_optimization)
            pub meta_optimization: bool,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning.adaptation_strategies)
            pub adaptation_strategies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning.transfer_learning)
            pub transfer_learning: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning.few_shot_learning)
            pub few_shot_learning: bool,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning.meta_parameters)
            pub meta_parameters: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MetaLearning {
            fn default() -> &'a MetaLearning {
                <MetaLearning as ::protobuf::Message>::default_instance()
            }
        }

        impl MetaLearning {
            pub fn new() -> MetaLearning {
                ::std::default::Default::default()
            }

            // bool meta_optimization = 1;

            pub fn meta_optimization(&self) -> bool {
                self.meta_optimization
            }

            pub fn clear_meta_optimization(&mut self) {
                self.meta_optimization = false;
            }

            // Param is passed by value, moved
            pub fn set_meta_optimization(&mut self, v: bool) {
                self.meta_optimization = v;
            }

            // repeated string adaptation_strategies = 2;

            pub fn adaptation_strategies(&self) -> &[::std::string::String] {
                &self.adaptation_strategies
            }

            pub fn clear_adaptation_strategies(&mut self) {
                self.adaptation_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_adaptation_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.adaptation_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_adaptation_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.adaptation_strategies
            }

            // Take field
            pub fn take_adaptation_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.adaptation_strategies, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLearning.TransferLearningEntry transfer_learning = 3;

            pub fn transfer_learning(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.transfer_learning
            }

            pub fn clear_transfer_learning(&mut self) {
                self.transfer_learning.clear();
            }

            // Param is passed by value, moved
            pub fn set_transfer_learning(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.transfer_learning = v;
            }

            // Mutable pointer to the field.
            pub fn mut_transfer_learning(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.transfer_learning
            }

            // Take field
            pub fn take_transfer_learning(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.transfer_learning, ::std::collections::HashMap::new())
            }

            // bool few_shot_learning = 4;

            pub fn few_shot_learning(&self) -> bool {
                self.few_shot_learning
            }

            pub fn clear_few_shot_learning(&mut self) {
                self.few_shot_learning = false;
            }

            // Param is passed by value, moved
            pub fn set_few_shot_learning(&mut self, v: bool) {
                self.few_shot_learning = v;
            }

            // repeated string meta_parameters = 5;

            pub fn meta_parameters(&self) -> &[::std::string::String] {
                &self.meta_parameters
            }

            pub fn clear_meta_parameters(&mut self) {
                self.meta_parameters.clear();
            }

            // Param is passed by value, moved
            pub fn set_meta_parameters(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.meta_parameters = v;
            }

            // Mutable pointer to the field.
            pub fn mut_meta_parameters(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.meta_parameters
            }

            // Take field
            pub fn take_meta_parameters(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.meta_parameters, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "meta_optimization",
                    |m: &MetaLearning| { &m.meta_optimization },
                    |m: &mut MetaLearning| { &mut m.meta_optimization },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "adaptation_strategies",
                    |m: &MetaLearning| { &m.adaptation_strategies },
                    |m: &mut MetaLearning| { &mut m.adaptation_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "transfer_learning",
                    |m: &MetaLearning| { &m.transfer_learning },
                    |m: &mut MetaLearning| { &mut m.transfer_learning },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "few_shot_learning",
                    |m: &MetaLearning| { &m.few_shot_learning },
                    |m: &mut MetaLearning| { &mut m.few_shot_learning },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "meta_parameters",
                    |m: &MetaLearning| { &m.meta_parameters },
                    |m: &mut MetaLearning| { &mut m.meta_parameters },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetaLearning>(
                    "NeuralArchitectureSystem.AdvancedNetworks.MetaLearning",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MetaLearning {
            const NAME: &'static str = "MetaLearning";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.meta_optimization = is.read_bool()?;
                        },
                        18 => {
                            self.adaptation_strategies.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.transfer_learning.insert(key, value);
                        },
                        32 => {
                            self.few_shot_learning = is.read_bool()?;
                        },
                        42 => {
                            self.meta_parameters.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.meta_optimization != false {
                    my_size += 1 + 1;
                }
                for value in &self.adaptation_strategies {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.transfer_learning {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.few_shot_learning != false {
                    my_size += 1 + 1;
                }
                for value in &self.meta_parameters {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.meta_optimization != false {
                    os.write_bool(1, self.meta_optimization)?;
                }
                for v in &self.adaptation_strategies {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.transfer_learning {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.few_shot_learning != false {
                    os.write_bool(4, self.few_shot_learning)?;
                }
                for v in &self.meta_parameters {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MetaLearning {
                MetaLearning::new()
            }

            fn clear(&mut self) {
                self.meta_optimization = false;
                self.adaptation_strategies.clear();
                self.transfer_learning.clear();
                self.few_shot_learning = false;
                self.meta_parameters.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MetaLearning {
                static instance: ::protobuf::rt::Lazy<MetaLearning> = ::protobuf::rt::Lazy::new();
                instance.get(MetaLearning::new)
            }
        }

        impl ::protobuf::MessageFull for MetaLearning {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem.AdvancedNetworks.MetaLearning").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MetaLearning {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MetaLearning {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem.AutoML)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutoML {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.AutoML.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutoML {
        fn default() -> &'a AutoML {
            <AutoML as ::protobuf::Message>::default_instance()
        }
    }

    impl AutoML {
        pub fn new() -> AutoML {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutoML>(
                "NeuralArchitectureSystem.AutoML",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AutoML {
        const NAME: &'static str = "AutoML";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutoML {
            AutoML::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutoML {
            static instance: AutoML = AutoML {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AutoML {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem.AutoML").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AutoML {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutoML {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AutoML`
    pub mod auto_ml {
        // @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ArchitectureSearch {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch.search_space)
            pub search_space: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch.search_strategies)
            pub search_strategies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch.progressive_search)
            pub progressive_search: bool,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch.evaluation_metrics)
            pub evaluation_metrics: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ArchitectureSearch {
            fn default() -> &'a ArchitectureSearch {
                <ArchitectureSearch as ::protobuf::Message>::default_instance()
            }
        }

        impl ArchitectureSearch {
            pub fn new() -> ArchitectureSearch {
                ::std::default::Default::default()
            }

            // repeated string search_space = 1;

            pub fn search_space(&self) -> &[::std::string::String] {
                &self.search_space
            }

            pub fn clear_search_space(&mut self) {
                self.search_space.clear();
            }

            // Param is passed by value, moved
            pub fn set_search_space(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.search_space = v;
            }

            // Mutable pointer to the field.
            pub fn mut_search_space(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.search_space
            }

            // Take field
            pub fn take_search_space(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.search_space, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch.SearchStrategiesEntry search_strategies = 2;

            pub fn search_strategies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.search_strategies
            }

            pub fn clear_search_strategies(&mut self) {
                self.search_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_search_strategies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.search_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_search_strategies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.search_strategies
            }

            // Take field
            pub fn take_search_strategies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.search_strategies, ::std::collections::HashMap::new())
            }

            // bool progressive_search = 3;

            pub fn progressive_search(&self) -> bool {
                self.progressive_search
            }

            pub fn clear_progressive_search(&mut self) {
                self.progressive_search = false;
            }

            // Param is passed by value, moved
            pub fn set_progressive_search(&mut self, v: bool) {
                self.progressive_search = v;
            }

            // repeated string evaluation_metrics = 4;

            pub fn evaluation_metrics(&self) -> &[::std::string::String] {
                &self.evaluation_metrics
            }

            pub fn clear_evaluation_metrics(&mut self) {
                self.evaluation_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_evaluation_metrics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.evaluation_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_evaluation_metrics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.evaluation_metrics
            }

            // Take field
            pub fn take_evaluation_metrics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.evaluation_metrics, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "search_space",
                    |m: &ArchitectureSearch| { &m.search_space },
                    |m: &mut ArchitectureSearch| { &mut m.search_space },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "search_strategies",
                    |m: &ArchitectureSearch| { &m.search_strategies },
                    |m: &mut ArchitectureSearch| { &mut m.search_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "progressive_search",
                    |m: &ArchitectureSearch| { &m.progressive_search },
                    |m: &mut ArchitectureSearch| { &mut m.progressive_search },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "evaluation_metrics",
                    |m: &ArchitectureSearch| { &m.evaluation_metrics },
                    |m: &mut ArchitectureSearch| { &mut m.evaluation_metrics },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArchitectureSearch>(
                    "NeuralArchitectureSystem.AutoML.ArchitectureSearch",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ArchitectureSearch {
            const NAME: &'static str = "ArchitectureSearch";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.search_space.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.search_strategies.insert(key, value);
                        },
                        24 => {
                            self.progressive_search = is.read_bool()?;
                        },
                        34 => {
                            self.evaluation_metrics.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.search_space {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.search_strategies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.progressive_search != false {
                    my_size += 1 + 1;
                }
                for value in &self.evaluation_metrics {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.search_space {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.search_strategies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.progressive_search != false {
                    os.write_bool(3, self.progressive_search)?;
                }
                for v in &self.evaluation_metrics {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ArchitectureSearch {
                ArchitectureSearch::new()
            }

            fn clear(&mut self) {
                self.search_space.clear();
                self.search_strategies.clear();
                self.progressive_search = false;
                self.evaluation_metrics.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ArchitectureSearch {
                static instance: ::protobuf::rt::Lazy<ArchitectureSearch> = ::protobuf::rt::Lazy::new();
                instance.get(ArchitectureSearch::new)
            }
        }

        impl ::protobuf::MessageFull for ArchitectureSearch {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem.AutoML.ArchitectureSearch").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ArchitectureSearch {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ArchitectureSearch {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.NeuralArchitectureSystem.AutoML.HyperparameterOptimization)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct HyperparameterOptimization {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.HyperparameterOptimization.tuning_algorithms)
            pub tuning_algorithms: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.HyperparameterOptimization.parameter_ranges)
            pub parameter_ranges: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.HyperparameterOptimization.bayesian_optimization)
            pub bayesian_optimization: bool,
            // @@protoc_insertion_point(field:kymera_mappings.NeuralArchitectureSystem.AutoML.HyperparameterOptimization.stopping_criteria)
            pub stopping_criteria: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.NeuralArchitectureSystem.AutoML.HyperparameterOptimization.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a HyperparameterOptimization {
            fn default() -> &'a HyperparameterOptimization {
                <HyperparameterOptimization as ::protobuf::Message>::default_instance()
            }
        }

        impl HyperparameterOptimization {
            pub fn new() -> HyperparameterOptimization {
                ::std::default::Default::default()
            }

            // repeated string tuning_algorithms = 1;

            pub fn tuning_algorithms(&self) -> &[::std::string::String] {
                &self.tuning_algorithms
            }

            pub fn clear_tuning_algorithms(&mut self) {
                self.tuning_algorithms.clear();
            }

            // Param is passed by value, moved
            pub fn set_tuning_algorithms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.tuning_algorithms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_tuning_algorithms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.tuning_algorithms
            }

            // Take field
            pub fn take_tuning_algorithms(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.tuning_algorithms, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.NeuralArchitectureSystem.AutoML.HyperparameterOptimization.ParameterRangesEntry parameter_ranges = 2;

            pub fn parameter_ranges(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.parameter_ranges
            }

            pub fn clear_parameter_ranges(&mut self) {
                self.parameter_ranges.clear();
            }

            // Param is passed by value, moved
            pub fn set_parameter_ranges(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.parameter_ranges = v;
            }

            // Mutable pointer to the field.
            pub fn mut_parameter_ranges(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.parameter_ranges
            }

            // Take field
            pub fn take_parameter_ranges(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.parameter_ranges, ::std::collections::HashMap::new())
            }

            // bool bayesian_optimization = 3;

            pub fn bayesian_optimization(&self) -> bool {
                self.bayesian_optimization
            }

            pub fn clear_bayesian_optimization(&mut self) {
                self.bayesian_optimization = false;
            }

            // Param is passed by value, moved
            pub fn set_bayesian_optimization(&mut self, v: bool) {
                self.bayesian_optimization = v;
            }

            // repeated string stopping_criteria = 4;

            pub fn stopping_criteria(&self) -> &[::std::string::String] {
                &self.stopping_criteria
            }

            pub fn clear_stopping_criteria(&mut self) {
                self.stopping_criteria.clear();
            }

            // Param is passed by value, moved
            pub fn set_stopping_criteria(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.stopping_criteria = v;
            }

            // Mutable pointer to the field.
            pub fn mut_stopping_criteria(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.stopping_criteria
            }

            // Take field
            pub fn take_stopping_criteria(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.stopping_criteria, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "tuning_algorithms",
                    |m: &HyperparameterOptimization| { &m.tuning_algorithms },
                    |m: &mut HyperparameterOptimization| { &mut m.tuning_algorithms },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "parameter_ranges",
                    |m: &HyperparameterOptimization| { &m.parameter_ranges },
                    |m: &mut HyperparameterOptimization| { &mut m.parameter_ranges },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "bayesian_optimization",
                    |m: &HyperparameterOptimization| { &m.bayesian_optimization },
                    |m: &mut HyperparameterOptimization| { &mut m.bayesian_optimization },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "stopping_criteria",
                    |m: &HyperparameterOptimization| { &m.stopping_criteria },
                    |m: &mut HyperparameterOptimization| { &mut m.stopping_criteria },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HyperparameterOptimization>(
                    "NeuralArchitectureSystem.AutoML.HyperparameterOptimization",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for HyperparameterOptimization {
            const NAME: &'static str = "HyperparameterOptimization";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.tuning_algorithms.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.parameter_ranges.insert(key, value);
                        },
                        24 => {
                            self.bayesian_optimization = is.read_bool()?;
                        },
                        34 => {
                            self.stopping_criteria.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.tuning_algorithms {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.parameter_ranges {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.bayesian_optimization != false {
                    my_size += 1 + 1;
                }
                for value in &self.stopping_criteria {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.tuning_algorithms {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.parameter_ranges {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.bayesian_optimization != false {
                    os.write_bool(3, self.bayesian_optimization)?;
                }
                for v in &self.stopping_criteria {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> HyperparameterOptimization {
                HyperparameterOptimization::new()
            }

            fn clear(&mut self) {
                self.tuning_algorithms.clear();
                self.parameter_ranges.clear();
                self.bayesian_optimization = false;
                self.stopping_criteria.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static HyperparameterOptimization {
                static instance: ::protobuf::rt::Lazy<HyperparameterOptimization> = ::protobuf::rt::Lazy::new();
                instance.get(HyperparameterOptimization::new)
            }
        }

        impl ::protobuf::MessageFull for HyperparameterOptimization {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("NeuralArchitectureSystem.AutoML.HyperparameterOptimization").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for HyperparameterOptimization {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for HyperparameterOptimization {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HardwareAccelerationSystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HardwareAccelerationSystem {
    fn default() -> &'a HardwareAccelerationSystem {
        <HardwareAccelerationSystem as ::protobuf::Message>::default_instance()
    }
}

impl HardwareAccelerationSystem {
    pub fn new() -> HardwareAccelerationSystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HardwareAccelerationSystem>(
            "HardwareAccelerationSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HardwareAccelerationSystem {
    const NAME: &'static str = "HardwareAccelerationSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HardwareAccelerationSystem {
        HardwareAccelerationSystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HardwareAccelerationSystem {
        static instance: HardwareAccelerationSystem = HardwareAccelerationSystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HardwareAccelerationSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HardwareAccelerationSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HardwareAccelerationSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `HardwareAccelerationSystem`
pub mod hardware_acceleration_system {
    // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GPUAcceleration {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GPUAcceleration {
        fn default() -> &'a GPUAcceleration {
            <GPUAcceleration as ::protobuf::Message>::default_instance()
        }
    }

    impl GPUAcceleration {
        pub fn new() -> GPUAcceleration {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GPUAcceleration>(
                "HardwareAccelerationSystem.GPUAcceleration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GPUAcceleration {
        const NAME: &'static str = "GPUAcceleration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GPUAcceleration {
            GPUAcceleration::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GPUAcceleration {
            static instance: GPUAcceleration = GPUAcceleration {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GPUAcceleration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.GPUAcceleration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GPUAcceleration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GPUAcceleration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `GPUAcceleration`
    pub mod gpuacceleration {
        // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CUDAIntegration {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration.cuda_version)
            pub cuda_version: u32,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration.cuda_capabilities)
            pub cuda_capabilities: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration.kernel_optimizations)
            pub kernel_optimizations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration.tensor_cores_enabled)
            pub tensor_cores_enabled: bool,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration.memory_strategies)
            pub memory_strategies: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CUDAIntegration {
            fn default() -> &'a CUDAIntegration {
                <CUDAIntegration as ::protobuf::Message>::default_instance()
            }
        }

        impl CUDAIntegration {
            pub fn new() -> CUDAIntegration {
                ::std::default::Default::default()
            }

            // uint32 cuda_version = 1;

            pub fn cuda_version(&self) -> u32 {
                self.cuda_version
            }

            pub fn clear_cuda_version(&mut self) {
                self.cuda_version = 0;
            }

            // Param is passed by value, moved
            pub fn set_cuda_version(&mut self, v: u32) {
                self.cuda_version = v;
            }

            // repeated string cuda_capabilities = 2;

            pub fn cuda_capabilities(&self) -> &[::std::string::String] {
                &self.cuda_capabilities
            }

            pub fn clear_cuda_capabilities(&mut self) {
                self.cuda_capabilities.clear();
            }

            // Param is passed by value, moved
            pub fn set_cuda_capabilities(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.cuda_capabilities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cuda_capabilities(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.cuda_capabilities
            }

            // Take field
            pub fn take_cuda_capabilities(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.cuda_capabilities, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration.KernelOptimizationsEntry kernel_optimizations = 3;

            pub fn kernel_optimizations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.kernel_optimizations
            }

            pub fn clear_kernel_optimizations(&mut self) {
                self.kernel_optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_kernel_optimizations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.kernel_optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_kernel_optimizations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.kernel_optimizations
            }

            // Take field
            pub fn take_kernel_optimizations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.kernel_optimizations, ::std::collections::HashMap::new())
            }

            // bool tensor_cores_enabled = 4;

            pub fn tensor_cores_enabled(&self) -> bool {
                self.tensor_cores_enabled
            }

            pub fn clear_tensor_cores_enabled(&mut self) {
                self.tensor_cores_enabled = false;
            }

            // Param is passed by value, moved
            pub fn set_tensor_cores_enabled(&mut self, v: bool) {
                self.tensor_cores_enabled = v;
            }

            // repeated string memory_strategies = 5;

            pub fn memory_strategies(&self) -> &[::std::string::String] {
                &self.memory_strategies
            }

            pub fn clear_memory_strategies(&mut self) {
                self.memory_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_memory_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.memory_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_memory_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.memory_strategies
            }

            // Take field
            pub fn take_memory_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.memory_strategies, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "cuda_version",
                    |m: &CUDAIntegration| { &m.cuda_version },
                    |m: &mut CUDAIntegration| { &mut m.cuda_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "cuda_capabilities",
                    |m: &CUDAIntegration| { &m.cuda_capabilities },
                    |m: &mut CUDAIntegration| { &mut m.cuda_capabilities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "kernel_optimizations",
                    |m: &CUDAIntegration| { &m.kernel_optimizations },
                    |m: &mut CUDAIntegration| { &mut m.kernel_optimizations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "tensor_cores_enabled",
                    |m: &CUDAIntegration| { &m.tensor_cores_enabled },
                    |m: &mut CUDAIntegration| { &mut m.tensor_cores_enabled },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "memory_strategies",
                    |m: &CUDAIntegration| { &m.memory_strategies },
                    |m: &mut CUDAIntegration| { &mut m.memory_strategies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUDAIntegration>(
                    "HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CUDAIntegration {
            const NAME: &'static str = "CUDAIntegration";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.cuda_version = is.read_uint32()?;
                        },
                        18 => {
                            self.cuda_capabilities.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.kernel_optimizations.insert(key, value);
                        },
                        32 => {
                            self.tensor_cores_enabled = is.read_bool()?;
                        },
                        42 => {
                            self.memory_strategies.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.cuda_version != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.cuda_version);
                }
                for value in &self.cuda_capabilities {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.kernel_optimizations {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.tensor_cores_enabled != false {
                    my_size += 1 + 1;
                }
                for value in &self.memory_strategies {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.cuda_version != 0 {
                    os.write_uint32(1, self.cuda_version)?;
                }
                for v in &self.cuda_capabilities {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.kernel_optimizations {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.tensor_cores_enabled != false {
                    os.write_bool(4, self.tensor_cores_enabled)?;
                }
                for v in &self.memory_strategies {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CUDAIntegration {
                CUDAIntegration::new()
            }

            fn clear(&mut self) {
                self.cuda_version = 0;
                self.cuda_capabilities.clear();
                self.kernel_optimizations.clear();
                self.tensor_cores_enabled = false;
                self.memory_strategies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CUDAIntegration {
                static instance: ::protobuf::rt::Lazy<CUDAIntegration> = ::protobuf::rt::Lazy::new();
                instance.get(CUDAIntegration::new)
            }
        }

        impl ::protobuf::MessageFull for CUDAIntegration {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.GPUAcceleration.CUDAIntegration").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CUDAIntegration {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CUDAIntegration {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ROCmSupport {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport.rocm_version)
            pub rocm_version: u32,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport.hip_features)
            pub hip_features: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport.optimization_flags)
            pub optimization_flags: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport.infinity_fabric_enabled)
            pub infinity_fabric_enabled: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ROCmSupport {
            fn default() -> &'a ROCmSupport {
                <ROCmSupport as ::protobuf::Message>::default_instance()
            }
        }

        impl ROCmSupport {
            pub fn new() -> ROCmSupport {
                ::std::default::Default::default()
            }

            // uint32 rocm_version = 1;

            pub fn rocm_version(&self) -> u32 {
                self.rocm_version
            }

            pub fn clear_rocm_version(&mut self) {
                self.rocm_version = 0;
            }

            // Param is passed by value, moved
            pub fn set_rocm_version(&mut self, v: u32) {
                self.rocm_version = v;
            }

            // repeated string hip_features = 2;

            pub fn hip_features(&self) -> &[::std::string::String] {
                &self.hip_features
            }

            pub fn clear_hip_features(&mut self) {
                self.hip_features.clear();
            }

            // Param is passed by value, moved
            pub fn set_hip_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.hip_features = v;
            }

            // Mutable pointer to the field.
            pub fn mut_hip_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.hip_features
            }

            // Take field
            pub fn take_hip_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.hip_features, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport.OptimizationFlagsEntry optimization_flags = 3;

            pub fn optimization_flags(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.optimization_flags
            }

            pub fn clear_optimization_flags(&mut self) {
                self.optimization_flags.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_flags(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.optimization_flags = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_flags(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.optimization_flags
            }

            // Take field
            pub fn take_optimization_flags(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.optimization_flags, ::std::collections::HashMap::new())
            }

            // bool infinity_fabric_enabled = 4;

            pub fn infinity_fabric_enabled(&self) -> bool {
                self.infinity_fabric_enabled
            }

            pub fn clear_infinity_fabric_enabled(&mut self) {
                self.infinity_fabric_enabled = false;
            }

            // Param is passed by value, moved
            pub fn set_infinity_fabric_enabled(&mut self, v: bool) {
                self.infinity_fabric_enabled = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "rocm_version",
                    |m: &ROCmSupport| { &m.rocm_version },
                    |m: &mut ROCmSupport| { &mut m.rocm_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hip_features",
                    |m: &ROCmSupport| { &m.hip_features },
                    |m: &mut ROCmSupport| { &mut m.hip_features },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "optimization_flags",
                    |m: &ROCmSupport| { &m.optimization_flags },
                    |m: &mut ROCmSupport| { &mut m.optimization_flags },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "infinity_fabric_enabled",
                    |m: &ROCmSupport| { &m.infinity_fabric_enabled },
                    |m: &mut ROCmSupport| { &mut m.infinity_fabric_enabled },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ROCmSupport>(
                    "HardwareAccelerationSystem.GPUAcceleration.ROCmSupport",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ROCmSupport {
            const NAME: &'static str = "ROCmSupport";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.rocm_version = is.read_uint32()?;
                        },
                        18 => {
                            self.hip_features.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.optimization_flags.insert(key, value);
                        },
                        32 => {
                            self.infinity_fabric_enabled = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.rocm_version != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.rocm_version);
                }
                for value in &self.hip_features {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.optimization_flags {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.infinity_fabric_enabled != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.rocm_version != 0 {
                    os.write_uint32(1, self.rocm_version)?;
                }
                for v in &self.hip_features {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.optimization_flags {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.infinity_fabric_enabled != false {
                    os.write_bool(4, self.infinity_fabric_enabled)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ROCmSupport {
                ROCmSupport::new()
            }

            fn clear(&mut self) {
                self.rocm_version = 0;
                self.hip_features.clear();
                self.optimization_flags.clear();
                self.infinity_fabric_enabled = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ROCmSupport {
                static instance: ::protobuf::rt::Lazy<ROCmSupport> = ::protobuf::rt::Lazy::new();
                instance.get(ROCmSupport::new)
            }
        }

        impl ::protobuf::MessageFull for ROCmSupport {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.GPUAcceleration.ROCmSupport").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ROCmSupport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ROCmSupport {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FPGAAcceleration {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FPGAAcceleration {
        fn default() -> &'a FPGAAcceleration {
            <FPGAAcceleration as ::protobuf::Message>::default_instance()
        }
    }

    impl FPGAAcceleration {
        pub fn new() -> FPGAAcceleration {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FPGAAcceleration>(
                "HardwareAccelerationSystem.FPGAAcceleration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FPGAAcceleration {
        const NAME: &'static str = "FPGAAcceleration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FPGAAcceleration {
            FPGAAcceleration::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FPGAAcceleration {
            static instance: FPGAAcceleration = FPGAAcceleration {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FPGAAcceleration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.FPGAAcceleration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FPGAAcceleration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FPGAAcceleration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `FPGAAcceleration`
    pub mod fpgaacceleration {
        // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct HDLGeneration {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration.hdl_templates)
            pub hdl_templates: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration.synthesis_rules)
            pub synthesis_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration.partial_reconfiguration)
            pub partial_reconfiguration: bool,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration.timing_constraints)
            pub timing_constraints: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a HDLGeneration {
            fn default() -> &'a HDLGeneration {
                <HDLGeneration as ::protobuf::Message>::default_instance()
            }
        }

        impl HDLGeneration {
            pub fn new() -> HDLGeneration {
                ::std::default::Default::default()
            }

            // repeated string hdl_templates = 1;

            pub fn hdl_templates(&self) -> &[::std::string::String] {
                &self.hdl_templates
            }

            pub fn clear_hdl_templates(&mut self) {
                self.hdl_templates.clear();
            }

            // Param is passed by value, moved
            pub fn set_hdl_templates(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.hdl_templates = v;
            }

            // Mutable pointer to the field.
            pub fn mut_hdl_templates(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.hdl_templates
            }

            // Take field
            pub fn take_hdl_templates(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.hdl_templates, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration.SynthesisRulesEntry synthesis_rules = 2;

            pub fn synthesis_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.synthesis_rules
            }

            pub fn clear_synthesis_rules(&mut self) {
                self.synthesis_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_synthesis_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.synthesis_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_synthesis_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.synthesis_rules
            }

            // Take field
            pub fn take_synthesis_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.synthesis_rules, ::std::collections::HashMap::new())
            }

            // bool partial_reconfiguration = 3;

            pub fn partial_reconfiguration(&self) -> bool {
                self.partial_reconfiguration
            }

            pub fn clear_partial_reconfiguration(&mut self) {
                self.partial_reconfiguration = false;
            }

            // Param is passed by value, moved
            pub fn set_partial_reconfiguration(&mut self, v: bool) {
                self.partial_reconfiguration = v;
            }

            // repeated string timing_constraints = 4;

            pub fn timing_constraints(&self) -> &[::std::string::String] {
                &self.timing_constraints
            }

            pub fn clear_timing_constraints(&mut self) {
                self.timing_constraints.clear();
            }

            // Param is passed by value, moved
            pub fn set_timing_constraints(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.timing_constraints = v;
            }

            // Mutable pointer to the field.
            pub fn mut_timing_constraints(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.timing_constraints
            }

            // Take field
            pub fn take_timing_constraints(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.timing_constraints, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hdl_templates",
                    |m: &HDLGeneration| { &m.hdl_templates },
                    |m: &mut HDLGeneration| { &mut m.hdl_templates },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "synthesis_rules",
                    |m: &HDLGeneration| { &m.synthesis_rules },
                    |m: &mut HDLGeneration| { &mut m.synthesis_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "partial_reconfiguration",
                    |m: &HDLGeneration| { &m.partial_reconfiguration },
                    |m: &mut HDLGeneration| { &mut m.partial_reconfiguration },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "timing_constraints",
                    |m: &HDLGeneration| { &m.timing_constraints },
                    |m: &mut HDLGeneration| { &mut m.timing_constraints },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HDLGeneration>(
                    "HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for HDLGeneration {
            const NAME: &'static str = "HDLGeneration";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.hdl_templates.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.synthesis_rules.insert(key, value);
                        },
                        24 => {
                            self.partial_reconfiguration = is.read_bool()?;
                        },
                        34 => {
                            self.timing_constraints.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.hdl_templates {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.synthesis_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.partial_reconfiguration != false {
                    my_size += 1 + 1;
                }
                for value in &self.timing_constraints {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.hdl_templates {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.synthesis_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.partial_reconfiguration != false {
                    os.write_bool(3, self.partial_reconfiguration)?;
                }
                for v in &self.timing_constraints {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> HDLGeneration {
                HDLGeneration::new()
            }

            fn clear(&mut self) {
                self.hdl_templates.clear();
                self.synthesis_rules.clear();
                self.partial_reconfiguration = false;
                self.timing_constraints.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static HDLGeneration {
                static instance: ::protobuf::rt::Lazy<HDLGeneration> = ::protobuf::rt::Lazy::new();
                instance.get(HDLGeneration::new)
            }
        }

        impl ::protobuf::MessageFull for HDLGeneration {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.FPGAAcceleration.HDLGeneration").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for HDLGeneration {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for HDLGeneration {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct BitstreamManagement {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement.bitstream_formats)
            pub bitstream_formats: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement.loading_strategies)
            pub loading_strategies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement.verification_enabled)
            pub verification_enabled: bool,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement.fallback_configs)
            pub fallback_configs: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a BitstreamManagement {
            fn default() -> &'a BitstreamManagement {
                <BitstreamManagement as ::protobuf::Message>::default_instance()
            }
        }

        impl BitstreamManagement {
            pub fn new() -> BitstreamManagement {
                ::std::default::Default::default()
            }

            // repeated string bitstream_formats = 1;

            pub fn bitstream_formats(&self) -> &[::std::string::String] {
                &self.bitstream_formats
            }

            pub fn clear_bitstream_formats(&mut self) {
                self.bitstream_formats.clear();
            }

            // Param is passed by value, moved
            pub fn set_bitstream_formats(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.bitstream_formats = v;
            }

            // Mutable pointer to the field.
            pub fn mut_bitstream_formats(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.bitstream_formats
            }

            // Take field
            pub fn take_bitstream_formats(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.bitstream_formats, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement.LoadingStrategiesEntry loading_strategies = 2;

            pub fn loading_strategies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.loading_strategies
            }

            pub fn clear_loading_strategies(&mut self) {
                self.loading_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_loading_strategies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.loading_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_loading_strategies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.loading_strategies
            }

            // Take field
            pub fn take_loading_strategies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.loading_strategies, ::std::collections::HashMap::new())
            }

            // bool verification_enabled = 3;

            pub fn verification_enabled(&self) -> bool {
                self.verification_enabled
            }

            pub fn clear_verification_enabled(&mut self) {
                self.verification_enabled = false;
            }

            // Param is passed by value, moved
            pub fn set_verification_enabled(&mut self, v: bool) {
                self.verification_enabled = v;
            }

            // repeated string fallback_configs = 4;

            pub fn fallback_configs(&self) -> &[::std::string::String] {
                &self.fallback_configs
            }

            pub fn clear_fallback_configs(&mut self) {
                self.fallback_configs.clear();
            }

            // Param is passed by value, moved
            pub fn set_fallback_configs(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.fallback_configs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_fallback_configs(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.fallback_configs
            }

            // Take field
            pub fn take_fallback_configs(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.fallback_configs, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "bitstream_formats",
                    |m: &BitstreamManagement| { &m.bitstream_formats },
                    |m: &mut BitstreamManagement| { &mut m.bitstream_formats },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "loading_strategies",
                    |m: &BitstreamManagement| { &m.loading_strategies },
                    |m: &mut BitstreamManagement| { &mut m.loading_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "verification_enabled",
                    |m: &BitstreamManagement| { &m.verification_enabled },
                    |m: &mut BitstreamManagement| { &mut m.verification_enabled },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "fallback_configs",
                    |m: &BitstreamManagement| { &m.fallback_configs },
                    |m: &mut BitstreamManagement| { &mut m.fallback_configs },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BitstreamManagement>(
                    "HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for BitstreamManagement {
            const NAME: &'static str = "BitstreamManagement";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.bitstream_formats.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.loading_strategies.insert(key, value);
                        },
                        24 => {
                            self.verification_enabled = is.read_bool()?;
                        },
                        34 => {
                            self.fallback_configs.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.bitstream_formats {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.loading_strategies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.verification_enabled != false {
                    my_size += 1 + 1;
                }
                for value in &self.fallback_configs {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.bitstream_formats {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.loading_strategies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.verification_enabled != false {
                    os.write_bool(3, self.verification_enabled)?;
                }
                for v in &self.fallback_configs {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> BitstreamManagement {
                BitstreamManagement::new()
            }

            fn clear(&mut self) {
                self.bitstream_formats.clear();
                self.loading_strategies.clear();
                self.verification_enabled = false;
                self.fallback_configs.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static BitstreamManagement {
                static instance: ::protobuf::rt::Lazy<BitstreamManagement> = ::protobuf::rt::Lazy::new();
                instance.get(BitstreamManagement::new)
            }
        }

        impl ::protobuf::MessageFull for BitstreamManagement {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for BitstreamManagement {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for BitstreamManagement {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.ASICOptimization)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ASICOptimization {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ASICOptimization {
        fn default() -> &'a ASICOptimization {
            <ASICOptimization as ::protobuf::Message>::default_instance()
        }
    }

    impl ASICOptimization {
        pub fn new() -> ASICOptimization {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ASICOptimization>(
                "HardwareAccelerationSystem.ASICOptimization",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ASICOptimization {
        const NAME: &'static str = "ASICOptimization";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ASICOptimization {
            ASICOptimization::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ASICOptimization {
            static instance: ASICOptimization = ASICOptimization {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ASICOptimization {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.ASICOptimization").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ASICOptimization {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ASICOptimization {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ASICOptimization`
    pub mod asicoptimization {
        // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.CircuitGeneration)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CircuitGeneration {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.CircuitGeneration.circuit_templates)
            pub circuit_templates: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.CircuitGeneration.optimization_rules)
            pub optimization_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.CircuitGeneration.power_optimization)
            pub power_optimization: bool,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.CircuitGeneration.timing_rules)
            pub timing_rules: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.CircuitGeneration.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CircuitGeneration {
            fn default() -> &'a CircuitGeneration {
                <CircuitGeneration as ::protobuf::Message>::default_instance()
            }
        }

        impl CircuitGeneration {
            pub fn new() -> CircuitGeneration {
                ::std::default::Default::default()
            }

            // repeated string circuit_templates = 1;

            pub fn circuit_templates(&self) -> &[::std::string::String] {
                &self.circuit_templates
            }

            pub fn clear_circuit_templates(&mut self) {
                self.circuit_templates.clear();
            }

            // Param is passed by value, moved
            pub fn set_circuit_templates(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.circuit_templates = v;
            }

            // Mutable pointer to the field.
            pub fn mut_circuit_templates(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.circuit_templates
            }

            // Take field
            pub fn take_circuit_templates(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.circuit_templates, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.HardwareAccelerationSystem.ASICOptimization.CircuitGeneration.OptimizationRulesEntry optimization_rules = 2;

            pub fn optimization_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.optimization_rules
            }

            pub fn clear_optimization_rules(&mut self) {
                self.optimization_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.optimization_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.optimization_rules
            }

            // Take field
            pub fn take_optimization_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.optimization_rules, ::std::collections::HashMap::new())
            }

            // bool power_optimization = 3;

            pub fn power_optimization(&self) -> bool {
                self.power_optimization
            }

            pub fn clear_power_optimization(&mut self) {
                self.power_optimization = false;
            }

            // Param is passed by value, moved
            pub fn set_power_optimization(&mut self, v: bool) {
                self.power_optimization = v;
            }

            // repeated string timing_rules = 4;

            pub fn timing_rules(&self) -> &[::std::string::String] {
                &self.timing_rules
            }

            pub fn clear_timing_rules(&mut self) {
                self.timing_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_timing_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.timing_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_timing_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.timing_rules
            }

            // Take field
            pub fn take_timing_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.timing_rules, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "circuit_templates",
                    |m: &CircuitGeneration| { &m.circuit_templates },
                    |m: &mut CircuitGeneration| { &mut m.circuit_templates },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "optimization_rules",
                    |m: &CircuitGeneration| { &m.optimization_rules },
                    |m: &mut CircuitGeneration| { &mut m.optimization_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "power_optimization",
                    |m: &CircuitGeneration| { &m.power_optimization },
                    |m: &mut CircuitGeneration| { &mut m.power_optimization },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "timing_rules",
                    |m: &CircuitGeneration| { &m.timing_rules },
                    |m: &mut CircuitGeneration| { &mut m.timing_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircuitGeneration>(
                    "HardwareAccelerationSystem.ASICOptimization.CircuitGeneration",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CircuitGeneration {
            const NAME: &'static str = "CircuitGeneration";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.circuit_templates.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.optimization_rules.insert(key, value);
                        },
                        24 => {
                            self.power_optimization = is.read_bool()?;
                        },
                        34 => {
                            self.timing_rules.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.circuit_templates {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.optimization_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.power_optimization != false {
                    my_size += 1 + 1;
                }
                for value in &self.timing_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.circuit_templates {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.optimization_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.power_optimization != false {
                    os.write_bool(3, self.power_optimization)?;
                }
                for v in &self.timing_rules {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CircuitGeneration {
                CircuitGeneration::new()
            }

            fn clear(&mut self) {
                self.circuit_templates.clear();
                self.optimization_rules.clear();
                self.power_optimization = false;
                self.timing_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CircuitGeneration {
                static instance: ::protobuf::rt::Lazy<CircuitGeneration> = ::protobuf::rt::Lazy::new();
                instance.get(CircuitGeneration::new)
            }
        }

        impl ::protobuf::MessageFull for CircuitGeneration {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.ASICOptimization.CircuitGeneration").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CircuitGeneration {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CircuitGeneration {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PhysicalDesign {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign.placement_strategies)
            pub placement_strategies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign.routing_rules)
            pub routing_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign.clock_tree_synthesis)
            pub clock_tree_synthesis: bool,
            // @@protoc_insertion_point(field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign.power_domains)
            pub power_domains: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PhysicalDesign {
            fn default() -> &'a PhysicalDesign {
                <PhysicalDesign as ::protobuf::Message>::default_instance()
            }
        }

        impl PhysicalDesign {
            pub fn new() -> PhysicalDesign {
                ::std::default::Default::default()
            }

            // repeated string placement_strategies = 1;

            pub fn placement_strategies(&self) -> &[::std::string::String] {
                &self.placement_strategies
            }

            pub fn clear_placement_strategies(&mut self) {
                self.placement_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_placement_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.placement_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_placement_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.placement_strategies
            }

            // Take field
            pub fn take_placement_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.placement_strategies, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign.RoutingRulesEntry routing_rules = 2;

            pub fn routing_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.routing_rules
            }

            pub fn clear_routing_rules(&mut self) {
                self.routing_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_routing_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.routing_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_routing_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.routing_rules
            }

            // Take field
            pub fn take_routing_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.routing_rules, ::std::collections::HashMap::new())
            }

            // bool clock_tree_synthesis = 3;

            pub fn clock_tree_synthesis(&self) -> bool {
                self.clock_tree_synthesis
            }

            pub fn clear_clock_tree_synthesis(&mut self) {
                self.clock_tree_synthesis = false;
            }

            // Param is passed by value, moved
            pub fn set_clock_tree_synthesis(&mut self, v: bool) {
                self.clock_tree_synthesis = v;
            }

            // repeated string power_domains = 4;

            pub fn power_domains(&self) -> &[::std::string::String] {
                &self.power_domains
            }

            pub fn clear_power_domains(&mut self) {
                self.power_domains.clear();
            }

            // Param is passed by value, moved
            pub fn set_power_domains(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.power_domains = v;
            }

            // Mutable pointer to the field.
            pub fn mut_power_domains(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.power_domains
            }

            // Take field
            pub fn take_power_domains(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.power_domains, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "placement_strategies",
                    |m: &PhysicalDesign| { &m.placement_strategies },
                    |m: &mut PhysicalDesign| { &mut m.placement_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "routing_rules",
                    |m: &PhysicalDesign| { &m.routing_rules },
                    |m: &mut PhysicalDesign| { &mut m.routing_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "clock_tree_synthesis",
                    |m: &PhysicalDesign| { &m.clock_tree_synthesis },
                    |m: &mut PhysicalDesign| { &mut m.clock_tree_synthesis },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "power_domains",
                    |m: &PhysicalDesign| { &m.power_domains },
                    |m: &mut PhysicalDesign| { &mut m.power_domains },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PhysicalDesign>(
                    "HardwareAccelerationSystem.ASICOptimization.PhysicalDesign",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PhysicalDesign {
            const NAME: &'static str = "PhysicalDesign";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.placement_strategies.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.routing_rules.insert(key, value);
                        },
                        24 => {
                            self.clock_tree_synthesis = is.read_bool()?;
                        },
                        34 => {
                            self.power_domains.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.placement_strategies {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.routing_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.clock_tree_synthesis != false {
                    my_size += 1 + 1;
                }
                for value in &self.power_domains {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.placement_strategies {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.routing_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.clock_tree_synthesis != false {
                    os.write_bool(3, self.clock_tree_synthesis)?;
                }
                for v in &self.power_domains {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PhysicalDesign {
                PhysicalDesign::new()
            }

            fn clear(&mut self) {
                self.placement_strategies.clear();
                self.routing_rules.clear();
                self.clock_tree_synthesis = false;
                self.power_domains.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PhysicalDesign {
                static instance: ::protobuf::rt::Lazy<PhysicalDesign> = ::protobuf::rt::Lazy::new();
                instance.get(PhysicalDesign::new)
            }
        }

        impl ::protobuf::MessageFull for PhysicalDesign {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("HardwareAccelerationSystem.ASICOptimization.PhysicalDesign").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PhysicalDesign {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PhysicalDesign {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.AdaptiveCompilationSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AdaptiveCompilationSystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.AdaptiveCompilationSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AdaptiveCompilationSystem {
    fn default() -> &'a AdaptiveCompilationSystem {
        <AdaptiveCompilationSystem as ::protobuf::Message>::default_instance()
    }
}

impl AdaptiveCompilationSystem {
    pub fn new() -> AdaptiveCompilationSystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdaptiveCompilationSystem>(
            "AdaptiveCompilationSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AdaptiveCompilationSystem {
    const NAME: &'static str = "AdaptiveCompilationSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AdaptiveCompilationSystem {
        AdaptiveCompilationSystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AdaptiveCompilationSystem {
        static instance: AdaptiveCompilationSystem = AdaptiveCompilationSystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AdaptiveCompilationSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AdaptiveCompilationSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AdaptiveCompilationSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdaptiveCompilationSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AdaptiveCompilationSystem`
pub mod adaptive_compilation_system {
    // @@protoc_insertion_point(message:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CompilerOptimization {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CompilerOptimization {
        fn default() -> &'a CompilerOptimization {
            <CompilerOptimization as ::protobuf::Message>::default_instance()
        }
    }

    impl CompilerOptimization {
        pub fn new() -> CompilerOptimization {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompilerOptimization>(
                "AdaptiveCompilationSystem.CompilerOptimization",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CompilerOptimization {
        const NAME: &'static str = "CompilerOptimization";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CompilerOptimization {
            CompilerOptimization::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CompilerOptimization {
            static instance: CompilerOptimization = CompilerOptimization {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CompilerOptimization {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("AdaptiveCompilationSystem.CompilerOptimization").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CompilerOptimization {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CompilerOptimization {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CompilerOptimization`
    pub mod compiler_optimization {
        // @@protoc_insertion_point(message:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct OptimizationPasses {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses.pass_sequence)
            pub pass_sequence: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses.pass_dependencies)
            pub pass_dependencies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses.adaptive_scheduling)
            pub adaptive_scheduling: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses.analysis_metrics)
            pub analysis_metrics: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a OptimizationPasses {
            fn default() -> &'a OptimizationPasses {
                <OptimizationPasses as ::protobuf::Message>::default_instance()
            }
        }

        impl OptimizationPasses {
            pub fn new() -> OptimizationPasses {
                ::std::default::Default::default()
            }

            // repeated string pass_sequence = 1;

            pub fn pass_sequence(&self) -> &[::std::string::String] {
                &self.pass_sequence
            }

            pub fn clear_pass_sequence(&mut self) {
                self.pass_sequence.clear();
            }

            // Param is passed by value, moved
            pub fn set_pass_sequence(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.pass_sequence = v;
            }

            // Mutable pointer to the field.
            pub fn mut_pass_sequence(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.pass_sequence
            }

            // Take field
            pub fn take_pass_sequence(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.pass_sequence, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses.PassDependenciesEntry pass_dependencies = 2;

            pub fn pass_dependencies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.pass_dependencies
            }

            pub fn clear_pass_dependencies(&mut self) {
                self.pass_dependencies.clear();
            }

            // Param is passed by value, moved
            pub fn set_pass_dependencies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.pass_dependencies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_pass_dependencies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.pass_dependencies
            }

            // Take field
            pub fn take_pass_dependencies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.pass_dependencies, ::std::collections::HashMap::new())
            }

            // bool adaptive_scheduling = 3;

            pub fn adaptive_scheduling(&self) -> bool {
                self.adaptive_scheduling
            }

            pub fn clear_adaptive_scheduling(&mut self) {
                self.adaptive_scheduling = false;
            }

            // Param is passed by value, moved
            pub fn set_adaptive_scheduling(&mut self, v: bool) {
                self.adaptive_scheduling = v;
            }

            // repeated string analysis_metrics = 4;

            pub fn analysis_metrics(&self) -> &[::std::string::String] {
                &self.analysis_metrics
            }

            pub fn clear_analysis_metrics(&mut self) {
                self.analysis_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_analysis_metrics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.analysis_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_analysis_metrics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.analysis_metrics
            }

            // Take field
            pub fn take_analysis_metrics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.analysis_metrics, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "pass_sequence",
                    |m: &OptimizationPasses| { &m.pass_sequence },
                    |m: &mut OptimizationPasses| { &mut m.pass_sequence },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "pass_dependencies",
                    |m: &OptimizationPasses| { &m.pass_dependencies },
                    |m: &mut OptimizationPasses| { &mut m.pass_dependencies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "adaptive_scheduling",
                    |m: &OptimizationPasses| { &m.adaptive_scheduling },
                    |m: &mut OptimizationPasses| { &mut m.adaptive_scheduling },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "analysis_metrics",
                    |m: &OptimizationPasses| { &m.analysis_metrics },
                    |m: &mut OptimizationPasses| { &mut m.analysis_metrics },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptimizationPasses>(
                    "AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for OptimizationPasses {
            const NAME: &'static str = "OptimizationPasses";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.pass_sequence.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.pass_dependencies.insert(key, value);
                        },
                        24 => {
                            self.adaptive_scheduling = is.read_bool()?;
                        },
                        34 => {
                            self.analysis_metrics.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.pass_sequence {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.pass_dependencies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.adaptive_scheduling != false {
                    my_size += 1 + 1;
                }
                for value in &self.analysis_metrics {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.pass_sequence {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.pass_dependencies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.adaptive_scheduling != false {
                    os.write_bool(3, self.adaptive_scheduling)?;
                }
                for v in &self.analysis_metrics {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> OptimizationPasses {
                OptimizationPasses::new()
            }

            fn clear(&mut self) {
                self.pass_sequence.clear();
                self.pass_dependencies.clear();
                self.adaptive_scheduling = false;
                self.analysis_metrics.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static OptimizationPasses {
                static instance: ::protobuf::rt::Lazy<OptimizationPasses> = ::protobuf::rt::Lazy::new();
                instance.get(OptimizationPasses::new)
            }
        }

        impl ::protobuf::MessageFull for OptimizationPasses {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AdaptiveCompilationSystem.CompilerOptimization.OptimizationPasses").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for OptimizationPasses {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for OptimizationPasses {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CodeGeneration {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration.target_architectures)
            pub target_architectures: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration.instruction_selection)
            pub instruction_selection: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration.vectorization_enabled)
            pub vectorization_enabled: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration.scheduling_strategies)
            pub scheduling_strategies: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CodeGeneration {
            fn default() -> &'a CodeGeneration {
                <CodeGeneration as ::protobuf::Message>::default_instance()
            }
        }

        impl CodeGeneration {
            pub fn new() -> CodeGeneration {
                ::std::default::Default::default()
            }

            // repeated string target_architectures = 1;

            pub fn target_architectures(&self) -> &[::std::string::String] {
                &self.target_architectures
            }

            pub fn clear_target_architectures(&mut self) {
                self.target_architectures.clear();
            }

            // Param is passed by value, moved
            pub fn set_target_architectures(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.target_architectures = v;
            }

            // Mutable pointer to the field.
            pub fn mut_target_architectures(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.target_architectures
            }

            // Take field
            pub fn take_target_architectures(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.target_architectures, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration.InstructionSelectionEntry instruction_selection = 2;

            pub fn instruction_selection(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.instruction_selection
            }

            pub fn clear_instruction_selection(&mut self) {
                self.instruction_selection.clear();
            }

            // Param is passed by value, moved
            pub fn set_instruction_selection(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.instruction_selection = v;
            }

            // Mutable pointer to the field.
            pub fn mut_instruction_selection(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.instruction_selection
            }

            // Take field
            pub fn take_instruction_selection(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.instruction_selection, ::std::collections::HashMap::new())
            }

            // bool vectorization_enabled = 3;

            pub fn vectorization_enabled(&self) -> bool {
                self.vectorization_enabled
            }

            pub fn clear_vectorization_enabled(&mut self) {
                self.vectorization_enabled = false;
            }

            // Param is passed by value, moved
            pub fn set_vectorization_enabled(&mut self, v: bool) {
                self.vectorization_enabled = v;
            }

            // repeated string scheduling_strategies = 4;

            pub fn scheduling_strategies(&self) -> &[::std::string::String] {
                &self.scheduling_strategies
            }

            pub fn clear_scheduling_strategies(&mut self) {
                self.scheduling_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_scheduling_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.scheduling_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_scheduling_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.scheduling_strategies
            }

            // Take field
            pub fn take_scheduling_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.scheduling_strategies, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "target_architectures",
                    |m: &CodeGeneration| { &m.target_architectures },
                    |m: &mut CodeGeneration| { &mut m.target_architectures },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "instruction_selection",
                    |m: &CodeGeneration| { &m.instruction_selection },
                    |m: &mut CodeGeneration| { &mut m.instruction_selection },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "vectorization_enabled",
                    |m: &CodeGeneration| { &m.vectorization_enabled },
                    |m: &mut CodeGeneration| { &mut m.vectorization_enabled },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "scheduling_strategies",
                    |m: &CodeGeneration| { &m.scheduling_strategies },
                    |m: &mut CodeGeneration| { &mut m.scheduling_strategies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeGeneration>(
                    "AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CodeGeneration {
            const NAME: &'static str = "CodeGeneration";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.target_architectures.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.instruction_selection.insert(key, value);
                        },
                        24 => {
                            self.vectorization_enabled = is.read_bool()?;
                        },
                        34 => {
                            self.scheduling_strategies.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.target_architectures {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.instruction_selection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.vectorization_enabled != false {
                    my_size += 1 + 1;
                }
                for value in &self.scheduling_strategies {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.target_architectures {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.instruction_selection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.vectorization_enabled != false {
                    os.write_bool(3, self.vectorization_enabled)?;
                }
                for v in &self.scheduling_strategies {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CodeGeneration {
                CodeGeneration::new()
            }

            fn clear(&mut self) {
                self.target_architectures.clear();
                self.instruction_selection.clear();
                self.vectorization_enabled = false;
                self.scheduling_strategies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CodeGeneration {
                static instance: ::protobuf::rt::Lazy<CodeGeneration> = ::protobuf::rt::Lazy::new();
                instance.get(CodeGeneration::new)
            }
        }

        impl ::protobuf::MessageFull for CodeGeneration {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AdaptiveCompilationSystem.CompilerOptimization.CodeGeneration").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CodeGeneration {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CodeGeneration {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuntimeOptimization {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuntimeOptimization {
        fn default() -> &'a RuntimeOptimization {
            <RuntimeOptimization as ::protobuf::Message>::default_instance()
        }
    }

    impl RuntimeOptimization {
        pub fn new() -> RuntimeOptimization {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeOptimization>(
                "AdaptiveCompilationSystem.RuntimeOptimization",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuntimeOptimization {
        const NAME: &'static str = "RuntimeOptimization";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuntimeOptimization {
            RuntimeOptimization::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuntimeOptimization {
            static instance: RuntimeOptimization = RuntimeOptimization {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RuntimeOptimization {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("AdaptiveCompilationSystem.RuntimeOptimization").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuntimeOptimization {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuntimeOptimization {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `RuntimeOptimization`
    pub mod runtime_optimization {
        // @@protoc_insertion_point(message:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct JITCompilation {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation.hot_spot_detection)
            pub hot_spot_detection: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation.compilation_triggers)
            pub compilation_triggers: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation.profile_guided)
            pub profile_guided: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation.deoptimization_rules)
            pub deoptimization_rules: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a JITCompilation {
            fn default() -> &'a JITCompilation {
                <JITCompilation as ::protobuf::Message>::default_instance()
            }
        }

        impl JITCompilation {
            pub fn new() -> JITCompilation {
                ::std::default::Default::default()
            }

            // repeated string hot_spot_detection = 1;

            pub fn hot_spot_detection(&self) -> &[::std::string::String] {
                &self.hot_spot_detection
            }

            pub fn clear_hot_spot_detection(&mut self) {
                self.hot_spot_detection.clear();
            }

            // Param is passed by value, moved
            pub fn set_hot_spot_detection(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.hot_spot_detection = v;
            }

            // Mutable pointer to the field.
            pub fn mut_hot_spot_detection(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.hot_spot_detection
            }

            // Take field
            pub fn take_hot_spot_detection(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.hot_spot_detection, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation.CompilationTriggersEntry compilation_triggers = 2;

            pub fn compilation_triggers(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.compilation_triggers
            }

            pub fn clear_compilation_triggers(&mut self) {
                self.compilation_triggers.clear();
            }

            // Param is passed by value, moved
            pub fn set_compilation_triggers(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.compilation_triggers = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compilation_triggers(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.compilation_triggers
            }

            // Take field
            pub fn take_compilation_triggers(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.compilation_triggers, ::std::collections::HashMap::new())
            }

            // bool profile_guided = 3;

            pub fn profile_guided(&self) -> bool {
                self.profile_guided
            }

            pub fn clear_profile_guided(&mut self) {
                self.profile_guided = false;
            }

            // Param is passed by value, moved
            pub fn set_profile_guided(&mut self, v: bool) {
                self.profile_guided = v;
            }

            // repeated string deoptimization_rules = 4;

            pub fn deoptimization_rules(&self) -> &[::std::string::String] {
                &self.deoptimization_rules
            }

            pub fn clear_deoptimization_rules(&mut self) {
                self.deoptimization_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_deoptimization_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.deoptimization_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_deoptimization_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.deoptimization_rules
            }

            // Take field
            pub fn take_deoptimization_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.deoptimization_rules, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hot_spot_detection",
                    |m: &JITCompilation| { &m.hot_spot_detection },
                    |m: &mut JITCompilation| { &mut m.hot_spot_detection },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "compilation_triggers",
                    |m: &JITCompilation| { &m.compilation_triggers },
                    |m: &mut JITCompilation| { &mut m.compilation_triggers },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "profile_guided",
                    |m: &JITCompilation| { &m.profile_guided },
                    |m: &mut JITCompilation| { &mut m.profile_guided },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "deoptimization_rules",
                    |m: &JITCompilation| { &m.deoptimization_rules },
                    |m: &mut JITCompilation| { &mut m.deoptimization_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JITCompilation>(
                    "AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for JITCompilation {
            const NAME: &'static str = "JITCompilation";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.hot_spot_detection.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.compilation_triggers.insert(key, value);
                        },
                        24 => {
                            self.profile_guided = is.read_bool()?;
                        },
                        34 => {
                            self.deoptimization_rules.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.hot_spot_detection {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.compilation_triggers {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.profile_guided != false {
                    my_size += 1 + 1;
                }
                for value in &self.deoptimization_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.hot_spot_detection {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.compilation_triggers {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.profile_guided != false {
                    os.write_bool(3, self.profile_guided)?;
                }
                for v in &self.deoptimization_rules {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> JITCompilation {
                JITCompilation::new()
            }

            fn clear(&mut self) {
                self.hot_spot_detection.clear();
                self.compilation_triggers.clear();
                self.profile_guided = false;
                self.deoptimization_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static JITCompilation {
                static instance: ::protobuf::rt::Lazy<JITCompilation> = ::protobuf::rt::Lazy::new();
                instance.get(JITCompilation::new)
            }
        }

        impl ::protobuf::MessageFull for JITCompilation {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AdaptiveCompilationSystem.RuntimeOptimization.JITCompilation").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for JITCompilation {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for JITCompilation {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SpeculativeExecution {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution.speculation_patterns)
            pub speculation_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution.rollback_strategies)
            pub rollback_strategies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution.branch_prediction)
            pub branch_prediction: bool,
            // @@protoc_insertion_point(field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution.guard_conditions)
            pub guard_conditions: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SpeculativeExecution {
            fn default() -> &'a SpeculativeExecution {
                <SpeculativeExecution as ::protobuf::Message>::default_instance()
            }
        }

        impl SpeculativeExecution {
            pub fn new() -> SpeculativeExecution {
                ::std::default::Default::default()
            }

            // repeated string speculation_patterns = 1;

            pub fn speculation_patterns(&self) -> &[::std::string::String] {
                &self.speculation_patterns
            }

            pub fn clear_speculation_patterns(&mut self) {
                self.speculation_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_speculation_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.speculation_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_speculation_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.speculation_patterns
            }

            // Take field
            pub fn take_speculation_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.speculation_patterns, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution.RollbackStrategiesEntry rollback_strategies = 2;

            pub fn rollback_strategies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.rollback_strategies
            }

            pub fn clear_rollback_strategies(&mut self) {
                self.rollback_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_rollback_strategies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.rollback_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_rollback_strategies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.rollback_strategies
            }

            // Take field
            pub fn take_rollback_strategies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.rollback_strategies, ::std::collections::HashMap::new())
            }

            // bool branch_prediction = 3;

            pub fn branch_prediction(&self) -> bool {
                self.branch_prediction
            }

            pub fn clear_branch_prediction(&mut self) {
                self.branch_prediction = false;
            }

            // Param is passed by value, moved
            pub fn set_branch_prediction(&mut self, v: bool) {
                self.branch_prediction = v;
            }

            // repeated string guard_conditions = 4;

            pub fn guard_conditions(&self) -> &[::std::string::String] {
                &self.guard_conditions
            }

            pub fn clear_guard_conditions(&mut self) {
                self.guard_conditions.clear();
            }

            // Param is passed by value, moved
            pub fn set_guard_conditions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.guard_conditions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_guard_conditions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.guard_conditions
            }

            // Take field
            pub fn take_guard_conditions(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.guard_conditions, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "speculation_patterns",
                    |m: &SpeculativeExecution| { &m.speculation_patterns },
                    |m: &mut SpeculativeExecution| { &mut m.speculation_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "rollback_strategies",
                    |m: &SpeculativeExecution| { &m.rollback_strategies },
                    |m: &mut SpeculativeExecution| { &mut m.rollback_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "branch_prediction",
                    |m: &SpeculativeExecution| { &m.branch_prediction },
                    |m: &mut SpeculativeExecution| { &mut m.branch_prediction },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "guard_conditions",
                    |m: &SpeculativeExecution| { &m.guard_conditions },
                    |m: &mut SpeculativeExecution| { &mut m.guard_conditions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpeculativeExecution>(
                    "AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SpeculativeExecution {
            const NAME: &'static str = "SpeculativeExecution";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.speculation_patterns.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.rollback_strategies.insert(key, value);
                        },
                        24 => {
                            self.branch_prediction = is.read_bool()?;
                        },
                        34 => {
                            self.guard_conditions.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.speculation_patterns {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.rollback_strategies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.branch_prediction != false {
                    my_size += 1 + 1;
                }
                for value in &self.guard_conditions {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.speculation_patterns {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.rollback_strategies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.branch_prediction != false {
                    os.write_bool(3, self.branch_prediction)?;
                }
                for v in &self.guard_conditions {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SpeculativeExecution {
                SpeculativeExecution::new()
            }

            fn clear(&mut self) {
                self.speculation_patterns.clear();
                self.rollback_strategies.clear();
                self.branch_prediction = false;
                self.guard_conditions.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SpeculativeExecution {
                static instance: ::protobuf::rt::Lazy<SpeculativeExecution> = ::protobuf::rt::Lazy::new();
                instance.get(SpeculativeExecution::new)
            }
        }

        impl ::protobuf::MessageFull for SpeculativeExecution {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExecution").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SpeculativeExecution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SpeculativeExecution {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancementSystemV2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecurityEnhancementSystemV2 {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancementSystemV2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecurityEnhancementSystemV2 {
    fn default() -> &'a SecurityEnhancementSystemV2 {
        <SecurityEnhancementSystemV2 as ::protobuf::Message>::default_instance()
    }
}

impl SecurityEnhancementSystemV2 {
    pub fn new() -> SecurityEnhancementSystemV2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityEnhancementSystemV2>(
            "SecurityEnhancementSystemV2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecurityEnhancementSystemV2 {
    const NAME: &'static str = "SecurityEnhancementSystemV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecurityEnhancementSystemV2 {
        SecurityEnhancementSystemV2::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecurityEnhancementSystemV2 {
        static instance: SecurityEnhancementSystemV2 = SecurityEnhancementSystemV2 {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecurityEnhancementSystemV2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecurityEnhancementSystemV2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecurityEnhancementSystemV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityEnhancementSystemV2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SecurityEnhancementSystemV2`
pub mod security_enhancement_system_v2 {
    // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FormalVerification {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FormalVerification {
        fn default() -> &'a FormalVerification {
            <FormalVerification as ::protobuf::Message>::default_instance()
        }
    }

    impl FormalVerification {
        pub fn new() -> FormalVerification {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FormalVerification>(
                "SecurityEnhancementSystemV2.FormalVerification",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FormalVerification {
        const NAME: &'static str = "FormalVerification";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FormalVerification {
            FormalVerification::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FormalVerification {
            static instance: FormalVerification = FormalVerification {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FormalVerification {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityEnhancementSystemV2.FormalVerification").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FormalVerification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FormalVerification {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `FormalVerification`
    pub mod formal_verification {
        // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ProofGeneration {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration.proof_strategies)
            pub proof_strategies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration.verification_rules)
            pub verification_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration.automated_proving)
            pub automated_proving: bool,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration.theorem_templates)
            pub theorem_templates: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ProofGeneration {
            fn default() -> &'a ProofGeneration {
                <ProofGeneration as ::protobuf::Message>::default_instance()
            }
        }

        impl ProofGeneration {
            pub fn new() -> ProofGeneration {
                ::std::default::Default::default()
            }

            // repeated string proof_strategies = 1;

            pub fn proof_strategies(&self) -> &[::std::string::String] {
                &self.proof_strategies
            }

            pub fn clear_proof_strategies(&mut self) {
                self.proof_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_proof_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.proof_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_proof_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.proof_strategies
            }

            // Take field
            pub fn take_proof_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.proof_strategies, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration.VerificationRulesEntry verification_rules = 2;

            pub fn verification_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.verification_rules
            }

            pub fn clear_verification_rules(&mut self) {
                self.verification_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_verification_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.verification_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_verification_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.verification_rules
            }

            // Take field
            pub fn take_verification_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.verification_rules, ::std::collections::HashMap::new())
            }

            // bool automated_proving = 3;

            pub fn automated_proving(&self) -> bool {
                self.automated_proving
            }

            pub fn clear_automated_proving(&mut self) {
                self.automated_proving = false;
            }

            // Param is passed by value, moved
            pub fn set_automated_proving(&mut self, v: bool) {
                self.automated_proving = v;
            }

            // repeated string theorem_templates = 4;

            pub fn theorem_templates(&self) -> &[::std::string::String] {
                &self.theorem_templates
            }

            pub fn clear_theorem_templates(&mut self) {
                self.theorem_templates.clear();
            }

            // Param is passed by value, moved
            pub fn set_theorem_templates(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.theorem_templates = v;
            }

            // Mutable pointer to the field.
            pub fn mut_theorem_templates(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.theorem_templates
            }

            // Take field
            pub fn take_theorem_templates(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.theorem_templates, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "proof_strategies",
                    |m: &ProofGeneration| { &m.proof_strategies },
                    |m: &mut ProofGeneration| { &mut m.proof_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "verification_rules",
                    |m: &ProofGeneration| { &m.verification_rules },
                    |m: &mut ProofGeneration| { &mut m.verification_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "automated_proving",
                    |m: &ProofGeneration| { &m.automated_proving },
                    |m: &mut ProofGeneration| { &mut m.automated_proving },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "theorem_templates",
                    |m: &ProofGeneration| { &m.theorem_templates },
                    |m: &mut ProofGeneration| { &mut m.theorem_templates },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProofGeneration>(
                    "SecurityEnhancementSystemV2.FormalVerification.ProofGeneration",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ProofGeneration {
            const NAME: &'static str = "ProofGeneration";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.proof_strategies.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.verification_rules.insert(key, value);
                        },
                        24 => {
                            self.automated_proving = is.read_bool()?;
                        },
                        34 => {
                            self.theorem_templates.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.proof_strategies {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.verification_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.automated_proving != false {
                    my_size += 1 + 1;
                }
                for value in &self.theorem_templates {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.proof_strategies {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.verification_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.automated_proving != false {
                    os.write_bool(3, self.automated_proving)?;
                }
                for v in &self.theorem_templates {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ProofGeneration {
                ProofGeneration::new()
            }

            fn clear(&mut self) {
                self.proof_strategies.clear();
                self.verification_rules.clear();
                self.automated_proving = false;
                self.theorem_templates.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ProofGeneration {
                static instance: ::protobuf::rt::Lazy<ProofGeneration> = ::protobuf::rt::Lazy::new();
                instance.get(ProofGeneration::new)
            }
        }

        impl ::protobuf::MessageFull for ProofGeneration {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SecurityEnhancementSystemV2.FormalVerification.ProofGeneration").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ProofGeneration {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ProofGeneration {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ModelChecking)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ModelChecking {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ModelChecking.state_space)
            pub state_space: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ModelChecking.temporal_logic)
            pub temporal_logic: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ModelChecking.liveness_checking)
            pub liveness_checking: bool,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ModelChecking.safety_properties)
            pub safety_properties: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ModelChecking.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ModelChecking {
            fn default() -> &'a ModelChecking {
                <ModelChecking as ::protobuf::Message>::default_instance()
            }
        }

        impl ModelChecking {
            pub fn new() -> ModelChecking {
                ::std::default::Default::default()
            }

            // repeated string state_space = 1;

            pub fn state_space(&self) -> &[::std::string::String] {
                &self.state_space
            }

            pub fn clear_state_space(&mut self) {
                self.state_space.clear();
            }

            // Param is passed by value, moved
            pub fn set_state_space(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.state_space = v;
            }

            // Mutable pointer to the field.
            pub fn mut_state_space(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.state_space
            }

            // Take field
            pub fn take_state_space(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.state_space, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.SecurityEnhancementSystemV2.FormalVerification.ModelChecking.TemporalLogicEntry temporal_logic = 2;

            pub fn temporal_logic(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.temporal_logic
            }

            pub fn clear_temporal_logic(&mut self) {
                self.temporal_logic.clear();
            }

            // Param is passed by value, moved
            pub fn set_temporal_logic(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.temporal_logic = v;
            }

            // Mutable pointer to the field.
            pub fn mut_temporal_logic(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.temporal_logic
            }

            // Take field
            pub fn take_temporal_logic(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.temporal_logic, ::std::collections::HashMap::new())
            }

            // bool liveness_checking = 3;

            pub fn liveness_checking(&self) -> bool {
                self.liveness_checking
            }

            pub fn clear_liveness_checking(&mut self) {
                self.liveness_checking = false;
            }

            // Param is passed by value, moved
            pub fn set_liveness_checking(&mut self, v: bool) {
                self.liveness_checking = v;
            }

            // repeated string safety_properties = 4;

            pub fn safety_properties(&self) -> &[::std::string::String] {
                &self.safety_properties
            }

            pub fn clear_safety_properties(&mut self) {
                self.safety_properties.clear();
            }

            // Param is passed by value, moved
            pub fn set_safety_properties(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.safety_properties = v;
            }

            // Mutable pointer to the field.
            pub fn mut_safety_properties(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.safety_properties
            }

            // Take field
            pub fn take_safety_properties(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.safety_properties, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "state_space",
                    |m: &ModelChecking| { &m.state_space },
                    |m: &mut ModelChecking| { &mut m.state_space },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "temporal_logic",
                    |m: &ModelChecking| { &m.temporal_logic },
                    |m: &mut ModelChecking| { &mut m.temporal_logic },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "liveness_checking",
                    |m: &ModelChecking| { &m.liveness_checking },
                    |m: &mut ModelChecking| { &mut m.liveness_checking },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "safety_properties",
                    |m: &ModelChecking| { &m.safety_properties },
                    |m: &mut ModelChecking| { &mut m.safety_properties },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModelChecking>(
                    "SecurityEnhancementSystemV2.FormalVerification.ModelChecking",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ModelChecking {
            const NAME: &'static str = "ModelChecking";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.state_space.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.temporal_logic.insert(key, value);
                        },
                        24 => {
                            self.liveness_checking = is.read_bool()?;
                        },
                        34 => {
                            self.safety_properties.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.state_space {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.temporal_logic {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.liveness_checking != false {
                    my_size += 1 + 1;
                }
                for value in &self.safety_properties {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.state_space {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.temporal_logic {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.liveness_checking != false {
                    os.write_bool(3, self.liveness_checking)?;
                }
                for v in &self.safety_properties {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ModelChecking {
                ModelChecking::new()
            }

            fn clear(&mut self) {
                self.state_space.clear();
                self.temporal_logic.clear();
                self.liveness_checking = false;
                self.safety_properties.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ModelChecking {
                static instance: ::protobuf::rt::Lazy<ModelChecking> = ::protobuf::rt::Lazy::new();
                instance.get(ModelChecking::new)
            }
        }

        impl ::protobuf::MessageFull for ModelChecking {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SecurityEnhancementSystemV2.FormalVerification.ModelChecking").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ModelChecking {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ModelChecking {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CryptographicSuite {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CryptographicSuite {
        fn default() -> &'a CryptographicSuite {
            <CryptographicSuite as ::protobuf::Message>::default_instance()
        }
    }

    impl CryptographicSuite {
        pub fn new() -> CryptographicSuite {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CryptographicSuite>(
                "SecurityEnhancementSystemV2.CryptographicSuite",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CryptographicSuite {
        const NAME: &'static str = "CryptographicSuite";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CryptographicSuite {
            CryptographicSuite::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CryptographicSuite {
            static instance: CryptographicSuite = CryptographicSuite {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CryptographicSuite {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityEnhancementSystemV2.CryptographicSuite").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CryptographicSuite {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CryptographicSuite {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CryptographicSuite`
    pub mod cryptographic_suite {
        // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct QuantumResistance {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance.post_quantum_algorithms)
            pub post_quantum_algorithms: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance.key_generation)
            pub key_generation: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance.hybrid_schemes)
            pub hybrid_schemes: bool,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance.security_levels)
            pub security_levels: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a QuantumResistance {
            fn default() -> &'a QuantumResistance {
                <QuantumResistance as ::protobuf::Message>::default_instance()
            }
        }

        impl QuantumResistance {
            pub fn new() -> QuantumResistance {
                ::std::default::Default::default()
            }

            // repeated string post_quantum_algorithms = 1;

            pub fn post_quantum_algorithms(&self) -> &[::std::string::String] {
                &self.post_quantum_algorithms
            }

            pub fn clear_post_quantum_algorithms(&mut self) {
                self.post_quantum_algorithms.clear();
            }

            // Param is passed by value, moved
            pub fn set_post_quantum_algorithms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.post_quantum_algorithms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_post_quantum_algorithms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.post_quantum_algorithms
            }

            // Take field
            pub fn take_post_quantum_algorithms(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.post_quantum_algorithms, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance.KeyGenerationEntry key_generation = 2;

            pub fn key_generation(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.key_generation
            }

            pub fn clear_key_generation(&mut self) {
                self.key_generation.clear();
            }

            // Param is passed by value, moved
            pub fn set_key_generation(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.key_generation = v;
            }

            // Mutable pointer to the field.
            pub fn mut_key_generation(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.key_generation
            }

            // Take field
            pub fn take_key_generation(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.key_generation, ::std::collections::HashMap::new())
            }

            // bool hybrid_schemes = 3;

            pub fn hybrid_schemes(&self) -> bool {
                self.hybrid_schemes
            }

            pub fn clear_hybrid_schemes(&mut self) {
                self.hybrid_schemes = false;
            }

            // Param is passed by value, moved
            pub fn set_hybrid_schemes(&mut self, v: bool) {
                self.hybrid_schemes = v;
            }

            // repeated string security_levels = 4;

            pub fn security_levels(&self) -> &[::std::string::String] {
                &self.security_levels
            }

            pub fn clear_security_levels(&mut self) {
                self.security_levels.clear();
            }

            // Param is passed by value, moved
            pub fn set_security_levels(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.security_levels = v;
            }

            // Mutable pointer to the field.
            pub fn mut_security_levels(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.security_levels
            }

            // Take field
            pub fn take_security_levels(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.security_levels, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "post_quantum_algorithms",
                    |m: &QuantumResistance| { &m.post_quantum_algorithms },
                    |m: &mut QuantumResistance| { &mut m.post_quantum_algorithms },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "key_generation",
                    |m: &QuantumResistance| { &m.key_generation },
                    |m: &mut QuantumResistance| { &mut m.key_generation },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "hybrid_schemes",
                    |m: &QuantumResistance| { &m.hybrid_schemes },
                    |m: &mut QuantumResistance| { &mut m.hybrid_schemes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "security_levels",
                    |m: &QuantumResistance| { &m.security_levels },
                    |m: &mut QuantumResistance| { &mut m.security_levels },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuantumResistance>(
                    "SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for QuantumResistance {
            const NAME: &'static str = "QuantumResistance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.post_quantum_algorithms.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.key_generation.insert(key, value);
                        },
                        24 => {
                            self.hybrid_schemes = is.read_bool()?;
                        },
                        34 => {
                            self.security_levels.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.post_quantum_algorithms {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.key_generation {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.hybrid_schemes != false {
                    my_size += 1 + 1;
                }
                for value in &self.security_levels {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.post_quantum_algorithms {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.key_generation {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.hybrid_schemes != false {
                    os.write_bool(3, self.hybrid_schemes)?;
                }
                for v in &self.security_levels {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> QuantumResistance {
                QuantumResistance::new()
            }

            fn clear(&mut self) {
                self.post_quantum_algorithms.clear();
                self.key_generation.clear();
                self.hybrid_schemes = false;
                self.security_levels.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static QuantumResistance {
                static instance: ::protobuf::rt::Lazy<QuantumResistance> = ::protobuf::rt::Lazy::new();
                instance.get(QuantumResistance::new)
            }
        }

        impl ::protobuf::MessageFull for QuantumResistance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SecurityEnhancementSystemV2.CryptographicSuite.QuantumResistance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for QuantumResistance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for QuantumResistance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ZeroKnowledge {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge.proof_systems)
            pub proof_systems: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge.protocol_definitions)
            pub protocol_definitions: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge.interactive_proofs)
            pub interactive_proofs: bool,
            // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge.witness_generation)
            pub witness_generation: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ZeroKnowledge {
            fn default() -> &'a ZeroKnowledge {
                <ZeroKnowledge as ::protobuf::Message>::default_instance()
            }
        }

        impl ZeroKnowledge {
            pub fn new() -> ZeroKnowledge {
                ::std::default::Default::default()
            }

            // repeated string proof_systems = 1;

            pub fn proof_systems(&self) -> &[::std::string::String] {
                &self.proof_systems
            }

            pub fn clear_proof_systems(&mut self) {
                self.proof_systems.clear();
            }

            // Param is passed by value, moved
            pub fn set_proof_systems(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.proof_systems = v;
            }

            // Mutable pointer to the field.
            pub fn mut_proof_systems(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.proof_systems
            }

            // Take field
            pub fn take_proof_systems(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.proof_systems, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge.ProtocolDefinitionsEntry protocol_definitions = 2;

            pub fn protocol_definitions(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.protocol_definitions
            }

            pub fn clear_protocol_definitions(&mut self) {
                self.protocol_definitions.clear();
            }

            // Param is passed by value, moved
            pub fn set_protocol_definitions(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.protocol_definitions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_protocol_definitions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.protocol_definitions
            }

            // Take field
            pub fn take_protocol_definitions(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.protocol_definitions, ::std::collections::HashMap::new())
            }

            // bool interactive_proofs = 3;

            pub fn interactive_proofs(&self) -> bool {
                self.interactive_proofs
            }

            pub fn clear_interactive_proofs(&mut self) {
                self.interactive_proofs = false;
            }

            // Param is passed by value, moved
            pub fn set_interactive_proofs(&mut self, v: bool) {
                self.interactive_proofs = v;
            }

            // repeated string witness_generation = 4;

            pub fn witness_generation(&self) -> &[::std::string::String] {
                &self.witness_generation
            }

            pub fn clear_witness_generation(&mut self) {
                self.witness_generation.clear();
            }

            // Param is passed by value, moved
            pub fn set_witness_generation(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.witness_generation = v;
            }

            // Mutable pointer to the field.
            pub fn mut_witness_generation(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.witness_generation
            }

            // Take field
            pub fn take_witness_generation(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.witness_generation, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "proof_systems",
                    |m: &ZeroKnowledge| { &m.proof_systems },
                    |m: &mut ZeroKnowledge| { &mut m.proof_systems },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "protocol_definitions",
                    |m: &ZeroKnowledge| { &m.protocol_definitions },
                    |m: &mut ZeroKnowledge| { &mut m.protocol_definitions },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "interactive_proofs",
                    |m: &ZeroKnowledge| { &m.interactive_proofs },
                    |m: &mut ZeroKnowledge| { &mut m.interactive_proofs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "witness_generation",
                    |m: &ZeroKnowledge| { &m.witness_generation },
                    |m: &mut ZeroKnowledge| { &mut m.witness_generation },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ZeroKnowledge>(
                    "SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ZeroKnowledge {
            const NAME: &'static str = "ZeroKnowledge";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.proof_systems.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.protocol_definitions.insert(key, value);
                        },
                        24 => {
                            self.interactive_proofs = is.read_bool()?;
                        },
                        34 => {
                            self.witness_generation.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.proof_systems {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.protocol_definitions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.interactive_proofs != false {
                    my_size += 1 + 1;
                }
                for value in &self.witness_generation {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.proof_systems {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.protocol_definitions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.interactive_proofs != false {
                    os.write_bool(3, self.interactive_proofs)?;
                }
                for v in &self.witness_generation {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ZeroKnowledge {
                ZeroKnowledge::new()
            }

            fn clear(&mut self) {
                self.proof_systems.clear();
                self.protocol_definitions.clear();
                self.interactive_proofs = false;
                self.witness_generation.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ZeroKnowledge {
                static instance: ::protobuf::rt::Lazy<ZeroKnowledge> = ::protobuf::rt::Lazy::new();
                instance.get(ZeroKnowledge::new)
            }
        }

        impl ::protobuf::MessageFull for ZeroKnowledge {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ZeroKnowledge {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ZeroKnowledge {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.MetaProgrammingSystemV2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MetaProgrammingSystemV2 {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.MetaProgrammingSystemV2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MetaProgrammingSystemV2 {
    fn default() -> &'a MetaProgrammingSystemV2 {
        <MetaProgrammingSystemV2 as ::protobuf::Message>::default_instance()
    }
}

impl MetaProgrammingSystemV2 {
    pub fn new() -> MetaProgrammingSystemV2 {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetaProgrammingSystemV2>(
            "MetaProgrammingSystemV2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MetaProgrammingSystemV2 {
    const NAME: &'static str = "MetaProgrammingSystemV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MetaProgrammingSystemV2 {
        MetaProgrammingSystemV2::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MetaProgrammingSystemV2 {
        static instance: MetaProgrammingSystemV2 = MetaProgrammingSystemV2 {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MetaProgrammingSystemV2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MetaProgrammingSystemV2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MetaProgrammingSystemV2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MetaProgrammingSystemV2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MetaProgrammingSystemV2`
pub mod meta_programming_system_v2 {
    // @@protoc_insertion_point(message:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CodeGeneration {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CodeGeneration {
        fn default() -> &'a CodeGeneration {
            <CodeGeneration as ::protobuf::Message>::default_instance()
        }
    }

    impl CodeGeneration {
        pub fn new() -> CodeGeneration {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeGeneration>(
                "MetaProgrammingSystemV2.CodeGeneration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CodeGeneration {
        const NAME: &'static str = "CodeGeneration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CodeGeneration {
            CodeGeneration::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CodeGeneration {
            static instance: CodeGeneration = CodeGeneration {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CodeGeneration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MetaProgrammingSystemV2.CodeGeneration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CodeGeneration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CodeGeneration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CodeGeneration`
    pub mod code_generation {
        // @@protoc_insertion_point(message:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.TemplateEngine)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TemplateEngine {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.TemplateEngine.template_patterns)
            pub template_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.TemplateEngine.expansion_rules)
            pub expansion_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.TemplateEngine.type_safe_templates)
            pub type_safe_templates: bool,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.TemplateEngine.specialization_rules)
            pub specialization_rules: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.TemplateEngine.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TemplateEngine {
            fn default() -> &'a TemplateEngine {
                <TemplateEngine as ::protobuf::Message>::default_instance()
            }
        }

        impl TemplateEngine {
            pub fn new() -> TemplateEngine {
                ::std::default::Default::default()
            }

            // repeated string template_patterns = 1;

            pub fn template_patterns(&self) -> &[::std::string::String] {
                &self.template_patterns
            }

            pub fn clear_template_patterns(&mut self) {
                self.template_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_template_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.template_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_template_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.template_patterns
            }

            // Take field
            pub fn take_template_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.template_patterns, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.TemplateEngine.ExpansionRulesEntry expansion_rules = 2;

            pub fn expansion_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.expansion_rules
            }

            pub fn clear_expansion_rules(&mut self) {
                self.expansion_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_expansion_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.expansion_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_expansion_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.expansion_rules
            }

            // Take field
            pub fn take_expansion_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.expansion_rules, ::std::collections::HashMap::new())
            }

            // bool type_safe_templates = 3;

            pub fn type_safe_templates(&self) -> bool {
                self.type_safe_templates
            }

            pub fn clear_type_safe_templates(&mut self) {
                self.type_safe_templates = false;
            }

            // Param is passed by value, moved
            pub fn set_type_safe_templates(&mut self, v: bool) {
                self.type_safe_templates = v;
            }

            // repeated string specialization_rules = 4;

            pub fn specialization_rules(&self) -> &[::std::string::String] {
                &self.specialization_rules
            }

            pub fn clear_specialization_rules(&mut self) {
                self.specialization_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_specialization_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.specialization_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_specialization_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.specialization_rules
            }

            // Take field
            pub fn take_specialization_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.specialization_rules, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "template_patterns",
                    |m: &TemplateEngine| { &m.template_patterns },
                    |m: &mut TemplateEngine| { &mut m.template_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "expansion_rules",
                    |m: &TemplateEngine| { &m.expansion_rules },
                    |m: &mut TemplateEngine| { &mut m.expansion_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "type_safe_templates",
                    |m: &TemplateEngine| { &m.type_safe_templates },
                    |m: &mut TemplateEngine| { &mut m.type_safe_templates },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "specialization_rules",
                    |m: &TemplateEngine| { &m.specialization_rules },
                    |m: &mut TemplateEngine| { &mut m.specialization_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TemplateEngine>(
                    "MetaProgrammingSystemV2.CodeGeneration.TemplateEngine",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TemplateEngine {
            const NAME: &'static str = "TemplateEngine";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.template_patterns.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.expansion_rules.insert(key, value);
                        },
                        24 => {
                            self.type_safe_templates = is.read_bool()?;
                        },
                        34 => {
                            self.specialization_rules.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.template_patterns {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.expansion_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.type_safe_templates != false {
                    my_size += 1 + 1;
                }
                for value in &self.specialization_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.template_patterns {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.expansion_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.type_safe_templates != false {
                    os.write_bool(3, self.type_safe_templates)?;
                }
                for v in &self.specialization_rules {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TemplateEngine {
                TemplateEngine::new()
            }

            fn clear(&mut self) {
                self.template_patterns.clear();
                self.expansion_rules.clear();
                self.type_safe_templates = false;
                self.specialization_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TemplateEngine {
                static instance: ::protobuf::rt::Lazy<TemplateEngine> = ::protobuf::rt::Lazy::new();
                instance.get(TemplateEngine::new)
            }
        }

        impl ::protobuf::MessageFull for TemplateEngine {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetaProgrammingSystemV2.CodeGeneration.TemplateEngine").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TemplateEngine {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TemplateEngine {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.MacroSystem)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MacroSystem {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.MacroSystem.macro_definitions)
            pub macro_definitions: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.MacroSystem.expansion_policies)
            pub expansion_policies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.MacroSystem.hygiene_checking)
            pub hygiene_checking: bool,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.MacroSystem.syntax_rules)
            pub syntax_rules: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.MacroSystem.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MacroSystem {
            fn default() -> &'a MacroSystem {
                <MacroSystem as ::protobuf::Message>::default_instance()
            }
        }

        impl MacroSystem {
            pub fn new() -> MacroSystem {
                ::std::default::Default::default()
            }

            // repeated string macro_definitions = 1;

            pub fn macro_definitions(&self) -> &[::std::string::String] {
                &self.macro_definitions
            }

            pub fn clear_macro_definitions(&mut self) {
                self.macro_definitions.clear();
            }

            // Param is passed by value, moved
            pub fn set_macro_definitions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.macro_definitions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_macro_definitions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.macro_definitions
            }

            // Take field
            pub fn take_macro_definitions(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.macro_definitions, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.MetaProgrammingSystemV2.CodeGeneration.MacroSystem.ExpansionPoliciesEntry expansion_policies = 2;

            pub fn expansion_policies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.expansion_policies
            }

            pub fn clear_expansion_policies(&mut self) {
                self.expansion_policies.clear();
            }

            // Param is passed by value, moved
            pub fn set_expansion_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.expansion_policies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_expansion_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.expansion_policies
            }

            // Take field
            pub fn take_expansion_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.expansion_policies, ::std::collections::HashMap::new())
            }

            // bool hygiene_checking = 3;

            pub fn hygiene_checking(&self) -> bool {
                self.hygiene_checking
            }

            pub fn clear_hygiene_checking(&mut self) {
                self.hygiene_checking = false;
            }

            // Param is passed by value, moved
            pub fn set_hygiene_checking(&mut self, v: bool) {
                self.hygiene_checking = v;
            }

            // repeated string syntax_rules = 4;

            pub fn syntax_rules(&self) -> &[::std::string::String] {
                &self.syntax_rules
            }

            pub fn clear_syntax_rules(&mut self) {
                self.syntax_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_syntax_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.syntax_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_syntax_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.syntax_rules
            }

            // Take field
            pub fn take_syntax_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.syntax_rules, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "macro_definitions",
                    |m: &MacroSystem| { &m.macro_definitions },
                    |m: &mut MacroSystem| { &mut m.macro_definitions },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "expansion_policies",
                    |m: &MacroSystem| { &m.expansion_policies },
                    |m: &mut MacroSystem| { &mut m.expansion_policies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "hygiene_checking",
                    |m: &MacroSystem| { &m.hygiene_checking },
                    |m: &mut MacroSystem| { &mut m.hygiene_checking },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "syntax_rules",
                    |m: &MacroSystem| { &m.syntax_rules },
                    |m: &mut MacroSystem| { &mut m.syntax_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MacroSystem>(
                    "MetaProgrammingSystemV2.CodeGeneration.MacroSystem",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MacroSystem {
            const NAME: &'static str = "MacroSystem";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.macro_definitions.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.expansion_policies.insert(key, value);
                        },
                        24 => {
                            self.hygiene_checking = is.read_bool()?;
                        },
                        34 => {
                            self.syntax_rules.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.macro_definitions {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.expansion_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.hygiene_checking != false {
                    my_size += 1 + 1;
                }
                for value in &self.syntax_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.macro_definitions {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.expansion_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.hygiene_checking != false {
                    os.write_bool(3, self.hygiene_checking)?;
                }
                for v in &self.syntax_rules {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MacroSystem {
                MacroSystem::new()
            }

            fn clear(&mut self) {
                self.macro_definitions.clear();
                self.expansion_policies.clear();
                self.hygiene_checking = false;
                self.syntax_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MacroSystem {
                static instance: ::protobuf::rt::Lazy<MacroSystem> = ::protobuf::rt::Lazy::new();
                instance.get(MacroSystem::new)
            }
        }

        impl ::protobuf::MessageFull for MacroSystem {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetaProgrammingSystemV2.CodeGeneration.MacroSystem").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MacroSystem {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MacroSystem {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReflectionSystem {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReflectionSystem {
        fn default() -> &'a ReflectionSystem {
            <ReflectionSystem as ::protobuf::Message>::default_instance()
        }
    }

    impl ReflectionSystem {
        pub fn new() -> ReflectionSystem {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReflectionSystem>(
                "MetaProgrammingSystemV2.ReflectionSystem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReflectionSystem {
        const NAME: &'static str = "ReflectionSystem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReflectionSystem {
            ReflectionSystem::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReflectionSystem {
            static instance: ReflectionSystem = ReflectionSystem {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReflectionSystem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MetaProgrammingSystemV2.ReflectionSystem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReflectionSystem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReflectionSystem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ReflectionSystem`
    pub mod reflection_system {
        // @@protoc_insertion_point(message:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TypeIntrospection {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection.type_patterns)
            pub type_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection.reflection_rules)
            pub reflection_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection.runtime_reflection)
            pub runtime_reflection: bool,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection.type_constraints)
            pub type_constraints: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TypeIntrospection {
            fn default() -> &'a TypeIntrospection {
                <TypeIntrospection as ::protobuf::Message>::default_instance()
            }
        }

        impl TypeIntrospection {
            pub fn new() -> TypeIntrospection {
                ::std::default::Default::default()
            }

            // repeated string type_patterns = 1;

            pub fn type_patterns(&self) -> &[::std::string::String] {
                &self.type_patterns
            }

            pub fn clear_type_patterns(&mut self) {
                self.type_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.type_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.type_patterns
            }

            // Take field
            pub fn take_type_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.type_patterns, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection.ReflectionRulesEntry reflection_rules = 2;

            pub fn reflection_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.reflection_rules
            }

            pub fn clear_reflection_rules(&mut self) {
                self.reflection_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_reflection_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.reflection_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_reflection_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.reflection_rules
            }

            // Take field
            pub fn take_reflection_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.reflection_rules, ::std::collections::HashMap::new())
            }

            // bool runtime_reflection = 3;

            pub fn runtime_reflection(&self) -> bool {
                self.runtime_reflection
            }

            pub fn clear_runtime_reflection(&mut self) {
                self.runtime_reflection = false;
            }

            // Param is passed by value, moved
            pub fn set_runtime_reflection(&mut self, v: bool) {
                self.runtime_reflection = v;
            }

            // repeated string type_constraints = 4;

            pub fn type_constraints(&self) -> &[::std::string::String] {
                &self.type_constraints
            }

            pub fn clear_type_constraints(&mut self) {
                self.type_constraints.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_constraints(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.type_constraints = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_constraints(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.type_constraints
            }

            // Take field
            pub fn take_type_constraints(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.type_constraints, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "type_patterns",
                    |m: &TypeIntrospection| { &m.type_patterns },
                    |m: &mut TypeIntrospection| { &mut m.type_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "reflection_rules",
                    |m: &TypeIntrospection| { &m.reflection_rules },
                    |m: &mut TypeIntrospection| { &mut m.reflection_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "runtime_reflection",
                    |m: &TypeIntrospection| { &m.runtime_reflection },
                    |m: &mut TypeIntrospection| { &mut m.runtime_reflection },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "type_constraints",
                    |m: &TypeIntrospection| { &m.type_constraints },
                    |m: &mut TypeIntrospection| { &mut m.type_constraints },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeIntrospection>(
                    "MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TypeIntrospection {
            const NAME: &'static str = "TypeIntrospection";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.type_patterns.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.reflection_rules.insert(key, value);
                        },
                        24 => {
                            self.runtime_reflection = is.read_bool()?;
                        },
                        34 => {
                            self.type_constraints.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.type_patterns {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.reflection_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.runtime_reflection != false {
                    my_size += 1 + 1;
                }
                for value in &self.type_constraints {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.type_patterns {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.reflection_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.runtime_reflection != false {
                    os.write_bool(3, self.runtime_reflection)?;
                }
                for v in &self.type_constraints {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TypeIntrospection {
                TypeIntrospection::new()
            }

            fn clear(&mut self) {
                self.type_patterns.clear();
                self.reflection_rules.clear();
                self.runtime_reflection = false;
                self.type_constraints.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TypeIntrospection {
                static instance: ::protobuf::rt::Lazy<TypeIntrospection> = ::protobuf::rt::Lazy::new();
                instance.get(TypeIntrospection::new)
            }
        }

        impl ::protobuf::MessageFull for TypeIntrospection {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetaProgrammingSystemV2.ReflectionSystem.TypeIntrospection").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TypeIntrospection {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TypeIntrospection {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MetaObjectProtocol {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol.protocol_methods)
            pub protocol_methods: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol.intercession_rules)
            pub intercession_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol.dynamic_dispatch)
            pub dynamic_dispatch: bool,
            // @@protoc_insertion_point(field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol.method_generation)
            pub method_generation: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MetaObjectProtocol {
            fn default() -> &'a MetaObjectProtocol {
                <MetaObjectProtocol as ::protobuf::Message>::default_instance()
            }
        }

        impl MetaObjectProtocol {
            pub fn new() -> MetaObjectProtocol {
                ::std::default::Default::default()
            }

            // repeated string protocol_methods = 1;

            pub fn protocol_methods(&self) -> &[::std::string::String] {
                &self.protocol_methods
            }

            pub fn clear_protocol_methods(&mut self) {
                self.protocol_methods.clear();
            }

            // Param is passed by value, moved
            pub fn set_protocol_methods(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.protocol_methods = v;
            }

            // Mutable pointer to the field.
            pub fn mut_protocol_methods(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.protocol_methods
            }

            // Take field
            pub fn take_protocol_methods(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.protocol_methods, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol.IntercessionRulesEntry intercession_rules = 2;

            pub fn intercession_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.intercession_rules
            }

            pub fn clear_intercession_rules(&mut self) {
                self.intercession_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_intercession_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.intercession_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_intercession_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.intercession_rules
            }

            // Take field
            pub fn take_intercession_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.intercession_rules, ::std::collections::HashMap::new())
            }

            // bool dynamic_dispatch = 3;

            pub fn dynamic_dispatch(&self) -> bool {
                self.dynamic_dispatch
            }

            pub fn clear_dynamic_dispatch(&mut self) {
                self.dynamic_dispatch = false;
            }

            // Param is passed by value, moved
            pub fn set_dynamic_dispatch(&mut self, v: bool) {
                self.dynamic_dispatch = v;
            }

            // repeated string method_generation = 4;

            pub fn method_generation(&self) -> &[::std::string::String] {
                &self.method_generation
            }

            pub fn clear_method_generation(&mut self) {
                self.method_generation.clear();
            }

            // Param is passed by value, moved
            pub fn set_method_generation(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.method_generation = v;
            }

            // Mutable pointer to the field.
            pub fn mut_method_generation(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.method_generation
            }

            // Take field
            pub fn take_method_generation(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.method_generation, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "protocol_methods",
                    |m: &MetaObjectProtocol| { &m.protocol_methods },
                    |m: &mut MetaObjectProtocol| { &mut m.protocol_methods },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "intercession_rules",
                    |m: &MetaObjectProtocol| { &m.intercession_rules },
                    |m: &mut MetaObjectProtocol| { &mut m.intercession_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "dynamic_dispatch",
                    |m: &MetaObjectProtocol| { &m.dynamic_dispatch },
                    |m: &mut MetaObjectProtocol| { &mut m.dynamic_dispatch },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "method_generation",
                    |m: &MetaObjectProtocol| { &m.method_generation },
                    |m: &mut MetaObjectProtocol| { &mut m.method_generation },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MetaObjectProtocol>(
                    "MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MetaObjectProtocol {
            const NAME: &'static str = "MetaObjectProtocol";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.protocol_methods.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.intercession_rules.insert(key, value);
                        },
                        24 => {
                            self.dynamic_dispatch = is.read_bool()?;
                        },
                        34 => {
                            self.method_generation.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.protocol_methods {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.intercession_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.dynamic_dispatch != false {
                    my_size += 1 + 1;
                }
                for value in &self.method_generation {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.protocol_methods {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.intercession_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.dynamic_dispatch != false {
                    os.write_bool(3, self.dynamic_dispatch)?;
                }
                for v in &self.method_generation {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MetaObjectProtocol {
                MetaObjectProtocol::new()
            }

            fn clear(&mut self) {
                self.protocol_methods.clear();
                self.intercession_rules.clear();
                self.dynamic_dispatch = false;
                self.method_generation.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MetaObjectProtocol {
                static instance: ::protobuf::rt::Lazy<MetaObjectProtocol> = ::protobuf::rt::Lazy::new();
                instance.get(MetaObjectProtocol::new)
            }
        }

        impl ::protobuf::MessageFull for MetaObjectProtocol {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MetaObjectProtocol {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MetaObjectProtocol {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.IntelligentDebuggingSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IntelligentDebuggingSystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentDebuggingSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IntelligentDebuggingSystem {
    fn default() -> &'a IntelligentDebuggingSystem {
        <IntelligentDebuggingSystem as ::protobuf::Message>::default_instance()
    }
}

impl IntelligentDebuggingSystem {
    pub fn new() -> IntelligentDebuggingSystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IntelligentDebuggingSystem>(
            "IntelligentDebuggingSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IntelligentDebuggingSystem {
    const NAME: &'static str = "IntelligentDebuggingSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IntelligentDebuggingSystem {
        IntelligentDebuggingSystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IntelligentDebuggingSystem {
        static instance: IntelligentDebuggingSystem = IntelligentDebuggingSystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IntelligentDebuggingSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IntelligentDebuggingSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IntelligentDebuggingSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntelligentDebuggingSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `IntelligentDebuggingSystem`
pub mod intelligent_debugging_system {
    // @@protoc_insertion_point(message:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutomaticDebugger {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutomaticDebugger {
        fn default() -> &'a AutomaticDebugger {
            <AutomaticDebugger as ::protobuf::Message>::default_instance()
        }
    }

    impl AutomaticDebugger {
        pub fn new() -> AutomaticDebugger {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutomaticDebugger>(
                "IntelligentDebuggingSystem.AutomaticDebugger",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AutomaticDebugger {
        const NAME: &'static str = "AutomaticDebugger";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutomaticDebugger {
            AutomaticDebugger::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutomaticDebugger {
            static instance: AutomaticDebugger = AutomaticDebugger {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AutomaticDebugger {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentDebuggingSystem.AutomaticDebugger").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AutomaticDebugger {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutomaticDebugger {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AutomaticDebugger`
    pub mod automatic_debugger {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.BugDetection)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct BugDetection {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.BugDetection.pattern_matching)
            pub pattern_matching: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.BugDetection.heuristic_rules)
            pub heuristic_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.BugDetection.runtime_monitoring)
            pub runtime_monitoring: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.BugDetection.fix_suggestions)
            pub fix_suggestions: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.BugDetection.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a BugDetection {
            fn default() -> &'a BugDetection {
                <BugDetection as ::protobuf::Message>::default_instance()
            }
        }

        impl BugDetection {
            pub fn new() -> BugDetection {
                ::std::default::Default::default()
            }

            // repeated string pattern_matching = 1;

            pub fn pattern_matching(&self) -> &[::std::string::String] {
                &self.pattern_matching
            }

            pub fn clear_pattern_matching(&mut self) {
                self.pattern_matching.clear();
            }

            // Param is passed by value, moved
            pub fn set_pattern_matching(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.pattern_matching = v;
            }

            // Mutable pointer to the field.
            pub fn mut_pattern_matching(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.pattern_matching
            }

            // Take field
            pub fn take_pattern_matching(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.pattern_matching, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.BugDetection.HeuristicRulesEntry heuristic_rules = 2;

            pub fn heuristic_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.heuristic_rules
            }

            pub fn clear_heuristic_rules(&mut self) {
                self.heuristic_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_heuristic_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.heuristic_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_heuristic_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.heuristic_rules
            }

            // Take field
            pub fn take_heuristic_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.heuristic_rules, ::std::collections::HashMap::new())
            }

            // bool runtime_monitoring = 3;

            pub fn runtime_monitoring(&self) -> bool {
                self.runtime_monitoring
            }

            pub fn clear_runtime_monitoring(&mut self) {
                self.runtime_monitoring = false;
            }

            // Param is passed by value, moved
            pub fn set_runtime_monitoring(&mut self, v: bool) {
                self.runtime_monitoring = v;
            }

            // repeated string fix_suggestions = 4;

            pub fn fix_suggestions(&self) -> &[::std::string::String] {
                &self.fix_suggestions
            }

            pub fn clear_fix_suggestions(&mut self) {
                self.fix_suggestions.clear();
            }

            // Param is passed by value, moved
            pub fn set_fix_suggestions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.fix_suggestions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_fix_suggestions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.fix_suggestions
            }

            // Take field
            pub fn take_fix_suggestions(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.fix_suggestions, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "pattern_matching",
                    |m: &BugDetection| { &m.pattern_matching },
                    |m: &mut BugDetection| { &mut m.pattern_matching },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "heuristic_rules",
                    |m: &BugDetection| { &m.heuristic_rules },
                    |m: &mut BugDetection| { &mut m.heuristic_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "runtime_monitoring",
                    |m: &BugDetection| { &m.runtime_monitoring },
                    |m: &mut BugDetection| { &mut m.runtime_monitoring },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "fix_suggestions",
                    |m: &BugDetection| { &m.fix_suggestions },
                    |m: &mut BugDetection| { &mut m.fix_suggestions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BugDetection>(
                    "IntelligentDebuggingSystem.AutomaticDebugger.BugDetection",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for BugDetection {
            const NAME: &'static str = "BugDetection";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.pattern_matching.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.heuristic_rules.insert(key, value);
                        },
                        24 => {
                            self.runtime_monitoring = is.read_bool()?;
                        },
                        34 => {
                            self.fix_suggestions.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.pattern_matching {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.heuristic_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.runtime_monitoring != false {
                    my_size += 1 + 1;
                }
                for value in &self.fix_suggestions {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.pattern_matching {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.heuristic_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.runtime_monitoring != false {
                    os.write_bool(3, self.runtime_monitoring)?;
                }
                for v in &self.fix_suggestions {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> BugDetection {
                BugDetection::new()
            }

            fn clear(&mut self) {
                self.pattern_matching.clear();
                self.heuristic_rules.clear();
                self.runtime_monitoring = false;
                self.fix_suggestions.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static BugDetection {
                static instance: ::protobuf::rt::Lazy<BugDetection> = ::protobuf::rt::Lazy::new();
                instance.get(BugDetection::new)
            }
        }

        impl ::protobuf::MessageFull for BugDetection {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentDebuggingSystem.AutomaticDebugger.BugDetection").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for BugDetection {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for BugDetection {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RootCauseAnalysis {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis.analysis_strategies)
            pub analysis_strategies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis.causal_inference)
            pub causal_inference: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis.symbolic_execution)
            pub symbolic_execution: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis.trace_analysis)
            pub trace_analysis: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RootCauseAnalysis {
            fn default() -> &'a RootCauseAnalysis {
                <RootCauseAnalysis as ::protobuf::Message>::default_instance()
            }
        }

        impl RootCauseAnalysis {
            pub fn new() -> RootCauseAnalysis {
                ::std::default::Default::default()
            }

            // repeated string analysis_strategies = 1;

            pub fn analysis_strategies(&self) -> &[::std::string::String] {
                &self.analysis_strategies
            }

            pub fn clear_analysis_strategies(&mut self) {
                self.analysis_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_analysis_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.analysis_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_analysis_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.analysis_strategies
            }

            // Take field
            pub fn take_analysis_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.analysis_strategies, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis.CausalInferenceEntry causal_inference = 2;

            pub fn causal_inference(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.causal_inference
            }

            pub fn clear_causal_inference(&mut self) {
                self.causal_inference.clear();
            }

            // Param is passed by value, moved
            pub fn set_causal_inference(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.causal_inference = v;
            }

            // Mutable pointer to the field.
            pub fn mut_causal_inference(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.causal_inference
            }

            // Take field
            pub fn take_causal_inference(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.causal_inference, ::std::collections::HashMap::new())
            }

            // bool symbolic_execution = 3;

            pub fn symbolic_execution(&self) -> bool {
                self.symbolic_execution
            }

            pub fn clear_symbolic_execution(&mut self) {
                self.symbolic_execution = false;
            }

            // Param is passed by value, moved
            pub fn set_symbolic_execution(&mut self, v: bool) {
                self.symbolic_execution = v;
            }

            // repeated string trace_analysis = 4;

            pub fn trace_analysis(&self) -> &[::std::string::String] {
                &self.trace_analysis
            }

            pub fn clear_trace_analysis(&mut self) {
                self.trace_analysis.clear();
            }

            // Param is passed by value, moved
            pub fn set_trace_analysis(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.trace_analysis = v;
            }

            // Mutable pointer to the field.
            pub fn mut_trace_analysis(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.trace_analysis
            }

            // Take field
            pub fn take_trace_analysis(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.trace_analysis, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "analysis_strategies",
                    |m: &RootCauseAnalysis| { &m.analysis_strategies },
                    |m: &mut RootCauseAnalysis| { &mut m.analysis_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "causal_inference",
                    |m: &RootCauseAnalysis| { &m.causal_inference },
                    |m: &mut RootCauseAnalysis| { &mut m.causal_inference },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "symbolic_execution",
                    |m: &RootCauseAnalysis| { &m.symbolic_execution },
                    |m: &mut RootCauseAnalysis| { &mut m.symbolic_execution },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "trace_analysis",
                    |m: &RootCauseAnalysis| { &m.trace_analysis },
                    |m: &mut RootCauseAnalysis| { &mut m.trace_analysis },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RootCauseAnalysis>(
                    "IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RootCauseAnalysis {
            const NAME: &'static str = "RootCauseAnalysis";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.analysis_strategies.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.causal_inference.insert(key, value);
                        },
                        24 => {
                            self.symbolic_execution = is.read_bool()?;
                        },
                        34 => {
                            self.trace_analysis.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.analysis_strategies {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.causal_inference {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.symbolic_execution != false {
                    my_size += 1 + 1;
                }
                for value in &self.trace_analysis {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.analysis_strategies {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.causal_inference {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.symbolic_execution != false {
                    os.write_bool(3, self.symbolic_execution)?;
                }
                for v in &self.trace_analysis {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RootCauseAnalysis {
                RootCauseAnalysis::new()
            }

            fn clear(&mut self) {
                self.analysis_strategies.clear();
                self.causal_inference.clear();
                self.symbolic_execution = false;
                self.trace_analysis.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RootCauseAnalysis {
                static instance: ::protobuf::rt::Lazy<RootCauseAnalysis> = ::protobuf::rt::Lazy::new();
                instance.get(RootCauseAnalysis::new)
            }
        }

        impl ::protobuf::MessageFull for RootCauseAnalysis {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentDebuggingSystem.AutomaticDebugger.RootCauseAnalysis").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RootCauseAnalysis {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RootCauseAnalysis {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DebuggingAssistant {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DebuggingAssistant {
        fn default() -> &'a DebuggingAssistant {
            <DebuggingAssistant as ::protobuf::Message>::default_instance()
        }
    }

    impl DebuggingAssistant {
        pub fn new() -> DebuggingAssistant {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DebuggingAssistant>(
                "IntelligentDebuggingSystem.DebuggingAssistant",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DebuggingAssistant {
        const NAME: &'static str = "DebuggingAssistant";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DebuggingAssistant {
            DebuggingAssistant::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DebuggingAssistant {
            static instance: DebuggingAssistant = DebuggingAssistant {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DebuggingAssistant {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentDebuggingSystem.DebuggingAssistant").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DebuggingAssistant {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DebuggingAssistant {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `DebuggingAssistant`
    pub mod debugging_assistant {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CodeUnderstanding {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding.semantic_analysis)
            pub semantic_analysis: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding.context_inference)
            pub context_inference: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding.natural_language)
            pub natural_language: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding.explanation_generation)
            pub explanation_generation: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CodeUnderstanding {
            fn default() -> &'a CodeUnderstanding {
                <CodeUnderstanding as ::protobuf::Message>::default_instance()
            }
        }

        impl CodeUnderstanding {
            pub fn new() -> CodeUnderstanding {
                ::std::default::Default::default()
            }

            // repeated string semantic_analysis = 1;

            pub fn semantic_analysis(&self) -> &[::std::string::String] {
                &self.semantic_analysis
            }

            pub fn clear_semantic_analysis(&mut self) {
                self.semantic_analysis.clear();
            }

            // Param is passed by value, moved
            pub fn set_semantic_analysis(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.semantic_analysis = v;
            }

            // Mutable pointer to the field.
            pub fn mut_semantic_analysis(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.semantic_analysis
            }

            // Take field
            pub fn take_semantic_analysis(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.semantic_analysis, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding.ContextInferenceEntry context_inference = 2;

            pub fn context_inference(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.context_inference
            }

            pub fn clear_context_inference(&mut self) {
                self.context_inference.clear();
            }

            // Param is passed by value, moved
            pub fn set_context_inference(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.context_inference = v;
            }

            // Mutable pointer to the field.
            pub fn mut_context_inference(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.context_inference
            }

            // Take field
            pub fn take_context_inference(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.context_inference, ::std::collections::HashMap::new())
            }

            // bool natural_language = 3;

            pub fn natural_language(&self) -> bool {
                self.natural_language
            }

            pub fn clear_natural_language(&mut self) {
                self.natural_language = false;
            }

            // Param is passed by value, moved
            pub fn set_natural_language(&mut self, v: bool) {
                self.natural_language = v;
            }

            // repeated string explanation_generation = 4;

            pub fn explanation_generation(&self) -> &[::std::string::String] {
                &self.explanation_generation
            }

            pub fn clear_explanation_generation(&mut self) {
                self.explanation_generation.clear();
            }

            // Param is passed by value, moved
            pub fn set_explanation_generation(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.explanation_generation = v;
            }

            // Mutable pointer to the field.
            pub fn mut_explanation_generation(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.explanation_generation
            }

            // Take field
            pub fn take_explanation_generation(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.explanation_generation, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "semantic_analysis",
                    |m: &CodeUnderstanding| { &m.semantic_analysis },
                    |m: &mut CodeUnderstanding| { &mut m.semantic_analysis },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "context_inference",
                    |m: &CodeUnderstanding| { &m.context_inference },
                    |m: &mut CodeUnderstanding| { &mut m.context_inference },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "natural_language",
                    |m: &CodeUnderstanding| { &m.natural_language },
                    |m: &mut CodeUnderstanding| { &mut m.natural_language },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "explanation_generation",
                    |m: &CodeUnderstanding| { &m.explanation_generation },
                    |m: &mut CodeUnderstanding| { &mut m.explanation_generation },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeUnderstanding>(
                    "IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CodeUnderstanding {
            const NAME: &'static str = "CodeUnderstanding";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.semantic_analysis.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.context_inference.insert(key, value);
                        },
                        24 => {
                            self.natural_language = is.read_bool()?;
                        },
                        34 => {
                            self.explanation_generation.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.semantic_analysis {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.context_inference {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.natural_language != false {
                    my_size += 1 + 1;
                }
                for value in &self.explanation_generation {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.semantic_analysis {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.context_inference {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.natural_language != false {
                    os.write_bool(3, self.natural_language)?;
                }
                for v in &self.explanation_generation {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CodeUnderstanding {
                CodeUnderstanding::new()
            }

            fn clear(&mut self) {
                self.semantic_analysis.clear();
                self.context_inference.clear();
                self.natural_language = false;
                self.explanation_generation.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CodeUnderstanding {
                static instance: ::protobuf::rt::Lazy<CodeUnderstanding> = ::protobuf::rt::Lazy::new();
                instance.get(CodeUnderstanding::new)
            }
        }

        impl ::protobuf::MessageFull for CodeUnderstanding {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentDebuggingSystem.DebuggingAssistant.CodeUnderstanding").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CodeUnderstanding {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CodeUnderstanding {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct InteractiveDebugging {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging.interaction_modes)
            pub interaction_modes: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging.visualization_rules)
            pub visualization_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging.time_travel_debugging)
            pub time_travel_debugging: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging.breakpoint_strategies)
            pub breakpoint_strategies: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a InteractiveDebugging {
            fn default() -> &'a InteractiveDebugging {
                <InteractiveDebugging as ::protobuf::Message>::default_instance()
            }
        }

        impl InteractiveDebugging {
            pub fn new() -> InteractiveDebugging {
                ::std::default::Default::default()
            }

            // repeated string interaction_modes = 1;

            pub fn interaction_modes(&self) -> &[::std::string::String] {
                &self.interaction_modes
            }

            pub fn clear_interaction_modes(&mut self) {
                self.interaction_modes.clear();
            }

            // Param is passed by value, moved
            pub fn set_interaction_modes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.interaction_modes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_interaction_modes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.interaction_modes
            }

            // Take field
            pub fn take_interaction_modes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.interaction_modes, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging.VisualizationRulesEntry visualization_rules = 2;

            pub fn visualization_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.visualization_rules
            }

            pub fn clear_visualization_rules(&mut self) {
                self.visualization_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_visualization_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.visualization_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_visualization_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.visualization_rules
            }

            // Take field
            pub fn take_visualization_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.visualization_rules, ::std::collections::HashMap::new())
            }

            // bool time_travel_debugging = 3;

            pub fn time_travel_debugging(&self) -> bool {
                self.time_travel_debugging
            }

            pub fn clear_time_travel_debugging(&mut self) {
                self.time_travel_debugging = false;
            }

            // Param is passed by value, moved
            pub fn set_time_travel_debugging(&mut self, v: bool) {
                self.time_travel_debugging = v;
            }

            // repeated string breakpoint_strategies = 4;

            pub fn breakpoint_strategies(&self) -> &[::std::string::String] {
                &self.breakpoint_strategies
            }

            pub fn clear_breakpoint_strategies(&mut self) {
                self.breakpoint_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_breakpoint_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.breakpoint_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_breakpoint_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.breakpoint_strategies
            }

            // Take field
            pub fn take_breakpoint_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.breakpoint_strategies, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "interaction_modes",
                    |m: &InteractiveDebugging| { &m.interaction_modes },
                    |m: &mut InteractiveDebugging| { &mut m.interaction_modes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "visualization_rules",
                    |m: &InteractiveDebugging| { &m.visualization_rules },
                    |m: &mut InteractiveDebugging| { &mut m.visualization_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "time_travel_debugging",
                    |m: &InteractiveDebugging| { &m.time_travel_debugging },
                    |m: &mut InteractiveDebugging| { &mut m.time_travel_debugging },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "breakpoint_strategies",
                    |m: &InteractiveDebugging| { &m.breakpoint_strategies },
                    |m: &mut InteractiveDebugging| { &mut m.breakpoint_strategies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteractiveDebugging>(
                    "IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for InteractiveDebugging {
            const NAME: &'static str = "InteractiveDebugging";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.interaction_modes.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.visualization_rules.insert(key, value);
                        },
                        24 => {
                            self.time_travel_debugging = is.read_bool()?;
                        },
                        34 => {
                            self.breakpoint_strategies.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.interaction_modes {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.visualization_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.time_travel_debugging != false {
                    my_size += 1 + 1;
                }
                for value in &self.breakpoint_strategies {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.interaction_modes {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.visualization_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.time_travel_debugging != false {
                    os.write_bool(3, self.time_travel_debugging)?;
                }
                for v in &self.breakpoint_strategies {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> InteractiveDebugging {
                InteractiveDebugging::new()
            }

            fn clear(&mut self) {
                self.interaction_modes.clear();
                self.visualization_rules.clear();
                self.time_travel_debugging = false;
                self.breakpoint_strategies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static InteractiveDebugging {
                static instance: ::protobuf::rt::Lazy<InteractiveDebugging> = ::protobuf::rt::Lazy::new();
                instance.get(InteractiveDebugging::new)
            }
        }

        impl ::protobuf::MessageFull for InteractiveDebugging {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentDebuggingSystem.DebuggingAssistant.InteractiveDebugging").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for InteractiveDebugging {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for InteractiveDebugging {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.DynamicOptimizationSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DynamicOptimizationSystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.DynamicOptimizationSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DynamicOptimizationSystem {
    fn default() -> &'a DynamicOptimizationSystem {
        <DynamicOptimizationSystem as ::protobuf::Message>::default_instance()
    }
}

impl DynamicOptimizationSystem {
    pub fn new() -> DynamicOptimizationSystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DynamicOptimizationSystem>(
            "DynamicOptimizationSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DynamicOptimizationSystem {
    const NAME: &'static str = "DynamicOptimizationSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DynamicOptimizationSystem {
        DynamicOptimizationSystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DynamicOptimizationSystem {
        static instance: DynamicOptimizationSystem = DynamicOptimizationSystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DynamicOptimizationSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DynamicOptimizationSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DynamicOptimizationSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicOptimizationSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DynamicOptimizationSystem`
pub mod dynamic_optimization_system {
    // @@protoc_insertion_point(message:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProfileGuidedOptimization {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.strategy)
        pub strategy: ::protobuf::EnumOrUnknown<profile_guided_optimization::OptimizationStrategy>,
        // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.profile_data)
        pub profile_data: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.optimization_weights)
        pub optimization_weights: ::std::collections::HashMap<::std::string::String, f32>,
        // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.adaptive_thresholds)
        pub adaptive_thresholds: bool,
        // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.feedback_loops)
        pub feedback_loops: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProfileGuidedOptimization {
        fn default() -> &'a ProfileGuidedOptimization {
            <ProfileGuidedOptimization as ::protobuf::Message>::default_instance()
        }
    }

    impl ProfileGuidedOptimization {
        pub fn new() -> ProfileGuidedOptimization {
            ::std::default::Default::default()
        }

        // .kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy strategy = 1;

        pub fn strategy(&self) -> profile_guided_optimization::OptimizationStrategy {
            self.strategy.enum_value_or_default()
        }

        pub fn clear_strategy(&mut self) {
            self.strategy = ::protobuf::EnumOrUnknown::new(profile_guided_optimization::OptimizationStrategy::CONSERVATIVE);
        }

        // Param is passed by value, moved
        pub fn set_strategy(&mut self, v: profile_guided_optimization::OptimizationStrategy) {
            self.strategy = ::protobuf::EnumOrUnknown::new(v);
        }

        // repeated string profile_data = 2;

        pub fn profile_data(&self) -> &[::std::string::String] {
            &self.profile_data
        }

        pub fn clear_profile_data(&mut self) {
            self.profile_data.clear();
        }

        // Param is passed by value, moved
        pub fn set_profile_data(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.profile_data = v;
        }

        // Mutable pointer to the field.
        pub fn mut_profile_data(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.profile_data
        }

        // Take field
        pub fn take_profile_data(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.profile_data, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationWeightsEntry optimization_weights = 3;

        pub fn optimization_weights(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
            &self.optimization_weights
        }

        pub fn clear_optimization_weights(&mut self) {
            self.optimization_weights.clear();
        }

        // Param is passed by value, moved
        pub fn set_optimization_weights(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
            self.optimization_weights = v;
        }

        // Mutable pointer to the field.
        pub fn mut_optimization_weights(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
            &mut self.optimization_weights
        }

        // Take field
        pub fn take_optimization_weights(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
            ::std::mem::replace(&mut self.optimization_weights, ::std::collections::HashMap::new())
        }

        // bool adaptive_thresholds = 4;

        pub fn adaptive_thresholds(&self) -> bool {
            self.adaptive_thresholds
        }

        pub fn clear_adaptive_thresholds(&mut self) {
            self.adaptive_thresholds = false;
        }

        // Param is passed by value, moved
        pub fn set_adaptive_thresholds(&mut self, v: bool) {
            self.adaptive_thresholds = v;
        }

        // repeated string feedback_loops = 5;

        pub fn feedback_loops(&self) -> &[::std::string::String] {
            &self.feedback_loops
        }

        pub fn clear_feedback_loops(&mut self) {
            self.feedback_loops.clear();
        }

        // Param is passed by value, moved
        pub fn set_feedback_loops(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.feedback_loops = v;
        }

        // Mutable pointer to the field.
        pub fn mut_feedback_loops(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.feedback_loops
        }

        // Take field
        pub fn take_feedback_loops(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.feedback_loops, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "strategy",
                |m: &ProfileGuidedOptimization| { &m.strategy },
                |m: &mut ProfileGuidedOptimization| { &mut m.strategy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "profile_data",
                |m: &ProfileGuidedOptimization| { &m.profile_data },
                |m: &mut ProfileGuidedOptimization| { &mut m.profile_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "optimization_weights",
                |m: &ProfileGuidedOptimization| { &m.optimization_weights },
                |m: &mut ProfileGuidedOptimization| { &mut m.optimization_weights },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "adaptive_thresholds",
                |m: &ProfileGuidedOptimization| { &m.adaptive_thresholds },
                |m: &mut ProfileGuidedOptimization| { &mut m.adaptive_thresholds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "feedback_loops",
                |m: &ProfileGuidedOptimization| { &m.feedback_loops },
                |m: &mut ProfileGuidedOptimization| { &mut m.feedback_loops },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProfileGuidedOptimization>(
                "DynamicOptimizationSystem.ProfileGuidedOptimization",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProfileGuidedOptimization {
        const NAME: &'static str = "ProfileGuidedOptimization";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.strategy = is.read_enum_or_unknown()?;
                    },
                    18 => {
                        self.profile_data.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                21 => value = is.read_float()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.optimization_weights.insert(key, value);
                    },
                    32 => {
                        self.adaptive_thresholds = is.read_bool()?;
                    },
                    42 => {
                        self.feedback_loops.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.strategy != ::protobuf::EnumOrUnknown::new(profile_guided_optimization::OptimizationStrategy::CONSERVATIVE) {
                my_size += ::protobuf::rt::int32_size(1, self.strategy.value());
            }
            for value in &self.profile_data {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.optimization_weights {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 4;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.adaptive_thresholds != false {
                my_size += 1 + 1;
            }
            for value in &self.feedback_loops {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.strategy != ::protobuf::EnumOrUnknown::new(profile_guided_optimization::OptimizationStrategy::CONSERVATIVE) {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.strategy))?;
            }
            for v in &self.profile_data {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.optimization_weights {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 4;
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_float(2, *v)?;
            };
            if self.adaptive_thresholds != false {
                os.write_bool(4, self.adaptive_thresholds)?;
            }
            for v in &self.feedback_loops {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProfileGuidedOptimization {
            ProfileGuidedOptimization::new()
        }

        fn clear(&mut self) {
            self.strategy = ::protobuf::EnumOrUnknown::new(profile_guided_optimization::OptimizationStrategy::CONSERVATIVE);
            self.profile_data.clear();
            self.optimization_weights.clear();
            self.adaptive_thresholds = false;
            self.feedback_loops.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProfileGuidedOptimization {
            static instance: ::protobuf::rt::Lazy<ProfileGuidedOptimization> = ::protobuf::rt::Lazy::new();
            instance.get(ProfileGuidedOptimization::new)
        }
    }

    impl ::protobuf::MessageFull for ProfileGuidedOptimization {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DynamicOptimizationSystem.ProfileGuidedOptimization").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProfileGuidedOptimization {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProfileGuidedOptimization {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ProfileGuidedOptimization`
    pub mod profile_guided_optimization {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy)
        pub enum OptimizationStrategy {
            // @@protoc_insertion_point(enum_value:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy.CONSERVATIVE)
            CONSERVATIVE = 0,
            // @@protoc_insertion_point(enum_value:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy.BALANCED)
            BALANCED = 1,
            // @@protoc_insertion_point(enum_value:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy.AGGRESSIVE)
            AGGRESSIVE = 2,
            // @@protoc_insertion_point(enum_value:kymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy.EXPERIMENTAL)
            EXPERIMENTAL = 3,
        }

        impl ::protobuf::Enum for OptimizationStrategy {
            const NAME: &'static str = "OptimizationStrategy";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<OptimizationStrategy> {
                match value {
                    0 => ::std::option::Option::Some(OptimizationStrategy::CONSERVATIVE),
                    1 => ::std::option::Option::Some(OptimizationStrategy::BALANCED),
                    2 => ::std::option::Option::Some(OptimizationStrategy::AGGRESSIVE),
                    3 => ::std::option::Option::Some(OptimizationStrategy::EXPERIMENTAL),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<OptimizationStrategy> {
                match str {
                    "CONSERVATIVE" => ::std::option::Option::Some(OptimizationStrategy::CONSERVATIVE),
                    "BALANCED" => ::std::option::Option::Some(OptimizationStrategy::BALANCED),
                    "AGGRESSIVE" => ::std::option::Option::Some(OptimizationStrategy::AGGRESSIVE),
                    "EXPERIMENTAL" => ::std::option::Option::Some(OptimizationStrategy::EXPERIMENTAL),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [OptimizationStrategy] = &[
                OptimizationStrategy::CONSERVATIVE,
                OptimizationStrategy::BALANCED,
                OptimizationStrategy::AGGRESSIVE,
                OptimizationStrategy::EXPERIMENTAL,
            ];
        }

        impl ::protobuf::EnumFull for OptimizationStrategy {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for OptimizationStrategy {
            fn default() -> Self {
                OptimizationStrategy::CONSERVATIVE
            }
        }

        impl OptimizationStrategy {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<OptimizationStrategy>("DynamicOptimizationSystem.ProfileGuidedOptimization.OptimizationStrategy")
            }
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.DynamicOptimizationSystem.AutoTuning)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutoTuning {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutoTuning {
        fn default() -> &'a AutoTuning {
            <AutoTuning as ::protobuf::Message>::default_instance()
        }
    }

    impl AutoTuning {
        pub fn new() -> AutoTuning {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutoTuning>(
                "DynamicOptimizationSystem.AutoTuning",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AutoTuning {
        const NAME: &'static str = "AutoTuning";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutoTuning {
            AutoTuning::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutoTuning {
            static instance: AutoTuning = AutoTuning {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AutoTuning {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DynamicOptimizationSystem.AutoTuning").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AutoTuning {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutoTuning {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AutoTuning`
    pub mod auto_tuning {
        // @@protoc_insertion_point(message:kymera_mappings.DynamicOptimizationSystem.AutoTuning.PerformanceModeling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PerformanceModeling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.PerformanceModeling.performance_metrics)
            pub performance_metrics: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.PerformanceModeling.cost_models)
            pub cost_models: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.PerformanceModeling.online_learning)
            pub online_learning: bool,
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.PerformanceModeling.adaptation_rules)
            pub adaptation_rules: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.PerformanceModeling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PerformanceModeling {
            fn default() -> &'a PerformanceModeling {
                <PerformanceModeling as ::protobuf::Message>::default_instance()
            }
        }

        impl PerformanceModeling {
            pub fn new() -> PerformanceModeling {
                ::std::default::Default::default()
            }

            // repeated string performance_metrics = 1;

            pub fn performance_metrics(&self) -> &[::std::string::String] {
                &self.performance_metrics
            }

            pub fn clear_performance_metrics(&mut self) {
                self.performance_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_performance_metrics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.performance_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_performance_metrics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.performance_metrics
            }

            // Take field
            pub fn take_performance_metrics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.performance_metrics, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.DynamicOptimizationSystem.AutoTuning.PerformanceModeling.CostModelsEntry cost_models = 2;

            pub fn cost_models(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.cost_models
            }

            pub fn clear_cost_models(&mut self) {
                self.cost_models.clear();
            }

            // Param is passed by value, moved
            pub fn set_cost_models(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.cost_models = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cost_models(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.cost_models
            }

            // Take field
            pub fn take_cost_models(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.cost_models, ::std::collections::HashMap::new())
            }

            // bool online_learning = 3;

            pub fn online_learning(&self) -> bool {
                self.online_learning
            }

            pub fn clear_online_learning(&mut self) {
                self.online_learning = false;
            }

            // Param is passed by value, moved
            pub fn set_online_learning(&mut self, v: bool) {
                self.online_learning = v;
            }

            // repeated string adaptation_rules = 4;

            pub fn adaptation_rules(&self) -> &[::std::string::String] {
                &self.adaptation_rules
            }

            pub fn clear_adaptation_rules(&mut self) {
                self.adaptation_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_adaptation_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.adaptation_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_adaptation_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.adaptation_rules
            }

            // Take field
            pub fn take_adaptation_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.adaptation_rules, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "performance_metrics",
                    |m: &PerformanceModeling| { &m.performance_metrics },
                    |m: &mut PerformanceModeling| { &mut m.performance_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "cost_models",
                    |m: &PerformanceModeling| { &m.cost_models },
                    |m: &mut PerformanceModeling| { &mut m.cost_models },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "online_learning",
                    |m: &PerformanceModeling| { &m.online_learning },
                    |m: &mut PerformanceModeling| { &mut m.online_learning },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "adaptation_rules",
                    |m: &PerformanceModeling| { &m.adaptation_rules },
                    |m: &mut PerformanceModeling| { &mut m.adaptation_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceModeling>(
                    "DynamicOptimizationSystem.AutoTuning.PerformanceModeling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PerformanceModeling {
            const NAME: &'static str = "PerformanceModeling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.performance_metrics.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.cost_models.insert(key, value);
                        },
                        24 => {
                            self.online_learning = is.read_bool()?;
                        },
                        34 => {
                            self.adaptation_rules.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.performance_metrics {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.cost_models {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.online_learning != false {
                    my_size += 1 + 1;
                }
                for value in &self.adaptation_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.performance_metrics {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.cost_models {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.online_learning != false {
                    os.write_bool(3, self.online_learning)?;
                }
                for v in &self.adaptation_rules {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PerformanceModeling {
                PerformanceModeling::new()
            }

            fn clear(&mut self) {
                self.performance_metrics.clear();
                self.cost_models.clear();
                self.online_learning = false;
                self.adaptation_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PerformanceModeling {
                static instance: ::protobuf::rt::Lazy<PerformanceModeling> = ::protobuf::rt::Lazy::new();
                instance.get(PerformanceModeling::new)
            }
        }

        impl ::protobuf::MessageFull for PerformanceModeling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("DynamicOptimizationSystem.AutoTuning.PerformanceModeling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PerformanceModeling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PerformanceModeling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.DynamicOptimizationSystem.AutoTuning.ConfigurationSpace)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ConfigurationSpace {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.ConfigurationSpace.tunable_parameters)
            pub tunable_parameters: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.ConfigurationSpace.parameter_constraints)
            pub parameter_constraints: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.ConfigurationSpace.multi_objective)
            pub multi_objective: bool,
            // @@protoc_insertion_point(field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.ConfigurationSpace.search_strategies)
            pub search_strategies: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.DynamicOptimizationSystem.AutoTuning.ConfigurationSpace.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ConfigurationSpace {
            fn default() -> &'a ConfigurationSpace {
                <ConfigurationSpace as ::protobuf::Message>::default_instance()
            }
        }

        impl ConfigurationSpace {
            pub fn new() -> ConfigurationSpace {
                ::std::default::Default::default()
            }

            // repeated string tunable_parameters = 1;

            pub fn tunable_parameters(&self) -> &[::std::string::String] {
                &self.tunable_parameters
            }

            pub fn clear_tunable_parameters(&mut self) {
                self.tunable_parameters.clear();
            }

            // Param is passed by value, moved
            pub fn set_tunable_parameters(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.tunable_parameters = v;
            }

            // Mutable pointer to the field.
            pub fn mut_tunable_parameters(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.tunable_parameters
            }

            // Take field
            pub fn take_tunable_parameters(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.tunable_parameters, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.DynamicOptimizationSystem.AutoTuning.ConfigurationSpace.ParameterConstraintsEntry parameter_constraints = 2;

            pub fn parameter_constraints(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.parameter_constraints
            }

            pub fn clear_parameter_constraints(&mut self) {
                self.parameter_constraints.clear();
            }

            // Param is passed by value, moved
            pub fn set_parameter_constraints(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.parameter_constraints = v;
            }

            // Mutable pointer to the field.
            pub fn mut_parameter_constraints(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.parameter_constraints
            }

            // Take field
            pub fn take_parameter_constraints(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.parameter_constraints, ::std::collections::HashMap::new())
            }

            // bool multi_objective = 3;

            pub fn multi_objective(&self) -> bool {
                self.multi_objective
            }

            pub fn clear_multi_objective(&mut self) {
                self.multi_objective = false;
            }

            // Param is passed by value, moved
            pub fn set_multi_objective(&mut self, v: bool) {
                self.multi_objective = v;
            }

            // repeated string search_strategies = 4;

            pub fn search_strategies(&self) -> &[::std::string::String] {
                &self.search_strategies
            }

            pub fn clear_search_strategies(&mut self) {
                self.search_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_search_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.search_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_search_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.search_strategies
            }

            // Take field
            pub fn take_search_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.search_strategies, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "tunable_parameters",
                    |m: &ConfigurationSpace| { &m.tunable_parameters },
                    |m: &mut ConfigurationSpace| { &mut m.tunable_parameters },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "parameter_constraints",
                    |m: &ConfigurationSpace| { &m.parameter_constraints },
                    |m: &mut ConfigurationSpace| { &mut m.parameter_constraints },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "multi_objective",
                    |m: &ConfigurationSpace| { &m.multi_objective },
                    |m: &mut ConfigurationSpace| { &mut m.multi_objective },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "search_strategies",
                    |m: &ConfigurationSpace| { &m.search_strategies },
                    |m: &mut ConfigurationSpace| { &mut m.search_strategies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConfigurationSpace>(
                    "DynamicOptimizationSystem.AutoTuning.ConfigurationSpace",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ConfigurationSpace {
            const NAME: &'static str = "ConfigurationSpace";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.tunable_parameters.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.parameter_constraints.insert(key, value);
                        },
                        24 => {
                            self.multi_objective = is.read_bool()?;
                        },
                        34 => {
                            self.search_strategies.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.tunable_parameters {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.parameter_constraints {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.multi_objective != false {
                    my_size += 1 + 1;
                }
                for value in &self.search_strategies {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.tunable_parameters {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.parameter_constraints {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.multi_objective != false {
                    os.write_bool(3, self.multi_objective)?;
                }
                for v in &self.search_strategies {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ConfigurationSpace {
                ConfigurationSpace::new()
            }

            fn clear(&mut self) {
                self.tunable_parameters.clear();
                self.parameter_constraints.clear();
                self.multi_objective = false;
                self.search_strategies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ConfigurationSpace {
                static instance: ::protobuf::rt::Lazy<ConfigurationSpace> = ::protobuf::rt::Lazy::new();
                instance.get(ConfigurationSpace::new)
            }
        }

        impl ::protobuf::MessageFull for ConfigurationSpace {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("DynamicOptimizationSystem.AutoTuning.ConfigurationSpace").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ConfigurationSpace {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ConfigurationSpace {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.VerificationSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VerificationSystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.VerificationSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VerificationSystem {
    fn default() -> &'a VerificationSystem {
        <VerificationSystem as ::protobuf::Message>::default_instance()
    }
}

impl VerificationSystem {
    pub fn new() -> VerificationSystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VerificationSystem>(
            "VerificationSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VerificationSystem {
    const NAME: &'static str = "VerificationSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VerificationSystem {
        VerificationSystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VerificationSystem {
        static instance: VerificationSystem = VerificationSystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VerificationSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VerificationSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VerificationSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerificationSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VerificationSystem`
pub mod verification_system {
    // @@protoc_insertion_point(message:kymera_mappings.VerificationSystem.StaticAnalysis)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StaticAnalysis {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.VerificationSystem.StaticAnalysis.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StaticAnalysis {
        fn default() -> &'a StaticAnalysis {
            <StaticAnalysis as ::protobuf::Message>::default_instance()
        }
    }

    impl StaticAnalysis {
        pub fn new() -> StaticAnalysis {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StaticAnalysis>(
                "VerificationSystem.StaticAnalysis",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StaticAnalysis {
        const NAME: &'static str = "StaticAnalysis";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StaticAnalysis {
            StaticAnalysis::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StaticAnalysis {
            static instance: StaticAnalysis = StaticAnalysis {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StaticAnalysis {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("VerificationSystem.StaticAnalysis").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StaticAnalysis {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StaticAnalysis {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `StaticAnalysis`
    pub mod static_analysis {
        // @@protoc_insertion_point(message:kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TypeChecking {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking.type_rules)
            pub type_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking.inference_algorithms)
            pub inference_algorithms: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking.gradual_typing)
            pub gradual_typing: bool,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking.constraint_solving)
            pub constraint_solving: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TypeChecking {
            fn default() -> &'a TypeChecking {
                <TypeChecking as ::protobuf::Message>::default_instance()
            }
        }

        impl TypeChecking {
            pub fn new() -> TypeChecking {
                ::std::default::Default::default()
            }

            // repeated string type_rules = 1;

            pub fn type_rules(&self) -> &[::std::string::String] {
                &self.type_rules
            }

            pub fn clear_type_rules(&mut self) {
                self.type_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.type_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.type_rules
            }

            // Take field
            pub fn take_type_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.type_rules, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking.InferenceAlgorithmsEntry inference_algorithms = 2;

            pub fn inference_algorithms(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.inference_algorithms
            }

            pub fn clear_inference_algorithms(&mut self) {
                self.inference_algorithms.clear();
            }

            // Param is passed by value, moved
            pub fn set_inference_algorithms(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.inference_algorithms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_inference_algorithms(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.inference_algorithms
            }

            // Take field
            pub fn take_inference_algorithms(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.inference_algorithms, ::std::collections::HashMap::new())
            }

            // bool gradual_typing = 3;

            pub fn gradual_typing(&self) -> bool {
                self.gradual_typing
            }

            pub fn clear_gradual_typing(&mut self) {
                self.gradual_typing = false;
            }

            // Param is passed by value, moved
            pub fn set_gradual_typing(&mut self, v: bool) {
                self.gradual_typing = v;
            }

            // repeated string constraint_solving = 4;

            pub fn constraint_solving(&self) -> &[::std::string::String] {
                &self.constraint_solving
            }

            pub fn clear_constraint_solving(&mut self) {
                self.constraint_solving.clear();
            }

            // Param is passed by value, moved
            pub fn set_constraint_solving(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.constraint_solving = v;
            }

            // Mutable pointer to the field.
            pub fn mut_constraint_solving(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.constraint_solving
            }

            // Take field
            pub fn take_constraint_solving(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.constraint_solving, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "type_rules",
                    |m: &TypeChecking| { &m.type_rules },
                    |m: &mut TypeChecking| { &mut m.type_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "inference_algorithms",
                    |m: &TypeChecking| { &m.inference_algorithms },
                    |m: &mut TypeChecking| { &mut m.inference_algorithms },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "gradual_typing",
                    |m: &TypeChecking| { &m.gradual_typing },
                    |m: &mut TypeChecking| { &mut m.gradual_typing },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "constraint_solving",
                    |m: &TypeChecking| { &m.constraint_solving },
                    |m: &mut TypeChecking| { &mut m.constraint_solving },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeChecking>(
                    "VerificationSystem.StaticAnalysis.TypeChecking",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TypeChecking {
            const NAME: &'static str = "TypeChecking";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.type_rules.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.inference_algorithms.insert(key, value);
                        },
                        24 => {
                            self.gradual_typing = is.read_bool()?;
                        },
                        34 => {
                            self.constraint_solving.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.type_rules {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.inference_algorithms {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.gradual_typing != false {
                    my_size += 1 + 1;
                }
                for value in &self.constraint_solving {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.type_rules {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.inference_algorithms {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.gradual_typing != false {
                    os.write_bool(3, self.gradual_typing)?;
                }
                for v in &self.constraint_solving {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TypeChecking {
                TypeChecking::new()
            }

            fn clear(&mut self) {
                self.type_rules.clear();
                self.inference_algorithms.clear();
                self.gradual_typing = false;
                self.constraint_solving.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TypeChecking {
                static instance: ::protobuf::rt::Lazy<TypeChecking> = ::protobuf::rt::Lazy::new();
                instance.get(TypeChecking::new)
            }
        }

        impl ::protobuf::MessageFull for TypeChecking {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("VerificationSystem.StaticAnalysis.TypeChecking").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TypeChecking {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TypeChecking {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.VerificationSystem.StaticAnalysis.DataFlowAnalysis)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DataFlowAnalysis {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.DataFlowAnalysis.analysis_passes)
            pub analysis_passes: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.DataFlowAnalysis.flow_equations)
            pub flow_equations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.DataFlowAnalysis.interprocedural)
            pub interprocedural: bool,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.StaticAnalysis.DataFlowAnalysis.alias_analysis)
            pub alias_analysis: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.VerificationSystem.StaticAnalysis.DataFlowAnalysis.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DataFlowAnalysis {
            fn default() -> &'a DataFlowAnalysis {
                <DataFlowAnalysis as ::protobuf::Message>::default_instance()
            }
        }

        impl DataFlowAnalysis {
            pub fn new() -> DataFlowAnalysis {
                ::std::default::Default::default()
            }

            // repeated string analysis_passes = 1;

            pub fn analysis_passes(&self) -> &[::std::string::String] {
                &self.analysis_passes
            }

            pub fn clear_analysis_passes(&mut self) {
                self.analysis_passes.clear();
            }

            // Param is passed by value, moved
            pub fn set_analysis_passes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.analysis_passes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_analysis_passes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.analysis_passes
            }

            // Take field
            pub fn take_analysis_passes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.analysis_passes, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.VerificationSystem.StaticAnalysis.DataFlowAnalysis.FlowEquationsEntry flow_equations = 2;

            pub fn flow_equations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.flow_equations
            }

            pub fn clear_flow_equations(&mut self) {
                self.flow_equations.clear();
            }

            // Param is passed by value, moved
            pub fn set_flow_equations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.flow_equations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_flow_equations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.flow_equations
            }

            // Take field
            pub fn take_flow_equations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.flow_equations, ::std::collections::HashMap::new())
            }

            // bool interprocedural = 3;

            pub fn interprocedural(&self) -> bool {
                self.interprocedural
            }

            pub fn clear_interprocedural(&mut self) {
                self.interprocedural = false;
            }

            // Param is passed by value, moved
            pub fn set_interprocedural(&mut self, v: bool) {
                self.interprocedural = v;
            }

            // repeated string alias_analysis = 4;

            pub fn alias_analysis(&self) -> &[::std::string::String] {
                &self.alias_analysis
            }

            pub fn clear_alias_analysis(&mut self) {
                self.alias_analysis.clear();
            }

            // Param is passed by value, moved
            pub fn set_alias_analysis(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.alias_analysis = v;
            }

            // Mutable pointer to the field.
            pub fn mut_alias_analysis(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.alias_analysis
            }

            // Take field
            pub fn take_alias_analysis(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.alias_analysis, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "analysis_passes",
                    |m: &DataFlowAnalysis| { &m.analysis_passes },
                    |m: &mut DataFlowAnalysis| { &mut m.analysis_passes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "flow_equations",
                    |m: &DataFlowAnalysis| { &m.flow_equations },
                    |m: &mut DataFlowAnalysis| { &mut m.flow_equations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "interprocedural",
                    |m: &DataFlowAnalysis| { &m.interprocedural },
                    |m: &mut DataFlowAnalysis| { &mut m.interprocedural },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "alias_analysis",
                    |m: &DataFlowAnalysis| { &m.alias_analysis },
                    |m: &mut DataFlowAnalysis| { &mut m.alias_analysis },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataFlowAnalysis>(
                    "VerificationSystem.StaticAnalysis.DataFlowAnalysis",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DataFlowAnalysis {
            const NAME: &'static str = "DataFlowAnalysis";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.analysis_passes.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.flow_equations.insert(key, value);
                        },
                        24 => {
                            self.interprocedural = is.read_bool()?;
                        },
                        34 => {
                            self.alias_analysis.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.analysis_passes {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.flow_equations {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.interprocedural != false {
                    my_size += 1 + 1;
                }
                for value in &self.alias_analysis {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.analysis_passes {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.flow_equations {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.interprocedural != false {
                    os.write_bool(3, self.interprocedural)?;
                }
                for v in &self.alias_analysis {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DataFlowAnalysis {
                DataFlowAnalysis::new()
            }

            fn clear(&mut self) {
                self.analysis_passes.clear();
                self.flow_equations.clear();
                self.interprocedural = false;
                self.alias_analysis.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DataFlowAnalysis {
                static instance: ::protobuf::rt::Lazy<DataFlowAnalysis> = ::protobuf::rt::Lazy::new();
                instance.get(DataFlowAnalysis::new)
            }
        }

        impl ::protobuf::MessageFull for DataFlowAnalysis {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("VerificationSystem.StaticAnalysis.DataFlowAnalysis").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DataFlowAnalysis {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DataFlowAnalysis {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.VerificationSystem.DynamicAnalysis)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DynamicAnalysis {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.VerificationSystem.DynamicAnalysis.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DynamicAnalysis {
        fn default() -> &'a DynamicAnalysis {
            <DynamicAnalysis as ::protobuf::Message>::default_instance()
        }
    }

    impl DynamicAnalysis {
        pub fn new() -> DynamicAnalysis {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DynamicAnalysis>(
                "VerificationSystem.DynamicAnalysis",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DynamicAnalysis {
        const NAME: &'static str = "DynamicAnalysis";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DynamicAnalysis {
            DynamicAnalysis::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DynamicAnalysis {
            static instance: DynamicAnalysis = DynamicAnalysis {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DynamicAnalysis {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("VerificationSystem.DynamicAnalysis").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DynamicAnalysis {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DynamicAnalysis {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `DynamicAnalysis`
    pub mod dynamic_analysis {
        // @@protoc_insertion_point(message:kymera_mappings.VerificationSystem.DynamicAnalysis.RuntimeVerification)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RuntimeVerification {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.RuntimeVerification.monitoring_points)
            pub monitoring_points: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.RuntimeVerification.verification_conditions)
            pub verification_conditions: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.RuntimeVerification.online_checking)
            pub online_checking: bool,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.RuntimeVerification.recovery_actions)
            pub recovery_actions: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.VerificationSystem.DynamicAnalysis.RuntimeVerification.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RuntimeVerification {
            fn default() -> &'a RuntimeVerification {
                <RuntimeVerification as ::protobuf::Message>::default_instance()
            }
        }

        impl RuntimeVerification {
            pub fn new() -> RuntimeVerification {
                ::std::default::Default::default()
            }

            // repeated string monitoring_points = 1;

            pub fn monitoring_points(&self) -> &[::std::string::String] {
                &self.monitoring_points
            }

            pub fn clear_monitoring_points(&mut self) {
                self.monitoring_points.clear();
            }

            // Param is passed by value, moved
            pub fn set_monitoring_points(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.monitoring_points = v;
            }

            // Mutable pointer to the field.
            pub fn mut_monitoring_points(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.monitoring_points
            }

            // Take field
            pub fn take_monitoring_points(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.monitoring_points, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.VerificationSystem.DynamicAnalysis.RuntimeVerification.VerificationConditionsEntry verification_conditions = 2;

            pub fn verification_conditions(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.verification_conditions
            }

            pub fn clear_verification_conditions(&mut self) {
                self.verification_conditions.clear();
            }

            // Param is passed by value, moved
            pub fn set_verification_conditions(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.verification_conditions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_verification_conditions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.verification_conditions
            }

            // Take field
            pub fn take_verification_conditions(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.verification_conditions, ::std::collections::HashMap::new())
            }

            // bool online_checking = 3;

            pub fn online_checking(&self) -> bool {
                self.online_checking
            }

            pub fn clear_online_checking(&mut self) {
                self.online_checking = false;
            }

            // Param is passed by value, moved
            pub fn set_online_checking(&mut self, v: bool) {
                self.online_checking = v;
            }

            // repeated string recovery_actions = 4;

            pub fn recovery_actions(&self) -> &[::std::string::String] {
                &self.recovery_actions
            }

            pub fn clear_recovery_actions(&mut self) {
                self.recovery_actions.clear();
            }

            // Param is passed by value, moved
            pub fn set_recovery_actions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.recovery_actions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_recovery_actions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.recovery_actions
            }

            // Take field
            pub fn take_recovery_actions(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.recovery_actions, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "monitoring_points",
                    |m: &RuntimeVerification| { &m.monitoring_points },
                    |m: &mut RuntimeVerification| { &mut m.monitoring_points },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "verification_conditions",
                    |m: &RuntimeVerification| { &m.verification_conditions },
                    |m: &mut RuntimeVerification| { &mut m.verification_conditions },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "online_checking",
                    |m: &RuntimeVerification| { &m.online_checking },
                    |m: &mut RuntimeVerification| { &mut m.online_checking },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "recovery_actions",
                    |m: &RuntimeVerification| { &m.recovery_actions },
                    |m: &mut RuntimeVerification| { &mut m.recovery_actions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeVerification>(
                    "VerificationSystem.DynamicAnalysis.RuntimeVerification",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RuntimeVerification {
            const NAME: &'static str = "RuntimeVerification";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.monitoring_points.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.verification_conditions.insert(key, value);
                        },
                        24 => {
                            self.online_checking = is.read_bool()?;
                        },
                        34 => {
                            self.recovery_actions.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.monitoring_points {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.verification_conditions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.online_checking != false {
                    my_size += 1 + 1;
                }
                for value in &self.recovery_actions {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.monitoring_points {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.verification_conditions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.online_checking != false {
                    os.write_bool(3, self.online_checking)?;
                }
                for v in &self.recovery_actions {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RuntimeVerification {
                RuntimeVerification::new()
            }

            fn clear(&mut self) {
                self.monitoring_points.clear();
                self.verification_conditions.clear();
                self.online_checking = false;
                self.recovery_actions.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RuntimeVerification {
                static instance: ::protobuf::rt::Lazy<RuntimeVerification> = ::protobuf::rt::Lazy::new();
                instance.get(RuntimeVerification::new)
            }
        }

        impl ::protobuf::MessageFull for RuntimeVerification {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("VerificationSystem.DynamicAnalysis.RuntimeVerification").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RuntimeVerification {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RuntimeVerification {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ConcurrencyAnalysis {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis.thread_safety)
            pub thread_safety: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis.deadlock_detection)
            pub deadlock_detection: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis.race_detection)
            pub race_detection: bool,
            // @@protoc_insertion_point(field:kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis.atomicity_violation)
            pub atomicity_violation: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ConcurrencyAnalysis {
            fn default() -> &'a ConcurrencyAnalysis {
                <ConcurrencyAnalysis as ::protobuf::Message>::default_instance()
            }
        }

        impl ConcurrencyAnalysis {
            pub fn new() -> ConcurrencyAnalysis {
                ::std::default::Default::default()
            }

            // repeated string thread_safety = 1;

            pub fn thread_safety(&self) -> &[::std::string::String] {
                &self.thread_safety
            }

            pub fn clear_thread_safety(&mut self) {
                self.thread_safety.clear();
            }

            // Param is passed by value, moved
            pub fn set_thread_safety(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.thread_safety = v;
            }

            // Mutable pointer to the field.
            pub fn mut_thread_safety(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.thread_safety
            }

            // Take field
            pub fn take_thread_safety(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.thread_safety, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis.DeadlockDetectionEntry deadlock_detection = 2;

            pub fn deadlock_detection(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.deadlock_detection
            }

            pub fn clear_deadlock_detection(&mut self) {
                self.deadlock_detection.clear();
            }

            // Param is passed by value, moved
            pub fn set_deadlock_detection(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.deadlock_detection = v;
            }

            // Mutable pointer to the field.
            pub fn mut_deadlock_detection(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.deadlock_detection
            }

            // Take field
            pub fn take_deadlock_detection(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.deadlock_detection, ::std::collections::HashMap::new())
            }

            // bool race_detection = 3;

            pub fn race_detection(&self) -> bool {
                self.race_detection
            }

            pub fn clear_race_detection(&mut self) {
                self.race_detection = false;
            }

            // Param is passed by value, moved
            pub fn set_race_detection(&mut self, v: bool) {
                self.race_detection = v;
            }

            // repeated string atomicity_violation = 4;

            pub fn atomicity_violation(&self) -> &[::std::string::String] {
                &self.atomicity_violation
            }

            pub fn clear_atomicity_violation(&mut self) {
                self.atomicity_violation.clear();
            }

            // Param is passed by value, moved
            pub fn set_atomicity_violation(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.atomicity_violation = v;
            }

            // Mutable pointer to the field.
            pub fn mut_atomicity_violation(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.atomicity_violation
            }

            // Take field
            pub fn take_atomicity_violation(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.atomicity_violation, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "thread_safety",
                    |m: &ConcurrencyAnalysis| { &m.thread_safety },
                    |m: &mut ConcurrencyAnalysis| { &mut m.thread_safety },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "deadlock_detection",
                    |m: &ConcurrencyAnalysis| { &m.deadlock_detection },
                    |m: &mut ConcurrencyAnalysis| { &mut m.deadlock_detection },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "race_detection",
                    |m: &ConcurrencyAnalysis| { &m.race_detection },
                    |m: &mut ConcurrencyAnalysis| { &mut m.race_detection },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "atomicity_violation",
                    |m: &ConcurrencyAnalysis| { &m.atomicity_violation },
                    |m: &mut ConcurrencyAnalysis| { &mut m.atomicity_violation },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConcurrencyAnalysis>(
                    "VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ConcurrencyAnalysis {
            const NAME: &'static str = "ConcurrencyAnalysis";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.thread_safety.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.deadlock_detection.insert(key, value);
                        },
                        24 => {
                            self.race_detection = is.read_bool()?;
                        },
                        34 => {
                            self.atomicity_violation.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.thread_safety {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.deadlock_detection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.race_detection != false {
                    my_size += 1 + 1;
                }
                for value in &self.atomicity_violation {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.thread_safety {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.deadlock_detection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.race_detection != false {
                    os.write_bool(3, self.race_detection)?;
                }
                for v in &self.atomicity_violation {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ConcurrencyAnalysis {
                ConcurrencyAnalysis::new()
            }

            fn clear(&mut self) {
                self.thread_safety.clear();
                self.deadlock_detection.clear();
                self.race_detection = false;
                self.atomicity_violation.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ConcurrencyAnalysis {
                static instance: ::protobuf::rt::Lazy<ConcurrencyAnalysis> = ::protobuf::rt::Lazy::new();
                instance.get(ConcurrencyAnalysis::new)
            }
        }

        impl ::protobuf::MessageFull for ConcurrencyAnalysis {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("VerificationSystem.DynamicAnalysis.ConcurrencyAnalysis").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ConcurrencyAnalysis {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ConcurrencyAnalysis {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.NumericTypeMapping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NumericTypeMapping {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.NumericTypeMapping.source_language)
    pub source_language: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.NumericTypeMapping.target_language)
    pub target_language: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.NumericTypeMapping.source_type)
    pub source_type: ::protobuf::EnumOrUnknown<NumericType>,
    // @@protoc_insertion_point(field:kymera_mappings.NumericTypeMapping.target_type)
    pub target_type: ::protobuf::EnumOrUnknown<NumericType>,
    // @@protoc_insertion_point(field:kymera_mappings.NumericTypeMapping.precision_loss_possible)
    pub precision_loss_possible: bool,
    // @@protoc_insertion_point(field:kymera_mappings.NumericTypeMapping.notes)
    pub notes: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.NumericTypeMapping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NumericTypeMapping {
    fn default() -> &'a NumericTypeMapping {
        <NumericTypeMapping as ::protobuf::Message>::default_instance()
    }
}

impl NumericTypeMapping {
    pub fn new() -> NumericTypeMapping {
        ::std::default::Default::default()
    }

    // string source_language = 1;

    pub fn source_language(&self) -> &str {
        &self.source_language
    }

    pub fn clear_source_language(&mut self) {
        self.source_language.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_language(&mut self, v: ::std::string::String) {
        self.source_language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_language(&mut self) -> &mut ::std::string::String {
        &mut self.source_language
    }

    // Take field
    pub fn take_source_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_language, ::std::string::String::new())
    }

    // string target_language = 2;

    pub fn target_language(&self) -> &str {
        &self.target_language
    }

    pub fn clear_target_language(&mut self) {
        self.target_language.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_language(&mut self, v: ::std::string::String) {
        self.target_language = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_language(&mut self) -> &mut ::std::string::String {
        &mut self.target_language
    }

    // Take field
    pub fn take_target_language(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_language, ::std::string::String::new())
    }

    // .kymera_mappings.NumericType source_type = 3;

    pub fn source_type(&self) -> NumericType {
        self.source_type.enum_value_or_default()
    }

    pub fn clear_source_type(&mut self) {
        self.source_type = ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN);
    }

    // Param is passed by value, moved
    pub fn set_source_type(&mut self, v: NumericType) {
        self.source_type = ::protobuf::EnumOrUnknown::new(v);
    }

    // .kymera_mappings.NumericType target_type = 4;

    pub fn target_type(&self) -> NumericType {
        self.target_type.enum_value_or_default()
    }

    pub fn clear_target_type(&mut self) {
        self.target_type = ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN);
    }

    // Param is passed by value, moved
    pub fn set_target_type(&mut self, v: NumericType) {
        self.target_type = ::protobuf::EnumOrUnknown::new(v);
    }

    // bool precision_loss_possible = 5;

    pub fn precision_loss_possible(&self) -> bool {
        self.precision_loss_possible
    }

    pub fn clear_precision_loss_possible(&mut self) {
        self.precision_loss_possible = false;
    }

    // Param is passed by value, moved
    pub fn set_precision_loss_possible(&mut self, v: bool) {
        self.precision_loss_possible = v;
    }

    // string notes = 6;

    pub fn notes(&self) -> &str {
        &self.notes
    }

    pub fn clear_notes(&mut self) {
        self.notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_notes(&mut self, v: ::std::string::String) {
        self.notes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notes(&mut self) -> &mut ::std::string::String {
        &mut self.notes
    }

    // Take field
    pub fn take_notes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.notes, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_language",
            |m: &NumericTypeMapping| { &m.source_language },
            |m: &mut NumericTypeMapping| { &mut m.source_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_language",
            |m: &NumericTypeMapping| { &m.target_language },
            |m: &mut NumericTypeMapping| { &mut m.target_language },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_type",
            |m: &NumericTypeMapping| { &m.source_type },
            |m: &mut NumericTypeMapping| { &mut m.source_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_type",
            |m: &NumericTypeMapping| { &m.target_type },
            |m: &mut NumericTypeMapping| { &mut m.target_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "precision_loss_possible",
            |m: &NumericTypeMapping| { &m.precision_loss_possible },
            |m: &mut NumericTypeMapping| { &mut m.precision_loss_possible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "notes",
            |m: &NumericTypeMapping| { &m.notes },
            |m: &mut NumericTypeMapping| { &mut m.notes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumericTypeMapping>(
            "NumericTypeMapping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NumericTypeMapping {
    const NAME: &'static str = "NumericTypeMapping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source_language = is.read_string()?;
                },
                18 => {
                    self.target_language = is.read_string()?;
                },
                24 => {
                    self.source_type = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.target_type = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.precision_loss_possible = is.read_bool()?;
                },
                50 => {
                    self.notes = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.source_language.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.source_language);
        }
        if !self.target_language.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.target_language);
        }
        if self.source_type != ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(3, self.source_type.value());
        }
        if self.target_type != ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.target_type.value());
        }
        if self.precision_loss_possible != false {
            my_size += 1 + 1;
        }
        if !self.notes.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.notes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.source_language.is_empty() {
            os.write_string(1, &self.source_language)?;
        }
        if !self.target_language.is_empty() {
            os.write_string(2, &self.target_language)?;
        }
        if self.source_type != ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.source_type))?;
        }
        if self.target_type != ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.target_type))?;
        }
        if self.precision_loss_possible != false {
            os.write_bool(5, self.precision_loss_possible)?;
        }
        if !self.notes.is_empty() {
            os.write_string(6, &self.notes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NumericTypeMapping {
        NumericTypeMapping::new()
    }

    fn clear(&mut self) {
        self.source_language.clear();
        self.target_language.clear();
        self.source_type = ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN);
        self.target_type = ::protobuf::EnumOrUnknown::new(NumericType::NUMERIC_UNKNOWN);
        self.precision_loss_possible = false;
        self.notes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NumericTypeMapping {
        static instance: NumericTypeMapping = NumericTypeMapping {
            source_language: ::std::string::String::new(),
            target_language: ::std::string::String::new(),
            source_type: ::protobuf::EnumOrUnknown::from_i32(0),
            target_type: ::protobuf::EnumOrUnknown::from_i32(0),
            precision_loss_possible: false,
            notes: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NumericTypeMapping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NumericTypeMapping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NumericTypeMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumericTypeMapping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:kymera_mappings.LanguageConstruct)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LanguageConstruct {
    // message oneof groups
    pub construct: ::std::option::Option<language_construct::Construct>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.LanguageConstruct.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LanguageConstruct {
    fn default() -> &'a LanguageConstruct {
        <LanguageConstruct as ::protobuf::Message>::default_instance()
    }
}

impl LanguageConstruct {
    pub fn new() -> LanguageConstruct {
        ::std::default::Default::default()
    }

    // .kymera_mappings.RustConstruct rust = 1;

    pub fn rust(&self) -> RustConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Rust(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => RustConstruct::RUST_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_rust(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_rust(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Rust(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rust(&mut self, v: RustConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Rust(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.PythonConstruct python = 2;

    pub fn python(&self) -> PythonConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Python(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => PythonConstruct::PYTHON_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_python(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_python(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Python(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_python(&mut self, v: PythonConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Python(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.JSConstruct javascript = 3;

    pub fn javascript(&self) -> JSConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Javascript(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => JSConstruct::JS_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_javascript(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_javascript(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Javascript(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_javascript(&mut self, v: JSConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Javascript(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.TSConstruct typescript = 4;

    pub fn typescript(&self) -> TSConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Typescript(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => TSConstruct::TS_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_typescript(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_typescript(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Typescript(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typescript(&mut self, v: TSConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Typescript(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.JavaConstruct java = 5;

    pub fn java(&self) -> JavaConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Java(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => JavaConstruct::JAVA_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_java(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_java(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Java(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_java(&mut self, v: JavaConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Java(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.GoConstruct go = 6;

    pub fn go(&self) -> GoConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Go(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => GoConstruct::GO_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_go(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_go(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Go(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_go(&mut self, v: GoConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Go(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.RubyConstruct ruby = 7;

    pub fn ruby(&self) -> RubyConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Ruby(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => RubyConstruct::RUBY_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_ruby(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_ruby(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Ruby(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ruby(&mut self, v: RubyConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Ruby(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.CPPConstruct cpp = 8;

    pub fn cpp(&self) -> CPPConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Cpp(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => CPPConstruct::CPP_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_cpp(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_cpp(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Cpp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cpp(&mut self, v: CPPConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Cpp(::protobuf::EnumOrUnknown::new(v)))
    }

    // .kymera_mappings.CSharpConstruct csharp = 9;

    pub fn csharp(&self) -> CSharpConstruct {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Csharp(v)) => ::protobuf::EnumOrUnknown::enum_value_or_default(&v),
            _ => CSharpConstruct::CSHARP_UNKNOWN_CONSTRUCT,
        }
    }

    pub fn clear_csharp(&mut self) {
        self.construct = ::std::option::Option::None;
    }

    pub fn has_csharp(&self) -> bool {
        match self.construct {
            ::std::option::Option::Some(language_construct::Construct::Csharp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_csharp(&mut self, v: CSharpConstruct) {
        self.construct = ::std::option::Option::Some(language_construct::Construct::Csharp(::protobuf::EnumOrUnknown::new(v)))
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "rust",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Rust(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<RustConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Rust(e));
            },
            RustConstruct::RUST_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "python",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Python(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<PythonConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Python(e));
            },
            PythonConstruct::PYTHON_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "javascript",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Javascript(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<JSConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Javascript(e));
            },
            JSConstruct::JS_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "typescript",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Typescript(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<TSConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Typescript(e));
            },
            TSConstruct::TS_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "java",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Java(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<JavaConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Java(e));
            },
            JavaConstruct::JAVA_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "go",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Go(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<GoConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Go(e));
            },
            GoConstruct::GO_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "ruby",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Ruby(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<RubyConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Ruby(e));
            },
            RubyConstruct::RUBY_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "cpp",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Cpp(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<CPPConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Cpp(e));
            },
            CPPConstruct::CPP_UNKNOWN_CONSTRUCT,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_enum_accessors::<_, _>(
            "csharp",
            |message: &LanguageConstruct| match &message.construct {
                ::std::option::Option::Some(language_construct::Construct::Csharp(e)) => ::std::option::Option::Some(*e),
                _ => ::std::option::Option::None,
            },
            |message: &mut LanguageConstruct, e: ::protobuf::EnumOrUnknown<CSharpConstruct>| {
                message.construct = ::std::option::Option::Some(language_construct::Construct::Csharp(e));
            },
            CSharpConstruct::CSHARP_UNKNOWN_CONSTRUCT,
        ));
        oneofs.push(language_construct::Construct::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanguageConstruct>(
            "LanguageConstruct",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LanguageConstruct {
    const NAME: &'static str = "LanguageConstruct";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Rust(is.read_enum_or_unknown()?));
                },
                16 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Python(is.read_enum_or_unknown()?));
                },
                24 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Javascript(is.read_enum_or_unknown()?));
                },
                32 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Typescript(is.read_enum_or_unknown()?));
                },
                40 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Java(is.read_enum_or_unknown()?));
                },
                48 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Go(is.read_enum_or_unknown()?));
                },
                56 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Ruby(is.read_enum_or_unknown()?));
                },
                64 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Cpp(is.read_enum_or_unknown()?));
                },
                72 => {
                    self.construct = ::std::option::Option::Some(language_construct::Construct::Csharp(is.read_enum_or_unknown()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.construct {
            match v {
                &language_construct::Construct::Rust(v) => {
                    my_size += ::protobuf::rt::int32_size(1, v.value());
                },
                &language_construct::Construct::Python(v) => {
                    my_size += ::protobuf::rt::int32_size(2, v.value());
                },
                &language_construct::Construct::Javascript(v) => {
                    my_size += ::protobuf::rt::int32_size(3, v.value());
                },
                &language_construct::Construct::Typescript(v) => {
                    my_size += ::protobuf::rt::int32_size(4, v.value());
                },
                &language_construct::Construct::Java(v) => {
                    my_size += ::protobuf::rt::int32_size(5, v.value());
                },
                &language_construct::Construct::Go(v) => {
                    my_size += ::protobuf::rt::int32_size(6, v.value());
                },
                &language_construct::Construct::Ruby(v) => {
                    my_size += ::protobuf::rt::int32_size(7, v.value());
                },
                &language_construct::Construct::Cpp(v) => {
                    my_size += ::protobuf::rt::int32_size(8, v.value());
                },
                &language_construct::Construct::Csharp(v) => {
                    my_size += ::protobuf::rt::int32_size(9, v.value());
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.construct {
            match v {
                &language_construct::Construct::Rust(v) => {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Python(v) => {
                    os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Javascript(v) => {
                    os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Typescript(v) => {
                    os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Java(v) => {
                    os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Go(v) => {
                    os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Ruby(v) => {
                    os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Cpp(v) => {
                    os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
                },
                &language_construct::Construct::Csharp(v) => {
                    os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LanguageConstruct {
        LanguageConstruct::new()
    }

    fn clear(&mut self) {
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.construct = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LanguageConstruct {
        static instance: LanguageConstruct = LanguageConstruct {
            construct: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LanguageConstruct {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LanguageConstruct").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LanguageConstruct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LanguageConstruct {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LanguageConstruct`
pub mod language_construct {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:kymera_mappings.LanguageConstruct.construct)
    pub enum Construct {
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.rust)
        Rust(::protobuf::EnumOrUnknown<super::RustConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.python)
        Python(::protobuf::EnumOrUnknown<super::PythonConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.javascript)
        Javascript(::protobuf::EnumOrUnknown<super::JSConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.typescript)
        Typescript(::protobuf::EnumOrUnknown<super::TSConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.java)
        Java(::protobuf::EnumOrUnknown<super::JavaConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.go)
        Go(::protobuf::EnumOrUnknown<super::GoConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.ruby)
        Ruby(::protobuf::EnumOrUnknown<super::RubyConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.cpp)
        Cpp(::protobuf::EnumOrUnknown<super::CPPConstruct>),
        // @@protoc_insertion_point(oneof_field:kymera_mappings.LanguageConstruct.csharp)
        Csharp(::protobuf::EnumOrUnknown<super::CSharpConstruct>),
    }

    impl ::protobuf::Oneof for Construct {
    }

    impl ::protobuf::OneofFull for Construct {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::LanguageConstruct as ::protobuf::MessageFull>::descriptor().oneof_by_name("construct").unwrap()).clone()
        }
    }

    impl Construct {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Construct>("construct")
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.LanguageMapping)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LanguageMapping {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.LanguageMapping.source_construct)
    pub source_construct: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.LanguageMapping.target_construct)
    pub target_construct: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.LanguageMapping.direct_mapping)
    pub direct_mapping: bool,
    // @@protoc_insertion_point(field:kymera_mappings.LanguageMapping.caveats)
    pub caveats: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.LanguageMapping.examples)
    pub examples: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.LanguageMapping.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LanguageMapping {
    fn default() -> &'a LanguageMapping {
        <LanguageMapping as ::protobuf::Message>::default_instance()
    }
}

impl LanguageMapping {
    pub fn new() -> LanguageMapping {
        ::std::default::Default::default()
    }

    // string source_construct = 1;

    pub fn source_construct(&self) -> &str {
        &self.source_construct
    }

    pub fn clear_source_construct(&mut self) {
        self.source_construct.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_construct(&mut self, v: ::std::string::String) {
        self.source_construct = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_construct(&mut self) -> &mut ::std::string::String {
        &mut self.source_construct
    }

    // Take field
    pub fn take_source_construct(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_construct, ::std::string::String::new())
    }

    // string target_construct = 2;

    pub fn target_construct(&self) -> &str {
        &self.target_construct
    }

    pub fn clear_target_construct(&mut self) {
        self.target_construct.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_construct(&mut self, v: ::std::string::String) {
        self.target_construct = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_construct(&mut self) -> &mut ::std::string::String {
        &mut self.target_construct
    }

    // Take field
    pub fn take_target_construct(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_construct, ::std::string::String::new())
    }

    // bool direct_mapping = 3;

    pub fn direct_mapping(&self) -> bool {
        self.direct_mapping
    }

    pub fn clear_direct_mapping(&mut self) {
        self.direct_mapping = false;
    }

    // Param is passed by value, moved
    pub fn set_direct_mapping(&mut self, v: bool) {
        self.direct_mapping = v;
    }

    // repeated string caveats = 4;

    pub fn caveats(&self) -> &[::std::string::String] {
        &self.caveats
    }

    pub fn clear_caveats(&mut self) {
        self.caveats.clear();
    }

    // Param is passed by value, moved
    pub fn set_caveats(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.caveats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_caveats(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.caveats
    }

    // Take field
    pub fn take_caveats(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.caveats, ::std::vec::Vec::new())
    }

    // repeated .kymera_mappings.LanguageMapping.ExamplesEntry examples = 5;

    pub fn examples(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.examples
    }

    pub fn clear_examples(&mut self) {
        self.examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_examples(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_examples(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.examples
    }

    // Take field
    pub fn take_examples(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.examples, ::std::collections::HashMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_construct",
            |m: &LanguageMapping| { &m.source_construct },
            |m: &mut LanguageMapping| { &mut m.source_construct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_construct",
            |m: &LanguageMapping| { &m.target_construct },
            |m: &mut LanguageMapping| { &mut m.target_construct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direct_mapping",
            |m: &LanguageMapping| { &m.direct_mapping },
            |m: &mut LanguageMapping| { &mut m.direct_mapping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "caveats",
            |m: &LanguageMapping| { &m.caveats },
            |m: &mut LanguageMapping| { &mut m.caveats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "examples",
            |m: &LanguageMapping| { &m.examples },
            |m: &mut LanguageMapping| { &mut m.examples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanguageMapping>(
            "LanguageMapping",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LanguageMapping {
    const NAME: &'static str = "LanguageMapping";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.source_construct = is.read_string()?;
                },
                18 => {
                    self.target_construct = is.read_string()?;
                },
                24 => {
                    self.direct_mapping = is.read_bool()?;
                },
                34 => {
                    self.caveats.push(is.read_string()?);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.examples.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.source_construct.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.source_construct);
        }
        if !self.target_construct.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.target_construct);
        }
        if self.direct_mapping != false {
            my_size += 1 + 1;
        }
        for value in &self.caveats {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for (k, v) in &self.examples {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.source_construct.is_empty() {
            os.write_string(1, &self.source_construct)?;
        }
        if !self.target_construct.is_empty() {
            os.write_string(2, &self.target_construct)?;
        }
        if self.direct_mapping != false {
            os.write_bool(3, self.direct_mapping)?;
        }
        for v in &self.caveats {
            os.write_string(4, &v)?;
        };
        for (k, v) in &self.examples {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LanguageMapping {
        LanguageMapping::new()
    }

    fn clear(&mut self) {
        self.source_construct.clear();
        self.target_construct.clear();
        self.direct_mapping = false;
        self.caveats.clear();
        self.examples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LanguageMapping {
        static instance: ::protobuf::rt::Lazy<LanguageMapping> = ::protobuf::rt::Lazy::new();
        instance.get(LanguageMapping::new)
    }
}

impl ::protobuf::MessageFull for LanguageMapping {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LanguageMapping").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LanguageMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LanguageMapping {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:kymera_mappings.ConstructMetadata)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConstructMetadata {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.last_updated)
    pub last_updated: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.changelog)
    pub changelog: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.computational_cost)
    pub computational_cost: ::protobuf::EnumOrUnknown<ComputationalCost>,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.memory_management)
    pub memory_management: ::protobuf::EnumOrUnknown<MemoryManagement>,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.examples)
    pub examples: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.language_mappings)
    pub language_mappings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.numeric_mappings)
    pub numeric_mappings: ::std::vec::Vec<NumericTypeMapping>,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.compatibility_notes)
    pub compatibility_notes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructMetadata.attributes)
    pub attributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.ConstructMetadata.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConstructMetadata {
    fn default() -> &'a ConstructMetadata {
        <ConstructMetadata as ::protobuf::Message>::default_instance()
    }
}

impl ConstructMetadata {
    pub fn new() -> ConstructMetadata {
        ::std::default::Default::default()
    }

    // string version = 1;

    pub fn version(&self) -> &str {
        &self.version
    }

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // string last_updated = 2;

    pub fn last_updated(&self) -> &str {
        &self.last_updated
    }

    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::std::string::String) {
        self.last_updated = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::std::string::String {
        &mut self.last_updated
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.last_updated, ::std::string::String::new())
    }

    // string changelog = 3;

    pub fn changelog(&self) -> &str {
        &self.changelog
    }

    pub fn clear_changelog(&mut self) {
        self.changelog.clear();
    }

    // Param is passed by value, moved
    pub fn set_changelog(&mut self, v: ::std::string::String) {
        self.changelog = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_changelog(&mut self) -> &mut ::std::string::String {
        &mut self.changelog
    }

    // Take field
    pub fn take_changelog(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.changelog, ::std::string::String::new())
    }

    // .kymera_mappings.ComputationalCost computational_cost = 4;

    pub fn computational_cost(&self) -> ComputationalCost {
        self.computational_cost.enum_value_or_default()
    }

    pub fn clear_computational_cost(&mut self) {
        self.computational_cost = ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU);
    }

    // Param is passed by value, moved
    pub fn set_computational_cost(&mut self, v: ComputationalCost) {
        self.computational_cost = ::protobuf::EnumOrUnknown::new(v);
    }

    // .kymera_mappings.MemoryManagement memory_management = 5;

    pub fn memory_management(&self) -> MemoryManagement {
        self.memory_management.enum_value_or_default()
    }

    pub fn clear_memory_management(&mut self) {
        self.memory_management = ::protobuf::EnumOrUnknown::new(MemoryManagement::MMU);
    }

    // Param is passed by value, moved
    pub fn set_memory_management(&mut self, v: MemoryManagement) {
        self.memory_management = ::protobuf::EnumOrUnknown::new(v);
    }

    // string description = 6;

    pub fn description(&self) -> &str {
        &self.description
    }

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated string examples = 7;

    pub fn examples(&self) -> &[::std::string::String] {
        &self.examples
    }

    pub fn clear_examples(&mut self) {
        self.examples.clear();
    }

    // Param is passed by value, moved
    pub fn set_examples(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.examples = v;
    }

    // Mutable pointer to the field.
    pub fn mut_examples(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.examples
    }

    // Take field
    pub fn take_examples(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.examples, ::std::vec::Vec::new())
    }

    // repeated .kymera_mappings.ConstructMetadata.LanguageMappingsEntry language_mappings = 8;

    pub fn language_mappings(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.language_mappings
    }

    pub fn clear_language_mappings(&mut self) {
        self.language_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_language_mappings(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.language_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_language_mappings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.language_mappings
    }

    // Take field
    pub fn take_language_mappings(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.language_mappings, ::std::collections::HashMap::new())
    }

    // repeated .kymera_mappings.NumericTypeMapping numeric_mappings = 9;

    pub fn numeric_mappings(&self) -> &[NumericTypeMapping] {
        &self.numeric_mappings
    }

    pub fn clear_numeric_mappings(&mut self) {
        self.numeric_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_numeric_mappings(&mut self, v: ::std::vec::Vec<NumericTypeMapping>) {
        self.numeric_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_numeric_mappings(&mut self) -> &mut ::std::vec::Vec<NumericTypeMapping> {
        &mut self.numeric_mappings
    }

    // Take field
    pub fn take_numeric_mappings(&mut self) -> ::std::vec::Vec<NumericTypeMapping> {
        ::std::mem::replace(&mut self.numeric_mappings, ::std::vec::Vec::new())
    }

    // repeated string compatibility_notes = 10;

    pub fn compatibility_notes(&self) -> &[::std::string::String] {
        &self.compatibility_notes
    }

    pub fn clear_compatibility_notes(&mut self) {
        self.compatibility_notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_compatibility_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.compatibility_notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compatibility_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.compatibility_notes
    }

    // Take field
    pub fn take_compatibility_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.compatibility_notes, ::std::vec::Vec::new())
    }

    // repeated .kymera_mappings.ConstructMetadata.AttributesEntry attributes = 11;

    pub fn attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.attributes
    }

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &ConstructMetadata| { &m.version },
            |m: &mut ConstructMetadata| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_updated",
            |m: &ConstructMetadata| { &m.last_updated },
            |m: &mut ConstructMetadata| { &mut m.last_updated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "changelog",
            |m: &ConstructMetadata| { &m.changelog },
            |m: &mut ConstructMetadata| { &mut m.changelog },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "computational_cost",
            |m: &ConstructMetadata| { &m.computational_cost },
            |m: &mut ConstructMetadata| { &mut m.computational_cost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "memory_management",
            |m: &ConstructMetadata| { &m.memory_management },
            |m: &mut ConstructMetadata| { &mut m.memory_management },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &ConstructMetadata| { &m.description },
            |m: &mut ConstructMetadata| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "examples",
            |m: &ConstructMetadata| { &m.examples },
            |m: &mut ConstructMetadata| { &mut m.examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "language_mappings",
            |m: &ConstructMetadata| { &m.language_mappings },
            |m: &mut ConstructMetadata| { &mut m.language_mappings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "numeric_mappings",
            |m: &ConstructMetadata| { &m.numeric_mappings },
            |m: &mut ConstructMetadata| { &mut m.numeric_mappings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "compatibility_notes",
            |m: &ConstructMetadata| { &m.compatibility_notes },
            |m: &mut ConstructMetadata| { &mut m.compatibility_notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "attributes",
            |m: &ConstructMetadata| { &m.attributes },
            |m: &mut ConstructMetadata| { &mut m.attributes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConstructMetadata>(
            "ConstructMetadata",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConstructMetadata {
    const NAME: &'static str = "ConstructMetadata";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version = is.read_string()?;
                },
                18 => {
                    self.last_updated = is.read_string()?;
                },
                26 => {
                    self.changelog = is.read_string()?;
                },
                32 => {
                    self.computational_cost = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.memory_management = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.description = is.read_string()?;
                },
                58 => {
                    self.examples.push(is.read_string()?);
                },
                66 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.language_mappings.insert(key, value);
                },
                74 => {
                    self.numeric_mappings.push(is.read_message()?);
                },
                82 => {
                    self.compatibility_notes.push(is.read_string()?);
                },
                90 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_string()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.attributes.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if !self.last_updated.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.last_updated);
        }
        if !self.changelog.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.changelog);
        }
        if self.computational_cost != ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU) {
            my_size += ::protobuf::rt::int32_size(4, self.computational_cost.value());
        }
        if self.memory_management != ::protobuf::EnumOrUnknown::new(MemoryManagement::MMU) {
            my_size += ::protobuf::rt::int32_size(5, self.memory_management.value());
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.description);
        }
        for value in &self.examples {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for (k, v) in &self.language_mappings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for value in &self.numeric_mappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.compatibility_notes {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if !self.last_updated.is_empty() {
            os.write_string(2, &self.last_updated)?;
        }
        if !self.changelog.is_empty() {
            os.write_string(3, &self.changelog)?;
        }
        if self.computational_cost != ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.computational_cost))?;
        }
        if self.memory_management != ::protobuf::EnumOrUnknown::new(MemoryManagement::MMU) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.memory_management))?;
        }
        if !self.description.is_empty() {
            os.write_string(6, &self.description)?;
        }
        for v in &self.examples {
            os.write_string(7, &v)?;
        };
        for (k, v) in &self.language_mappings {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(66)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        for v in &self.numeric_mappings {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.compatibility_notes {
            os.write_string(10, &v)?;
        };
        for (k, v) in &self.attributes {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::string_size(2, &v);
            os.write_raw_varint32(90)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConstructMetadata {
        ConstructMetadata::new()
    }

    fn clear(&mut self) {
        self.version.clear();
        self.last_updated.clear();
        self.changelog.clear();
        self.computational_cost = ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU);
        self.memory_management = ::protobuf::EnumOrUnknown::new(MemoryManagement::MMU);
        self.description.clear();
        self.examples.clear();
        self.language_mappings.clear();
        self.numeric_mappings.clear();
        self.compatibility_notes.clear();
        self.attributes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConstructMetadata {
        static instance: ::protobuf::rt::Lazy<ConstructMetadata> = ::protobuf::rt::Lazy::new();
        instance.get(ConstructMetadata::new)
    }
}

impl ::protobuf::MessageFull for ConstructMetadata {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConstructMetadata").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConstructMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConstructMetadata {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:kymera_mappings.FileVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileVersion {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.FileVersion.major)
    pub major: u32,
    // @@protoc_insertion_point(field:kymera_mappings.FileVersion.minor)
    pub minor: u32,
    // @@protoc_insertion_point(field:kymera_mappings.FileVersion.patch)
    pub patch: u32,
    // @@protoc_insertion_point(field:kymera_mappings.FileVersion.build)
    pub build: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.FileVersion.extended_notes)
    pub extended_notes: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.FileVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileVersion {
    fn default() -> &'a FileVersion {
        <FileVersion as ::protobuf::Message>::default_instance()
    }
}

impl FileVersion {
    pub fn new() -> FileVersion {
        ::std::default::Default::default()
    }

    // uint32 major = 1;

    pub fn major(&self) -> u32 {
        self.major
    }

    pub fn clear_major(&mut self) {
        self.major = 0;
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: u32) {
        self.major = v;
    }

    // uint32 minor = 2;

    pub fn minor(&self) -> u32 {
        self.minor
    }

    pub fn clear_minor(&mut self) {
        self.minor = 0;
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: u32) {
        self.minor = v;
    }

    // uint32 patch = 3;

    pub fn patch(&self) -> u32 {
        self.patch
    }

    pub fn clear_patch(&mut self) {
        self.patch = 0;
    }

    // Param is passed by value, moved
    pub fn set_patch(&mut self, v: u32) {
        self.patch = v;
    }

    // string build = 4;

    pub fn build(&self) -> &str {
        &self.build
    }

    pub fn clear_build(&mut self) {
        self.build.clear();
    }

    // Param is passed by value, moved
    pub fn set_build(&mut self, v: ::std::string::String) {
        self.build = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build(&mut self) -> &mut ::std::string::String {
        &mut self.build
    }

    // Take field
    pub fn take_build(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.build, ::std::string::String::new())
    }

    // repeated string extended_notes = 5;

    pub fn extended_notes(&self) -> &[::std::string::String] {
        &self.extended_notes
    }

    pub fn clear_extended_notes(&mut self) {
        self.extended_notes.clear();
    }

    // Param is passed by value, moved
    pub fn set_extended_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.extended_notes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extended_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.extended_notes
    }

    // Take field
    pub fn take_extended_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.extended_notes, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "major",
            |m: &FileVersion| { &m.major },
            |m: &mut FileVersion| { &mut m.major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minor",
            |m: &FileVersion| { &m.minor },
            |m: &mut FileVersion| { &mut m.minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "patch",
            |m: &FileVersion| { &m.patch },
            |m: &mut FileVersion| { &mut m.patch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "build",
            |m: &FileVersion| { &m.build },
            |m: &mut FileVersion| { &mut m.build },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extended_notes",
            |m: &FileVersion| { &m.extended_notes },
            |m: &mut FileVersion| { &mut m.extended_notes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileVersion>(
            "FileVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileVersion {
    const NAME: &'static str = "FileVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.major = is.read_uint32()?;
                },
                16 => {
                    self.minor = is.read_uint32()?;
                },
                24 => {
                    self.patch = is.read_uint32()?;
                },
                34 => {
                    self.build = is.read_string()?;
                },
                42 => {
                    self.extended_notes.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.major != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.major);
        }
        if self.minor != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.minor);
        }
        if self.patch != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.patch);
        }
        if !self.build.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.build);
        }
        for value in &self.extended_notes {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.major != 0 {
            os.write_uint32(1, self.major)?;
        }
        if self.minor != 0 {
            os.write_uint32(2, self.minor)?;
        }
        if self.patch != 0 {
            os.write_uint32(3, self.patch)?;
        }
        if !self.build.is_empty() {
            os.write_string(4, &self.build)?;
        }
        for v in &self.extended_notes {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileVersion {
        FileVersion::new()
    }

    fn clear(&mut self) {
        self.major = 0;
        self.minor = 0;
        self.patch = 0;
        self.build.clear();
        self.extended_notes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileVersion {
        static instance: FileVersion = FileVersion {
            major: 0,
            minor: 0,
            patch: 0,
            build: ::std::string::String::new(),
            extended_notes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileVersion`
pub mod file_version {
    // @@protoc_insertion_point(message:kymera_mappings.FileVersion.VersionConstraint)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct VersionConstraint {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionConstraint.min_version)
        pub min_version: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionConstraint.max_version)
        pub max_version: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionConstraint.excluded_versions)
        pub excluded_versions: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FileVersion.VersionConstraint.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a VersionConstraint {
        fn default() -> &'a VersionConstraint {
            <VersionConstraint as ::protobuf::Message>::default_instance()
        }
    }

    impl VersionConstraint {
        pub fn new() -> VersionConstraint {
            ::std::default::Default::default()
        }

        // string min_version = 1;

        pub fn min_version(&self) -> &str {
            &self.min_version
        }

        pub fn clear_min_version(&mut self) {
            self.min_version.clear();
        }

        // Param is passed by value, moved
        pub fn set_min_version(&mut self, v: ::std::string::String) {
            self.min_version = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_min_version(&mut self) -> &mut ::std::string::String {
            &mut self.min_version
        }

        // Take field
        pub fn take_min_version(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.min_version, ::std::string::String::new())
        }

        // string max_version = 2;

        pub fn max_version(&self) -> &str {
            &self.max_version
        }

        pub fn clear_max_version(&mut self) {
            self.max_version.clear();
        }

        // Param is passed by value, moved
        pub fn set_max_version(&mut self, v: ::std::string::String) {
            self.max_version = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_max_version(&mut self) -> &mut ::std::string::String {
            &mut self.max_version
        }

        // Take field
        pub fn take_max_version(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.max_version, ::std::string::String::new())
        }

        // repeated string excluded_versions = 3;

        pub fn excluded_versions(&self) -> &[::std::string::String] {
            &self.excluded_versions
        }

        pub fn clear_excluded_versions(&mut self) {
            self.excluded_versions.clear();
        }

        // Param is passed by value, moved
        pub fn set_excluded_versions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.excluded_versions = v;
        }

        // Mutable pointer to the field.
        pub fn mut_excluded_versions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.excluded_versions
        }

        // Take field
        pub fn take_excluded_versions(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.excluded_versions, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "min_version",
                |m: &VersionConstraint| { &m.min_version },
                |m: &mut VersionConstraint| { &mut m.min_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "max_version",
                |m: &VersionConstraint| { &m.max_version },
                |m: &mut VersionConstraint| { &mut m.max_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "excluded_versions",
                |m: &VersionConstraint| { &m.excluded_versions },
                |m: &mut VersionConstraint| { &mut m.excluded_versions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionConstraint>(
                "FileVersion.VersionConstraint",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for VersionConstraint {
        const NAME: &'static str = "VersionConstraint";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.min_version = is.read_string()?;
                    },
                    18 => {
                        self.max_version = is.read_string()?;
                    },
                    26 => {
                        self.excluded_versions.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.min_version.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.min_version);
            }
            if !self.max_version.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.max_version);
            }
            for value in &self.excluded_versions {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.min_version.is_empty() {
                os.write_string(1, &self.min_version)?;
            }
            if !self.max_version.is_empty() {
                os.write_string(2, &self.max_version)?;
            }
            for v in &self.excluded_versions {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> VersionConstraint {
            VersionConstraint::new()
        }

        fn clear(&mut self) {
            self.min_version.clear();
            self.max_version.clear();
            self.excluded_versions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static VersionConstraint {
            static instance: VersionConstraint = VersionConstraint {
                min_version: ::std::string::String::new(),
                max_version: ::std::string::String::new(),
                excluded_versions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for VersionConstraint {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FileVersion.VersionConstraint").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for VersionConstraint {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for VersionConstraint {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.FileVersion.VersionMetadata)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct VersionMetadata {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionMetadata.release_date)
        pub release_date: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionMetadata.author)
        pub author: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionMetadata.changes)
        pub changes: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionMetadata.breaking_changes)
        pub breaking_changes: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FileVersion.VersionMetadata.compatibility_notes)
        pub compatibility_notes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FileVersion.VersionMetadata.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a VersionMetadata {
        fn default() -> &'a VersionMetadata {
            <VersionMetadata as ::protobuf::Message>::default_instance()
        }
    }

    impl VersionMetadata {
        pub fn new() -> VersionMetadata {
            ::std::default::Default::default()
        }

        // string release_date = 1;

        pub fn release_date(&self) -> &str {
            &self.release_date
        }

        pub fn clear_release_date(&mut self) {
            self.release_date.clear();
        }

        // Param is passed by value, moved
        pub fn set_release_date(&mut self, v: ::std::string::String) {
            self.release_date = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_release_date(&mut self) -> &mut ::std::string::String {
            &mut self.release_date
        }

        // Take field
        pub fn take_release_date(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.release_date, ::std::string::String::new())
        }

        // string author = 2;

        pub fn author(&self) -> &str {
            &self.author
        }

        pub fn clear_author(&mut self) {
            self.author.clear();
        }

        // Param is passed by value, moved
        pub fn set_author(&mut self, v: ::std::string::String) {
            self.author = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_author(&mut self) -> &mut ::std::string::String {
            &mut self.author
        }

        // Take field
        pub fn take_author(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.author, ::std::string::String::new())
        }

        // repeated string changes = 3;

        pub fn changes(&self) -> &[::std::string::String] {
            &self.changes
        }

        pub fn clear_changes(&mut self) {
            self.changes.clear();
        }

        // Param is passed by value, moved
        pub fn set_changes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.changes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_changes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.changes
        }

        // Take field
        pub fn take_changes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.changes, ::std::vec::Vec::new())
        }

        // repeated string breaking_changes = 4;

        pub fn breaking_changes(&self) -> &[::std::string::String] {
            &self.breaking_changes
        }

        pub fn clear_breaking_changes(&mut self) {
            self.breaking_changes.clear();
        }

        // Param is passed by value, moved
        pub fn set_breaking_changes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.breaking_changes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_breaking_changes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.breaking_changes
        }

        // Take field
        pub fn take_breaking_changes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.breaking_changes, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.FileVersion.VersionMetadata.CompatibilityNotesEntry compatibility_notes = 5;

        pub fn compatibility_notes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.compatibility_notes
        }

        pub fn clear_compatibility_notes(&mut self) {
            self.compatibility_notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_compatibility_notes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.compatibility_notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_compatibility_notes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.compatibility_notes
        }

        // Take field
        pub fn take_compatibility_notes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.compatibility_notes, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "release_date",
                |m: &VersionMetadata| { &m.release_date },
                |m: &mut VersionMetadata| { &mut m.release_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "author",
                |m: &VersionMetadata| { &m.author },
                |m: &mut VersionMetadata| { &mut m.author },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "changes",
                |m: &VersionMetadata| { &m.changes },
                |m: &mut VersionMetadata| { &mut m.changes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "breaking_changes",
                |m: &VersionMetadata| { &m.breaking_changes },
                |m: &mut VersionMetadata| { &mut m.breaking_changes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "compatibility_notes",
                |m: &VersionMetadata| { &m.compatibility_notes },
                |m: &mut VersionMetadata| { &mut m.compatibility_notes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VersionMetadata>(
                "FileVersion.VersionMetadata",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for VersionMetadata {
        const NAME: &'static str = "VersionMetadata";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.release_date = is.read_string()?;
                    },
                    18 => {
                        self.author = is.read_string()?;
                    },
                    26 => {
                        self.changes.push(is.read_string()?);
                    },
                    34 => {
                        self.breaking_changes.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.compatibility_notes.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.release_date.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.release_date);
            }
            if !self.author.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.author);
            }
            for value in &self.changes {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.breaking_changes {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.compatibility_notes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.release_date.is_empty() {
                os.write_string(1, &self.release_date)?;
            }
            if !self.author.is_empty() {
                os.write_string(2, &self.author)?;
            }
            for v in &self.changes {
                os.write_string(3, &v)?;
            };
            for v in &self.breaking_changes {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.compatibility_notes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> VersionMetadata {
            VersionMetadata::new()
        }

        fn clear(&mut self) {
            self.release_date.clear();
            self.author.clear();
            self.changes.clear();
            self.breaking_changes.clear();
            self.compatibility_notes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static VersionMetadata {
            static instance: ::protobuf::rt::Lazy<VersionMetadata> = ::protobuf::rt::Lazy::new();
            instance.get(VersionMetadata::new)
        }
    }

    impl ::protobuf::MessageFull for VersionMetadata {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FileVersion.VersionMetadata").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for VersionMetadata {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for VersionMetadata {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.MappingError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MappingError {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.MappingError.error_code)
    pub error_code: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.MappingError.description)
    pub description: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.MappingError.suggested_fixes)
    pub suggested_fixes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:kymera_mappings.MappingError.severity)
    pub severity: ::protobuf::EnumOrUnknown<mapping_error::ErrorSeverity>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.MappingError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MappingError {
    fn default() -> &'a MappingError {
        <MappingError as ::protobuf::Message>::default_instance()
    }
}

impl MappingError {
    pub fn new() -> MappingError {
        ::std::default::Default::default()
    }

    // string error_code = 1;

    pub fn error_code(&self) -> &str {
        &self.error_code
    }

    pub fn clear_error_code(&mut self) {
        self.error_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_code(&mut self, v: ::std::string::String) {
        self.error_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_code(&mut self) -> &mut ::std::string::String {
        &mut self.error_code
    }

    // Take field
    pub fn take_error_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_code, ::std::string::String::new())
    }

    // string description = 2;

    pub fn description(&self) -> &str {
        &self.description
    }

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // repeated string suggested_fixes = 3;

    pub fn suggested_fixes(&self) -> &[::std::string::String] {
        &self.suggested_fixes
    }

    pub fn clear_suggested_fixes(&mut self) {
        self.suggested_fixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_suggested_fixes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.suggested_fixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_suggested_fixes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.suggested_fixes
    }

    // Take field
    pub fn take_suggested_fixes(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.suggested_fixes, ::std::vec::Vec::new())
    }

    // .kymera_mappings.MappingError.ErrorSeverity severity = 4;

    pub fn severity(&self) -> mapping_error::ErrorSeverity {
        self.severity.enum_value_or_default()
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::protobuf::EnumOrUnknown::new(mapping_error::ErrorSeverity::UNKNOWN);
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: mapping_error::ErrorSeverity) {
        self.severity = ::protobuf::EnumOrUnknown::new(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error_code",
            |m: &MappingError| { &m.error_code },
            |m: &mut MappingError| { &mut m.error_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "description",
            |m: &MappingError| { &m.description },
            |m: &mut MappingError| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "suggested_fixes",
            |m: &MappingError| { &m.suggested_fixes },
            |m: &mut MappingError| { &mut m.suggested_fixes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "severity",
            |m: &MappingError| { &m.severity },
            |m: &mut MappingError| { &mut m.severity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MappingError>(
            "MappingError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MappingError {
    const NAME: &'static str = "MappingError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error_code = is.read_string()?;
                },
                18 => {
                    self.description = is.read_string()?;
                },
                26 => {
                    self.suggested_fixes.push(is.read_string()?);
                },
                32 => {
                    self.severity = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error_code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error_code);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        for value in &self.suggested_fixes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.severity != ::protobuf::EnumOrUnknown::new(mapping_error::ErrorSeverity::UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.severity.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error_code.is_empty() {
            os.write_string(1, &self.error_code)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        for v in &self.suggested_fixes {
            os.write_string(3, &v)?;
        };
        if self.severity != ::protobuf::EnumOrUnknown::new(mapping_error::ErrorSeverity::UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.severity))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MappingError {
        MappingError::new()
    }

    fn clear(&mut self) {
        self.error_code.clear();
        self.description.clear();
        self.suggested_fixes.clear();
        self.severity = ::protobuf::EnumOrUnknown::new(mapping_error::ErrorSeverity::UNKNOWN);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MappingError {
        static instance: MappingError = MappingError {
            error_code: ::std::string::String::new(),
            description: ::std::string::String::new(),
            suggested_fixes: ::std::vec::Vec::new(),
            severity: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MappingError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MappingError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MappingError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MappingError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MappingError`
pub mod mapping_error {
    // @@protoc_insertion_point(message:kymera_mappings.MappingError.ErrorContext)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ErrorContext {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.MappingError.ErrorContext.source_language)
        pub source_language: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.MappingError.ErrorContext.target_language)
        pub target_language: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.MappingError.ErrorContext.construct)
        pub construct: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.MappingError.ErrorContext.stack_trace)
        pub stack_trace: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.MappingError.ErrorContext.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ErrorContext {
        fn default() -> &'a ErrorContext {
            <ErrorContext as ::protobuf::Message>::default_instance()
        }
    }

    impl ErrorContext {
        pub fn new() -> ErrorContext {
            ::std::default::Default::default()
        }

        // string source_language = 1;

        pub fn source_language(&self) -> &str {
            &self.source_language
        }

        pub fn clear_source_language(&mut self) {
            self.source_language.clear();
        }

        // Param is passed by value, moved
        pub fn set_source_language(&mut self, v: ::std::string::String) {
            self.source_language = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_source_language(&mut self) -> &mut ::std::string::String {
            &mut self.source_language
        }

        // Take field
        pub fn take_source_language(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.source_language, ::std::string::String::new())
        }

        // string target_language = 2;

        pub fn target_language(&self) -> &str {
            &self.target_language
        }

        pub fn clear_target_language(&mut self) {
            self.target_language.clear();
        }

        // Param is passed by value, moved
        pub fn set_target_language(&mut self, v: ::std::string::String) {
            self.target_language = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_target_language(&mut self) -> &mut ::std::string::String {
            &mut self.target_language
        }

        // Take field
        pub fn take_target_language(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.target_language, ::std::string::String::new())
        }

        // string construct = 3;

        pub fn construct(&self) -> &str {
            &self.construct
        }

        pub fn clear_construct(&mut self) {
            self.construct.clear();
        }

        // Param is passed by value, moved
        pub fn set_construct(&mut self, v: ::std::string::String) {
            self.construct = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_construct(&mut self) -> &mut ::std::string::String {
            &mut self.construct
        }

        // Take field
        pub fn take_construct(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.construct, ::std::string::String::new())
        }

        // string stack_trace = 4;

        pub fn stack_trace(&self) -> &str {
            &self.stack_trace
        }

        pub fn clear_stack_trace(&mut self) {
            self.stack_trace.clear();
        }

        // Param is passed by value, moved
        pub fn set_stack_trace(&mut self, v: ::std::string::String) {
            self.stack_trace = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_stack_trace(&mut self) -> &mut ::std::string::String {
            &mut self.stack_trace
        }

        // Take field
        pub fn take_stack_trace(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.stack_trace, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "source_language",
                |m: &ErrorContext| { &m.source_language },
                |m: &mut ErrorContext| { &mut m.source_language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "target_language",
                |m: &ErrorContext| { &m.target_language },
                |m: &mut ErrorContext| { &mut m.target_language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "construct",
                |m: &ErrorContext| { &m.construct },
                |m: &mut ErrorContext| { &mut m.construct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "stack_trace",
                |m: &ErrorContext| { &m.stack_trace },
                |m: &mut ErrorContext| { &mut m.stack_trace },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorContext>(
                "MappingError.ErrorContext",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ErrorContext {
        const NAME: &'static str = "ErrorContext";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.source_language = is.read_string()?;
                    },
                    18 => {
                        self.target_language = is.read_string()?;
                    },
                    26 => {
                        self.construct = is.read_string()?;
                    },
                    34 => {
                        self.stack_trace = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.source_language.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.source_language);
            }
            if !self.target_language.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.target_language);
            }
            if !self.construct.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.construct);
            }
            if !self.stack_trace.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.stack_trace);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.source_language.is_empty() {
                os.write_string(1, &self.source_language)?;
            }
            if !self.target_language.is_empty() {
                os.write_string(2, &self.target_language)?;
            }
            if !self.construct.is_empty() {
                os.write_string(3, &self.construct)?;
            }
            if !self.stack_trace.is_empty() {
                os.write_string(4, &self.stack_trace)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ErrorContext {
            ErrorContext::new()
        }

        fn clear(&mut self) {
            self.source_language.clear();
            self.target_language.clear();
            self.construct.clear();
            self.stack_trace.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ErrorContext {
            static instance: ErrorContext = ErrorContext {
                source_language: ::std::string::String::new(),
                target_language: ::std::string::String::new(),
                construct: ::std::string::String::new(),
                stack_trace: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ErrorContext {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MappingError.ErrorContext").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ErrorContext {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorContext {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.MappingError.ErrorResolution)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ErrorResolution {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.MappingError.ErrorResolution.steps)
        pub steps: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.MappingError.ErrorResolution.documentation_link)
        pub documentation_link: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.MappingError.ErrorResolution.requires_manual_intervention)
        pub requires_manual_intervention: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.MappingError.ErrorResolution.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ErrorResolution {
        fn default() -> &'a ErrorResolution {
            <ErrorResolution as ::protobuf::Message>::default_instance()
        }
    }

    impl ErrorResolution {
        pub fn new() -> ErrorResolution {
            ::std::default::Default::default()
        }

        // repeated string steps = 1;

        pub fn steps(&self) -> &[::std::string::String] {
            &self.steps
        }

        pub fn clear_steps(&mut self) {
            self.steps.clear();
        }

        // Param is passed by value, moved
        pub fn set_steps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.steps = v;
        }

        // Mutable pointer to the field.
        pub fn mut_steps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.steps
        }

        // Take field
        pub fn take_steps(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.steps, ::std::vec::Vec::new())
        }

        // string documentation_link = 2;

        pub fn documentation_link(&self) -> &str {
            &self.documentation_link
        }

        pub fn clear_documentation_link(&mut self) {
            self.documentation_link.clear();
        }

        // Param is passed by value, moved
        pub fn set_documentation_link(&mut self, v: ::std::string::String) {
            self.documentation_link = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_documentation_link(&mut self) -> &mut ::std::string::String {
            &mut self.documentation_link
        }

        // Take field
        pub fn take_documentation_link(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.documentation_link, ::std::string::String::new())
        }

        // bool requires_manual_intervention = 3;

        pub fn requires_manual_intervention(&self) -> bool {
            self.requires_manual_intervention
        }

        pub fn clear_requires_manual_intervention(&mut self) {
            self.requires_manual_intervention = false;
        }

        // Param is passed by value, moved
        pub fn set_requires_manual_intervention(&mut self, v: bool) {
            self.requires_manual_intervention = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "steps",
                |m: &ErrorResolution| { &m.steps },
                |m: &mut ErrorResolution| { &mut m.steps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "documentation_link",
                |m: &ErrorResolution| { &m.documentation_link },
                |m: &mut ErrorResolution| { &mut m.documentation_link },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "requires_manual_intervention",
                |m: &ErrorResolution| { &m.requires_manual_intervention },
                |m: &mut ErrorResolution| { &mut m.requires_manual_intervention },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorResolution>(
                "MappingError.ErrorResolution",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ErrorResolution {
        const NAME: &'static str = "ErrorResolution";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.steps.push(is.read_string()?);
                    },
                    18 => {
                        self.documentation_link = is.read_string()?;
                    },
                    24 => {
                        self.requires_manual_intervention = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.steps {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            if !self.documentation_link.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.documentation_link);
            }
            if self.requires_manual_intervention != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.steps {
                os.write_string(1, &v)?;
            };
            if !self.documentation_link.is_empty() {
                os.write_string(2, &self.documentation_link)?;
            }
            if self.requires_manual_intervention != false {
                os.write_bool(3, self.requires_manual_intervention)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ErrorResolution {
            ErrorResolution::new()
        }

        fn clear(&mut self) {
            self.steps.clear();
            self.documentation_link.clear();
            self.requires_manual_intervention = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ErrorResolution {
            static instance: ErrorResolution = ErrorResolution {
                steps: ::std::vec::Vec::new(),
                documentation_link: ::std::string::String::new(),
                requires_manual_intervention: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ErrorResolution {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MappingError.ErrorResolution").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ErrorResolution {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorResolution {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:kymera_mappings.MappingError.ErrorSeverity)
    pub enum ErrorSeverity {
        // @@protoc_insertion_point(enum_value:kymera_mappings.MappingError.ErrorSeverity.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:kymera_mappings.MappingError.ErrorSeverity.WARNING)
        WARNING = 1,
        // @@protoc_insertion_point(enum_value:kymera_mappings.MappingError.ErrorSeverity.ERROR)
        ERROR = 2,
        // @@protoc_insertion_point(enum_value:kymera_mappings.MappingError.ErrorSeverity.CRITICAL)
        CRITICAL = 3,
        // @@protoc_insertion_point(enum_value:kymera_mappings.MappingError.ErrorSeverity.FATAL)
        FATAL = 4,
    }

    impl ::protobuf::Enum for ErrorSeverity {
        const NAME: &'static str = "ErrorSeverity";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ErrorSeverity> {
            match value {
                0 => ::std::option::Option::Some(ErrorSeverity::UNKNOWN),
                1 => ::std::option::Option::Some(ErrorSeverity::WARNING),
                2 => ::std::option::Option::Some(ErrorSeverity::ERROR),
                3 => ::std::option::Option::Some(ErrorSeverity::CRITICAL),
                4 => ::std::option::Option::Some(ErrorSeverity::FATAL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ErrorSeverity> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(ErrorSeverity::UNKNOWN),
                "WARNING" => ::std::option::Option::Some(ErrorSeverity::WARNING),
                "ERROR" => ::std::option::Option::Some(ErrorSeverity::ERROR),
                "CRITICAL" => ::std::option::Option::Some(ErrorSeverity::CRITICAL),
                "FATAL" => ::std::option::Option::Some(ErrorSeverity::FATAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ErrorSeverity] = &[
            ErrorSeverity::UNKNOWN,
            ErrorSeverity::WARNING,
            ErrorSeverity::ERROR,
            ErrorSeverity::CRITICAL,
            ErrorSeverity::FATAL,
        ];
    }

    impl ::protobuf::EnumFull for ErrorSeverity {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MappingError.ErrorSeverity").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for ErrorSeverity {
        fn default() -> Self {
            ErrorSeverity::UNKNOWN
        }
    }

    impl ErrorSeverity {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ErrorSeverity>("MappingError.ErrorSeverity")
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.ConstructPerformance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConstructPerformance {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.runtime_cost)
    pub runtime_cost: ::protobuf::EnumOrUnknown<ComputationalCost>,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.memory_footprint)
    pub memory_footprint: u32,
    // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.cacheable)
    pub cacheable: bool,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.ConstructPerformance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConstructPerformance {
    fn default() -> &'a ConstructPerformance {
        <ConstructPerformance as ::protobuf::Message>::default_instance()
    }
}

impl ConstructPerformance {
    pub fn new() -> ConstructPerformance {
        ::std::default::Default::default()
    }

    // .kymera_mappings.ComputationalCost runtime_cost = 1;

    pub fn runtime_cost(&self) -> ComputationalCost {
        self.runtime_cost.enum_value_or_default()
    }

    pub fn clear_runtime_cost(&mut self) {
        self.runtime_cost = ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU);
    }

    // Param is passed by value, moved
    pub fn set_runtime_cost(&mut self, v: ComputationalCost) {
        self.runtime_cost = ::protobuf::EnumOrUnknown::new(v);
    }

    // uint32 memory_footprint = 2;

    pub fn memory_footprint(&self) -> u32 {
        self.memory_footprint
    }

    pub fn clear_memory_footprint(&mut self) {
        self.memory_footprint = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory_footprint(&mut self, v: u32) {
        self.memory_footprint = v;
    }

    // bool cacheable = 3;

    pub fn cacheable(&self) -> bool {
        self.cacheable
    }

    pub fn clear_cacheable(&mut self) {
        self.cacheable = false;
    }

    // Param is passed by value, moved
    pub fn set_cacheable(&mut self, v: bool) {
        self.cacheable = v;
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "runtime_cost",
            |m: &ConstructPerformance| { &m.runtime_cost },
            |m: &mut ConstructPerformance| { &mut m.runtime_cost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "memory_footprint",
            |m: &ConstructPerformance| { &m.memory_footprint },
            |m: &mut ConstructPerformance| { &mut m.memory_footprint },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cacheable",
            |m: &ConstructPerformance| { &m.cacheable },
            |m: &mut ConstructPerformance| { &mut m.cacheable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConstructPerformance>(
            "ConstructPerformance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConstructPerformance {
    const NAME: &'static str = "ConstructPerformance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.runtime_cost = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.memory_footprint = is.read_uint32()?;
                },
                24 => {
                    self.cacheable = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.runtime_cost != ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU) {
            my_size += ::protobuf::rt::int32_size(1, self.runtime_cost.value());
        }
        if self.memory_footprint != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.memory_footprint);
        }
        if self.cacheable != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.runtime_cost != ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.runtime_cost))?;
        }
        if self.memory_footprint != 0 {
            os.write_uint32(2, self.memory_footprint)?;
        }
        if self.cacheable != false {
            os.write_bool(3, self.cacheable)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConstructPerformance {
        ConstructPerformance::new()
    }

    fn clear(&mut self) {
        self.runtime_cost = ::protobuf::EnumOrUnknown::new(ComputationalCost::CCU);
        self.memory_footprint = 0;
        self.cacheable = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConstructPerformance {
        static instance: ConstructPerformance = ConstructPerformance {
            runtime_cost: ::protobuf::EnumOrUnknown::from_i32(0),
            memory_footprint: 0,
            cacheable: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConstructPerformance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConstructPerformance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConstructPerformance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConstructPerformance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ConstructPerformance`
pub mod construct_performance {
    // @@protoc_insertion_point(message:kymera_mappings.ConstructPerformance.PerformanceMetrics)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PerformanceMetrics {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.PerformanceMetrics.average_execution_time)
        pub average_execution_time: f64,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.PerformanceMetrics.memory_peak)
        pub memory_peak: u64,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.PerformanceMetrics.cpu_usage_percentage)
        pub cpu_usage_percentage: u32,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.PerformanceMetrics.bottlenecks)
        pub bottlenecks: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ConstructPerformance.PerformanceMetrics.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PerformanceMetrics {
        fn default() -> &'a PerformanceMetrics {
            <PerformanceMetrics as ::protobuf::Message>::default_instance()
        }
    }

    impl PerformanceMetrics {
        pub fn new() -> PerformanceMetrics {
            ::std::default::Default::default()
        }

        // double average_execution_time = 1;

        pub fn average_execution_time(&self) -> f64 {
            self.average_execution_time
        }

        pub fn clear_average_execution_time(&mut self) {
            self.average_execution_time = 0.;
        }

        // Param is passed by value, moved
        pub fn set_average_execution_time(&mut self, v: f64) {
            self.average_execution_time = v;
        }

        // uint64 memory_peak = 2;

        pub fn memory_peak(&self) -> u64 {
            self.memory_peak
        }

        pub fn clear_memory_peak(&mut self) {
            self.memory_peak = 0;
        }

        // Param is passed by value, moved
        pub fn set_memory_peak(&mut self, v: u64) {
            self.memory_peak = v;
        }

        // uint32 cpu_usage_percentage = 3;

        pub fn cpu_usage_percentage(&self) -> u32 {
            self.cpu_usage_percentage
        }

        pub fn clear_cpu_usage_percentage(&mut self) {
            self.cpu_usage_percentage = 0;
        }

        // Param is passed by value, moved
        pub fn set_cpu_usage_percentage(&mut self, v: u32) {
            self.cpu_usage_percentage = v;
        }

        // repeated string bottlenecks = 4;

        pub fn bottlenecks(&self) -> &[::std::string::String] {
            &self.bottlenecks
        }

        pub fn clear_bottlenecks(&mut self) {
            self.bottlenecks.clear();
        }

        // Param is passed by value, moved
        pub fn set_bottlenecks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.bottlenecks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_bottlenecks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.bottlenecks
        }

        // Take field
        pub fn take_bottlenecks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.bottlenecks, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "average_execution_time",
                |m: &PerformanceMetrics| { &m.average_execution_time },
                |m: &mut PerformanceMetrics| { &mut m.average_execution_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "memory_peak",
                |m: &PerformanceMetrics| { &m.memory_peak },
                |m: &mut PerformanceMetrics| { &mut m.memory_peak },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "cpu_usage_percentage",
                |m: &PerformanceMetrics| { &m.cpu_usage_percentage },
                |m: &mut PerformanceMetrics| { &mut m.cpu_usage_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bottlenecks",
                |m: &PerformanceMetrics| { &m.bottlenecks },
                |m: &mut PerformanceMetrics| { &mut m.bottlenecks },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceMetrics>(
                "ConstructPerformance.PerformanceMetrics",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PerformanceMetrics {
        const NAME: &'static str = "PerformanceMetrics";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.average_execution_time = is.read_double()?;
                    },
                    16 => {
                        self.memory_peak = is.read_uint64()?;
                    },
                    24 => {
                        self.cpu_usage_percentage = is.read_uint32()?;
                    },
                    34 => {
                        self.bottlenecks.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.average_execution_time != 0. {
                my_size += 1 + 8;
            }
            if self.memory_peak != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.memory_peak);
            }
            if self.cpu_usage_percentage != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.cpu_usage_percentage);
            }
            for value in &self.bottlenecks {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.average_execution_time != 0. {
                os.write_double(1, self.average_execution_time)?;
            }
            if self.memory_peak != 0 {
                os.write_uint64(2, self.memory_peak)?;
            }
            if self.cpu_usage_percentage != 0 {
                os.write_uint32(3, self.cpu_usage_percentage)?;
            }
            for v in &self.bottlenecks {
                os.write_string(4, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PerformanceMetrics {
            PerformanceMetrics::new()
        }

        fn clear(&mut self) {
            self.average_execution_time = 0.;
            self.memory_peak = 0;
            self.cpu_usage_percentage = 0;
            self.bottlenecks.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PerformanceMetrics {
            static instance: PerformanceMetrics = PerformanceMetrics {
                average_execution_time: 0.,
                memory_peak: 0,
                cpu_usage_percentage: 0,
                bottlenecks: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PerformanceMetrics {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ConstructPerformance.PerformanceMetrics").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PerformanceMetrics {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PerformanceMetrics {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ConstructPerformance.OptimizationHints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OptimizationHints {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.OptimizationHints.suggestions)
        pub suggestions: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.OptimizationHints.best_practices)
        pub best_practices: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.OptimizationHints.known_issues)
        pub known_issues: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ConstructPerformance.OptimizationHints.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OptimizationHints {
        fn default() -> &'a OptimizationHints {
            <OptimizationHints as ::protobuf::Message>::default_instance()
        }
    }

    impl OptimizationHints {
        pub fn new() -> OptimizationHints {
            ::std::default::Default::default()
        }

        // repeated string suggestions = 1;

        pub fn suggestions(&self) -> &[::std::string::String] {
            &self.suggestions
        }

        pub fn clear_suggestions(&mut self) {
            self.suggestions.clear();
        }

        // Param is passed by value, moved
        pub fn set_suggestions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.suggestions = v;
        }

        // Mutable pointer to the field.
        pub fn mut_suggestions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.suggestions
        }

        // Take field
        pub fn take_suggestions(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.suggestions, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.ConstructPerformance.OptimizationHints.BestPracticesEntry best_practices = 2;

        pub fn best_practices(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.best_practices
        }

        pub fn clear_best_practices(&mut self) {
            self.best_practices.clear();
        }

        // Param is passed by value, moved
        pub fn set_best_practices(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.best_practices = v;
        }

        // Mutable pointer to the field.
        pub fn mut_best_practices(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.best_practices
        }

        // Take field
        pub fn take_best_practices(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.best_practices, ::std::collections::HashMap::new())
        }

        // repeated string known_issues = 3;

        pub fn known_issues(&self) -> &[::std::string::String] {
            &self.known_issues
        }

        pub fn clear_known_issues(&mut self) {
            self.known_issues.clear();
        }

        // Param is passed by value, moved
        pub fn set_known_issues(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.known_issues = v;
        }

        // Mutable pointer to the field.
        pub fn mut_known_issues(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.known_issues
        }

        // Take field
        pub fn take_known_issues(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.known_issues, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "suggestions",
                |m: &OptimizationHints| { &m.suggestions },
                |m: &mut OptimizationHints| { &mut m.suggestions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "best_practices",
                |m: &OptimizationHints| { &m.best_practices },
                |m: &mut OptimizationHints| { &mut m.best_practices },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "known_issues",
                |m: &OptimizationHints| { &m.known_issues },
                |m: &mut OptimizationHints| { &mut m.known_issues },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptimizationHints>(
                "ConstructPerformance.OptimizationHints",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OptimizationHints {
        const NAME: &'static str = "OptimizationHints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.suggestions.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.best_practices.insert(key, value);
                    },
                    26 => {
                        self.known_issues.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.suggestions {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.best_practices {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.known_issues {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.suggestions {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.best_practices {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.known_issues {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OptimizationHints {
            OptimizationHints::new()
        }

        fn clear(&mut self) {
            self.suggestions.clear();
            self.best_practices.clear();
            self.known_issues.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OptimizationHints {
            static instance: ::protobuf::rt::Lazy<OptimizationHints> = ::protobuf::rt::Lazy::new();
            instance.get(OptimizationHints::new)
        }
    }

    impl ::protobuf::MessageFull for OptimizationHints {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ConstructPerformance.OptimizationHints").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OptimizationHints {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OptimizationHints {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ConstructPerformance.ResourceUtilization)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ResourceUtilization {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.ResourceUtilization.stack_usage)
        pub stack_usage: u32,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.ResourceUtilization.heap_allocation)
        pub heap_allocation: u32,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.ResourceUtilization.thread_safe)
        pub thread_safe: bool,
        // @@protoc_insertion_point(field:kymera_mappings.ConstructPerformance.ResourceUtilization.resource_constraints)
        pub resource_constraints: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ConstructPerformance.ResourceUtilization.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ResourceUtilization {
        fn default() -> &'a ResourceUtilization {
            <ResourceUtilization as ::protobuf::Message>::default_instance()
        }
    }

    impl ResourceUtilization {
        pub fn new() -> ResourceUtilization {
            ::std::default::Default::default()
        }

        // uint32 stack_usage = 1;

        pub fn stack_usage(&self) -> u32 {
            self.stack_usage
        }

        pub fn clear_stack_usage(&mut self) {
            self.stack_usage = 0;
        }

        // Param is passed by value, moved
        pub fn set_stack_usage(&mut self, v: u32) {
            self.stack_usage = v;
        }

        // uint32 heap_allocation = 2;

        pub fn heap_allocation(&self) -> u32 {
            self.heap_allocation
        }

        pub fn clear_heap_allocation(&mut self) {
            self.heap_allocation = 0;
        }

        // Param is passed by value, moved
        pub fn set_heap_allocation(&mut self, v: u32) {
            self.heap_allocation = v;
        }

        // bool thread_safe = 3;

        pub fn thread_safe(&self) -> bool {
            self.thread_safe
        }

        pub fn clear_thread_safe(&mut self) {
            self.thread_safe = false;
        }

        // Param is passed by value, moved
        pub fn set_thread_safe(&mut self, v: bool) {
            self.thread_safe = v;
        }

        // repeated string resource_constraints = 4;

        pub fn resource_constraints(&self) -> &[::std::string::String] {
            &self.resource_constraints
        }

        pub fn clear_resource_constraints(&mut self) {
            self.resource_constraints.clear();
        }

        // Param is passed by value, moved
        pub fn set_resource_constraints(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.resource_constraints = v;
        }

        // Mutable pointer to the field.
        pub fn mut_resource_constraints(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.resource_constraints
        }

        // Take field
        pub fn take_resource_constraints(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.resource_constraints, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "stack_usage",
                |m: &ResourceUtilization| { &m.stack_usage },
                |m: &mut ResourceUtilization| { &mut m.stack_usage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "heap_allocation",
                |m: &ResourceUtilization| { &m.heap_allocation },
                |m: &mut ResourceUtilization| { &mut m.heap_allocation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "thread_safe",
                |m: &ResourceUtilization| { &m.thread_safe },
                |m: &mut ResourceUtilization| { &mut m.thread_safe },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "resource_constraints",
                |m: &ResourceUtilization| { &m.resource_constraints },
                |m: &mut ResourceUtilization| { &mut m.resource_constraints },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceUtilization>(
                "ConstructPerformance.ResourceUtilization",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ResourceUtilization {
        const NAME: &'static str = "ResourceUtilization";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stack_usage = is.read_uint32()?;
                    },
                    16 => {
                        self.heap_allocation = is.read_uint32()?;
                    },
                    24 => {
                        self.thread_safe = is.read_bool()?;
                    },
                    34 => {
                        self.resource_constraints.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.stack_usage != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.stack_usage);
            }
            if self.heap_allocation != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.heap_allocation);
            }
            if self.thread_safe != false {
                my_size += 1 + 1;
            }
            for value in &self.resource_constraints {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.stack_usage != 0 {
                os.write_uint32(1, self.stack_usage)?;
            }
            if self.heap_allocation != 0 {
                os.write_uint32(2, self.heap_allocation)?;
            }
            if self.thread_safe != false {
                os.write_bool(3, self.thread_safe)?;
            }
            for v in &self.resource_constraints {
                os.write_string(4, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ResourceUtilization {
            ResourceUtilization::new()
        }

        fn clear(&mut self) {
            self.stack_usage = 0;
            self.heap_allocation = 0;
            self.thread_safe = false;
            self.resource_constraints.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ResourceUtilization {
            static instance: ResourceUtilization = ResourceUtilization {
                stack_usage: 0,
                heap_allocation: 0,
                thread_safe: false,
                resource_constraints: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ResourceUtilization {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ConstructPerformance.ResourceUtilization").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ResourceUtilization {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ResourceUtilization {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.ValidationRule)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValidationRule {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.rule_id)
    pub rule_id: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.condition)
    pub condition: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.error_message)
    pub error_message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.ValidationRule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValidationRule {
    fn default() -> &'a ValidationRule {
        <ValidationRule as ::protobuf::Message>::default_instance()
    }
}

impl ValidationRule {
    pub fn new() -> ValidationRule {
        ::std::default::Default::default()
    }

    // string rule_id = 1;

    pub fn rule_id(&self) -> &str {
        &self.rule_id
    }

    pub fn clear_rule_id(&mut self) {
        self.rule_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_rule_id(&mut self, v: ::std::string::String) {
        self.rule_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_id(&mut self) -> &mut ::std::string::String {
        &mut self.rule_id
    }

    // Take field
    pub fn take_rule_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rule_id, ::std::string::String::new())
    }

    // string condition = 2;

    pub fn condition(&self) -> &str {
        &self.condition
    }

    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: ::std::string::String) {
        self.condition = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut ::std::string::String {
        &mut self.condition
    }

    // Take field
    pub fn take_condition(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.condition, ::std::string::String::new())
    }

    // string error_message = 3;

    pub fn error_message(&self) -> &str {
        &self.error_message
    }

    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.error_message
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error_message, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rule_id",
            |m: &ValidationRule| { &m.rule_id },
            |m: &mut ValidationRule| { &mut m.rule_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "condition",
            |m: &ValidationRule| { &m.condition },
            |m: &mut ValidationRule| { &mut m.condition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error_message",
            |m: &ValidationRule| { &m.error_message },
            |m: &mut ValidationRule| { &mut m.error_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidationRule>(
            "ValidationRule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValidationRule {
    const NAME: &'static str = "ValidationRule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rule_id = is.read_string()?;
                },
                18 => {
                    self.condition = is.read_string()?;
                },
                26 => {
                    self.error_message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.rule_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.rule_id);
        }
        if !self.condition.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.condition);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.error_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.rule_id.is_empty() {
            os.write_string(1, &self.rule_id)?;
        }
        if !self.condition.is_empty() {
            os.write_string(2, &self.condition)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(3, &self.error_message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValidationRule {
        ValidationRule::new()
    }

    fn clear(&mut self) {
        self.rule_id.clear();
        self.condition.clear();
        self.error_message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValidationRule {
        static instance: ValidationRule = ValidationRule {
            rule_id: ::std::string::String::new(),
            condition: ::std::string::String::new(),
            error_message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValidationRule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValidationRule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValidationRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidationRule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ValidationRule`
pub mod validation_rule {
    // @@protoc_insertion_point(message:kymera_mappings.ValidationRule.Constraint)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Constraint {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.Constraint.field_name)
        pub field_name: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.Constraint.validation_regex)
        pub validation_regex: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.Constraint.allowed_values)
        pub allowed_values: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.Constraint.custom_validator)
        pub custom_validator: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ValidationRule.Constraint.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Constraint {
        fn default() -> &'a Constraint {
            <Constraint as ::protobuf::Message>::default_instance()
        }
    }

    impl Constraint {
        pub fn new() -> Constraint {
            ::std::default::Default::default()
        }

        // string field_name = 1;

        pub fn field_name(&self) -> &str {
            &self.field_name
        }

        pub fn clear_field_name(&mut self) {
            self.field_name.clear();
        }

        // Param is passed by value, moved
        pub fn set_field_name(&mut self, v: ::std::string::String) {
            self.field_name = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_field_name(&mut self) -> &mut ::std::string::String {
            &mut self.field_name
        }

        // Take field
        pub fn take_field_name(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.field_name, ::std::string::String::new())
        }

        // string validation_regex = 2;

        pub fn validation_regex(&self) -> &str {
            &self.validation_regex
        }

        pub fn clear_validation_regex(&mut self) {
            self.validation_regex.clear();
        }

        // Param is passed by value, moved
        pub fn set_validation_regex(&mut self, v: ::std::string::String) {
            self.validation_regex = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_validation_regex(&mut self) -> &mut ::std::string::String {
            &mut self.validation_regex
        }

        // Take field
        pub fn take_validation_regex(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.validation_regex, ::std::string::String::new())
        }

        // repeated string allowed_values = 3;

        pub fn allowed_values(&self) -> &[::std::string::String] {
            &self.allowed_values
        }

        pub fn clear_allowed_values(&mut self) {
            self.allowed_values.clear();
        }

        // Param is passed by value, moved
        pub fn set_allowed_values(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.allowed_values = v;
        }

        // Mutable pointer to the field.
        pub fn mut_allowed_values(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.allowed_values
        }

        // Take field
        pub fn take_allowed_values(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.allowed_values, ::std::vec::Vec::new())
        }

        // string custom_validator = 4;

        pub fn custom_validator(&self) -> &str {
            &self.custom_validator
        }

        pub fn clear_custom_validator(&mut self) {
            self.custom_validator.clear();
        }

        // Param is passed by value, moved
        pub fn set_custom_validator(&mut self, v: ::std::string::String) {
            self.custom_validator = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_custom_validator(&mut self) -> &mut ::std::string::String {
            &mut self.custom_validator
        }

        // Take field
        pub fn take_custom_validator(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.custom_validator, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "field_name",
                |m: &Constraint| { &m.field_name },
                |m: &mut Constraint| { &mut m.field_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "validation_regex",
                |m: &Constraint| { &m.validation_regex },
                |m: &mut Constraint| { &mut m.validation_regex },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "allowed_values",
                |m: &Constraint| { &m.allowed_values },
                |m: &mut Constraint| { &mut m.allowed_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "custom_validator",
                |m: &Constraint| { &m.custom_validator },
                |m: &mut Constraint| { &mut m.custom_validator },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Constraint>(
                "ValidationRule.Constraint",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Constraint {
        const NAME: &'static str = "Constraint";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.field_name = is.read_string()?;
                    },
                    18 => {
                        self.validation_regex = is.read_string()?;
                    },
                    26 => {
                        self.allowed_values.push(is.read_string()?);
                    },
                    34 => {
                        self.custom_validator = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.field_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.field_name);
            }
            if !self.validation_regex.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.validation_regex);
            }
            for value in &self.allowed_values {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if !self.custom_validator.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.custom_validator);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.field_name.is_empty() {
                os.write_string(1, &self.field_name)?;
            }
            if !self.validation_regex.is_empty() {
                os.write_string(2, &self.validation_regex)?;
            }
            for v in &self.allowed_values {
                os.write_string(3, &v)?;
            };
            if !self.custom_validator.is_empty() {
                os.write_string(4, &self.custom_validator)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Constraint {
            Constraint::new()
        }

        fn clear(&mut self) {
            self.field_name.clear();
            self.validation_regex.clear();
            self.allowed_values.clear();
            self.custom_validator.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Constraint {
            static instance: Constraint = Constraint {
                field_name: ::std::string::String::new(),
                validation_regex: ::std::string::String::new(),
                allowed_values: ::std::vec::Vec::new(),
                custom_validator: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Constraint {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ValidationRule.Constraint").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Constraint {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Constraint {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ValidationRule.ValidationContext)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ValidationContext {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.ValidationContext.prerequisites)
        pub prerequisites: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.ValidationContext.dependencies)
        pub dependencies: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.ValidationContext.environment_requirements)
        pub environment_requirements: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ValidationRule.ValidationContext.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ValidationContext {
        fn default() -> &'a ValidationContext {
            <ValidationContext as ::protobuf::Message>::default_instance()
        }
    }

    impl ValidationContext {
        pub fn new() -> ValidationContext {
            ::std::default::Default::default()
        }

        // repeated string prerequisites = 1;

        pub fn prerequisites(&self) -> &[::std::string::String] {
            &self.prerequisites
        }

        pub fn clear_prerequisites(&mut self) {
            self.prerequisites.clear();
        }

        // Param is passed by value, moved
        pub fn set_prerequisites(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.prerequisites = v;
        }

        // Mutable pointer to the field.
        pub fn mut_prerequisites(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.prerequisites
        }

        // Take field
        pub fn take_prerequisites(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.prerequisites, ::std::vec::Vec::new())
        }

        // repeated string dependencies = 2;

        pub fn dependencies(&self) -> &[::std::string::String] {
            &self.dependencies
        }

        pub fn clear_dependencies(&mut self) {
            self.dependencies.clear();
        }

        // Param is passed by value, moved
        pub fn set_dependencies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.dependencies = v;
        }

        // Mutable pointer to the field.
        pub fn mut_dependencies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.dependencies
        }

        // Take field
        pub fn take_dependencies(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.dependencies, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.ValidationRule.ValidationContext.EnvironmentRequirementsEntry environment_requirements = 3;

        pub fn environment_requirements(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.environment_requirements
        }

        pub fn clear_environment_requirements(&mut self) {
            self.environment_requirements.clear();
        }

        // Param is passed by value, moved
        pub fn set_environment_requirements(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.environment_requirements = v;
        }

        // Mutable pointer to the field.
        pub fn mut_environment_requirements(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.environment_requirements
        }

        // Take field
        pub fn take_environment_requirements(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.environment_requirements, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "prerequisites",
                |m: &ValidationContext| { &m.prerequisites },
                |m: &mut ValidationContext| { &mut m.prerequisites },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dependencies",
                |m: &ValidationContext| { &m.dependencies },
                |m: &mut ValidationContext| { &mut m.dependencies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "environment_requirements",
                |m: &ValidationContext| { &m.environment_requirements },
                |m: &mut ValidationContext| { &mut m.environment_requirements },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidationContext>(
                "ValidationRule.ValidationContext",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ValidationContext {
        const NAME: &'static str = "ValidationContext";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.prerequisites.push(is.read_string()?);
                    },
                    18 => {
                        self.dependencies.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.environment_requirements.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.prerequisites {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.dependencies {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.environment_requirements {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.prerequisites {
                os.write_string(1, &v)?;
            };
            for v in &self.dependencies {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.environment_requirements {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ValidationContext {
            ValidationContext::new()
        }

        fn clear(&mut self) {
            self.prerequisites.clear();
            self.dependencies.clear();
            self.environment_requirements.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ValidationContext {
            static instance: ::protobuf::rt::Lazy<ValidationContext> = ::protobuf::rt::Lazy::new();
            instance.get(ValidationContext::new)
        }
    }

    impl ::protobuf::MessageFull for ValidationContext {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ValidationRule.ValidationContext").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ValidationContext {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ValidationContext {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ValidationRule.ValidationResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ValidationResult {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.ValidationResult.is_valid)
        pub is_valid: bool,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.ValidationResult.violations)
        pub violations: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.ValidationResult.warnings)
        pub warnings: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ValidationRule.ValidationResult.validation_time)
        pub validation_time: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ValidationRule.ValidationResult.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ValidationResult {
        fn default() -> &'a ValidationResult {
            <ValidationResult as ::protobuf::Message>::default_instance()
        }
    }

    impl ValidationResult {
        pub fn new() -> ValidationResult {
            ::std::default::Default::default()
        }

        // bool is_valid = 1;

        pub fn is_valid(&self) -> bool {
            self.is_valid
        }

        pub fn clear_is_valid(&mut self) {
            self.is_valid = false;
        }

        // Param is passed by value, moved
        pub fn set_is_valid(&mut self, v: bool) {
            self.is_valid = v;
        }

        // repeated string violations = 2;

        pub fn violations(&self) -> &[::std::string::String] {
            &self.violations
        }

        pub fn clear_violations(&mut self) {
            self.violations.clear();
        }

        // Param is passed by value, moved
        pub fn set_violations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.violations = v;
        }

        // Mutable pointer to the field.
        pub fn mut_violations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.violations
        }

        // Take field
        pub fn take_violations(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.violations, ::std::vec::Vec::new())
        }

        // repeated string warnings = 3;

        pub fn warnings(&self) -> &[::std::string::String] {
            &self.warnings
        }

        pub fn clear_warnings(&mut self) {
            self.warnings.clear();
        }

        // Param is passed by value, moved
        pub fn set_warnings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.warnings = v;
        }

        // Mutable pointer to the field.
        pub fn mut_warnings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.warnings
        }

        // Take field
        pub fn take_warnings(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.warnings, ::std::vec::Vec::new())
        }

        // string validation_time = 4;

        pub fn validation_time(&self) -> &str {
            &self.validation_time
        }

        pub fn clear_validation_time(&mut self) {
            self.validation_time.clear();
        }

        // Param is passed by value, moved
        pub fn set_validation_time(&mut self, v: ::std::string::String) {
            self.validation_time = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_validation_time(&mut self) -> &mut ::std::string::String {
            &mut self.validation_time
        }

        // Take field
        pub fn take_validation_time(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.validation_time, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "is_valid",
                |m: &ValidationResult| { &m.is_valid },
                |m: &mut ValidationResult| { &mut m.is_valid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "violations",
                |m: &ValidationResult| { &m.violations },
                |m: &mut ValidationResult| { &mut m.violations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "warnings",
                |m: &ValidationResult| { &m.warnings },
                |m: &mut ValidationResult| { &mut m.warnings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "validation_time",
                |m: &ValidationResult| { &m.validation_time },
                |m: &mut ValidationResult| { &mut m.validation_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValidationResult>(
                "ValidationRule.ValidationResult",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ValidationResult {
        const NAME: &'static str = "ValidationResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.is_valid = is.read_bool()?;
                    },
                    18 => {
                        self.violations.push(is.read_string()?);
                    },
                    26 => {
                        self.warnings.push(is.read_string()?);
                    },
                    34 => {
                        self.validation_time = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.is_valid != false {
                my_size += 1 + 1;
            }
            for value in &self.violations {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for value in &self.warnings {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if !self.validation_time.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.validation_time);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.is_valid != false {
                os.write_bool(1, self.is_valid)?;
            }
            for v in &self.violations {
                os.write_string(2, &v)?;
            };
            for v in &self.warnings {
                os.write_string(3, &v)?;
            };
            if !self.validation_time.is_empty() {
                os.write_string(4, &self.validation_time)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ValidationResult {
            ValidationResult::new()
        }

        fn clear(&mut self) {
            self.is_valid = false;
            self.violations.clear();
            self.warnings.clear();
            self.validation_time.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ValidationResult {
            static instance: ValidationResult = ValidationResult {
                is_valid: false,
                violations: ::std::vec::Vec::new(),
                warnings: ::std::vec::Vec::new(),
                validation_time: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ValidationResult {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ValidationRule.ValidationResult").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ValidationResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ValidationResult {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.DeprecationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeprecationInfo {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.is_deprecated)
    pub is_deprecated: bool,
    // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.since_version)
    pub since_version: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.replacement)
    pub replacement: ::std::string::String,
    // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.migration_guide)
    pub migration_guide: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.DeprecationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeprecationInfo {
    fn default() -> &'a DeprecationInfo {
        <DeprecationInfo as ::protobuf::Message>::default_instance()
    }
}

impl DeprecationInfo {
    pub fn new() -> DeprecationInfo {
        ::std::default::Default::default()
    }

    // bool is_deprecated = 1;

    pub fn is_deprecated(&self) -> bool {
        self.is_deprecated
    }

    pub fn clear_is_deprecated(&mut self) {
        self.is_deprecated = false;
    }

    // Param is passed by value, moved
    pub fn set_is_deprecated(&mut self, v: bool) {
        self.is_deprecated = v;
    }

    // string since_version = 2;

    pub fn since_version(&self) -> &str {
        &self.since_version
    }

    pub fn clear_since_version(&mut self) {
        self.since_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_since_version(&mut self, v: ::std::string::String) {
        self.since_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_since_version(&mut self) -> &mut ::std::string::String {
        &mut self.since_version
    }

    // Take field
    pub fn take_since_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.since_version, ::std::string::String::new())
    }

    // string replacement = 3;

    pub fn replacement(&self) -> &str {
        &self.replacement
    }

    pub fn clear_replacement(&mut self) {
        self.replacement.clear();
    }

    // Param is passed by value, moved
    pub fn set_replacement(&mut self, v: ::std::string::String) {
        self.replacement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replacement(&mut self) -> &mut ::std::string::String {
        &mut self.replacement
    }

    // Take field
    pub fn take_replacement(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.replacement, ::std::string::String::new())
    }

    // string migration_guide = 4;

    pub fn migration_guide(&self) -> &str {
        &self.migration_guide
    }

    pub fn clear_migration_guide(&mut self) {
        self.migration_guide.clear();
    }

    // Param is passed by value, moved
    pub fn set_migration_guide(&mut self, v: ::std::string::String) {
        self.migration_guide = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_migration_guide(&mut self) -> &mut ::std::string::String {
        &mut self.migration_guide
    }

    // Take field
    pub fn take_migration_guide(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.migration_guide, ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_deprecated",
            |m: &DeprecationInfo| { &m.is_deprecated },
            |m: &mut DeprecationInfo| { &mut m.is_deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "since_version",
            |m: &DeprecationInfo| { &m.since_version },
            |m: &mut DeprecationInfo| { &mut m.since_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replacement",
            |m: &DeprecationInfo| { &m.replacement },
            |m: &mut DeprecationInfo| { &mut m.replacement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "migration_guide",
            |m: &DeprecationInfo| { &m.migration_guide },
            |m: &mut DeprecationInfo| { &mut m.migration_guide },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeprecationInfo>(
            "DeprecationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeprecationInfo {
    const NAME: &'static str = "DeprecationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_deprecated = is.read_bool()?;
                },
                18 => {
                    self.since_version = is.read_string()?;
                },
                26 => {
                    self.replacement = is.read_string()?;
                },
                34 => {
                    self.migration_guide = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_deprecated != false {
            my_size += 1 + 1;
        }
        if !self.since_version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.since_version);
        }
        if !self.replacement.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.replacement);
        }
        if !self.migration_guide.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.migration_guide);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_deprecated != false {
            os.write_bool(1, self.is_deprecated)?;
        }
        if !self.since_version.is_empty() {
            os.write_string(2, &self.since_version)?;
        }
        if !self.replacement.is_empty() {
            os.write_string(3, &self.replacement)?;
        }
        if !self.migration_guide.is_empty() {
            os.write_string(4, &self.migration_guide)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeprecationInfo {
        DeprecationInfo::new()
    }

    fn clear(&mut self) {
        self.is_deprecated = false;
        self.since_version.clear();
        self.replacement.clear();
        self.migration_guide.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeprecationInfo {
        static instance: DeprecationInfo = DeprecationInfo {
            is_deprecated: false,
            since_version: ::std::string::String::new(),
            replacement: ::std::string::String::new(),
            migration_guide: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeprecationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeprecationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeprecationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeprecationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DeprecationInfo`
pub mod deprecation_info {
    // @@protoc_insertion_point(message:kymera_mappings.DeprecationInfo.DeprecationSchedule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeprecationSchedule {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.DeprecationSchedule.announcement_date)
        pub announcement_date: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.DeprecationSchedule.soft_deprecation_date)
        pub soft_deprecation_date: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.DeprecationSchedule.hard_deprecation_date)
        pub hard_deprecation_date: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.DeprecationSchedule.end_of_life_date)
        pub end_of_life_date: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.DeprecationInfo.DeprecationSchedule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeprecationSchedule {
        fn default() -> &'a DeprecationSchedule {
            <DeprecationSchedule as ::protobuf::Message>::default_instance()
        }
    }

    impl DeprecationSchedule {
        pub fn new() -> DeprecationSchedule {
            ::std::default::Default::default()
        }

        // string announcement_date = 1;

        pub fn announcement_date(&self) -> &str {
            &self.announcement_date
        }

        pub fn clear_announcement_date(&mut self) {
            self.announcement_date.clear();
        }

        // Param is passed by value, moved
        pub fn set_announcement_date(&mut self, v: ::std::string::String) {
            self.announcement_date = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_announcement_date(&mut self) -> &mut ::std::string::String {
            &mut self.announcement_date
        }

        // Take field
        pub fn take_announcement_date(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.announcement_date, ::std::string::String::new())
        }

        // string soft_deprecation_date = 2;

        pub fn soft_deprecation_date(&self) -> &str {
            &self.soft_deprecation_date
        }

        pub fn clear_soft_deprecation_date(&mut self) {
            self.soft_deprecation_date.clear();
        }

        // Param is passed by value, moved
        pub fn set_soft_deprecation_date(&mut self, v: ::std::string::String) {
            self.soft_deprecation_date = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_soft_deprecation_date(&mut self) -> &mut ::std::string::String {
            &mut self.soft_deprecation_date
        }

        // Take field
        pub fn take_soft_deprecation_date(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.soft_deprecation_date, ::std::string::String::new())
        }

        // string hard_deprecation_date = 3;

        pub fn hard_deprecation_date(&self) -> &str {
            &self.hard_deprecation_date
        }

        pub fn clear_hard_deprecation_date(&mut self) {
            self.hard_deprecation_date.clear();
        }

        // Param is passed by value, moved
        pub fn set_hard_deprecation_date(&mut self, v: ::std::string::String) {
            self.hard_deprecation_date = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hard_deprecation_date(&mut self) -> &mut ::std::string::String {
            &mut self.hard_deprecation_date
        }

        // Take field
        pub fn take_hard_deprecation_date(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.hard_deprecation_date, ::std::string::String::new())
        }

        // string end_of_life_date = 4;

        pub fn end_of_life_date(&self) -> &str {
            &self.end_of_life_date
        }

        pub fn clear_end_of_life_date(&mut self) {
            self.end_of_life_date.clear();
        }

        // Param is passed by value, moved
        pub fn set_end_of_life_date(&mut self, v: ::std::string::String) {
            self.end_of_life_date = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_end_of_life_date(&mut self) -> &mut ::std::string::String {
            &mut self.end_of_life_date
        }

        // Take field
        pub fn take_end_of_life_date(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.end_of_life_date, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "announcement_date",
                |m: &DeprecationSchedule| { &m.announcement_date },
                |m: &mut DeprecationSchedule| { &mut m.announcement_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "soft_deprecation_date",
                |m: &DeprecationSchedule| { &m.soft_deprecation_date },
                |m: &mut DeprecationSchedule| { &mut m.soft_deprecation_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hard_deprecation_date",
                |m: &DeprecationSchedule| { &m.hard_deprecation_date },
                |m: &mut DeprecationSchedule| { &mut m.hard_deprecation_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "end_of_life_date",
                |m: &DeprecationSchedule| { &m.end_of_life_date },
                |m: &mut DeprecationSchedule| { &mut m.end_of_life_date },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeprecationSchedule>(
                "DeprecationInfo.DeprecationSchedule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeprecationSchedule {
        const NAME: &'static str = "DeprecationSchedule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.announcement_date = is.read_string()?;
                    },
                    18 => {
                        self.soft_deprecation_date = is.read_string()?;
                    },
                    26 => {
                        self.hard_deprecation_date = is.read_string()?;
                    },
                    34 => {
                        self.end_of_life_date = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.announcement_date.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.announcement_date);
            }
            if !self.soft_deprecation_date.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.soft_deprecation_date);
            }
            if !self.hard_deprecation_date.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.hard_deprecation_date);
            }
            if !self.end_of_life_date.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.end_of_life_date);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.announcement_date.is_empty() {
                os.write_string(1, &self.announcement_date)?;
            }
            if !self.soft_deprecation_date.is_empty() {
                os.write_string(2, &self.soft_deprecation_date)?;
            }
            if !self.hard_deprecation_date.is_empty() {
                os.write_string(3, &self.hard_deprecation_date)?;
            }
            if !self.end_of_life_date.is_empty() {
                os.write_string(4, &self.end_of_life_date)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeprecationSchedule {
            DeprecationSchedule::new()
        }

        fn clear(&mut self) {
            self.announcement_date.clear();
            self.soft_deprecation_date.clear();
            self.hard_deprecation_date.clear();
            self.end_of_life_date.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeprecationSchedule {
            static instance: DeprecationSchedule = DeprecationSchedule {
                announcement_date: ::std::string::String::new(),
                soft_deprecation_date: ::std::string::String::new(),
                hard_deprecation_date: ::std::string::String::new(),
                end_of_life_date: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeprecationSchedule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DeprecationInfo.DeprecationSchedule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeprecationSchedule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeprecationSchedule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.DeprecationInfo.MigrationStep)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MigrationStep {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.MigrationStep.step_number)
        pub step_number: u32,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.MigrationStep.description)
        pub description: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.MigrationStep.code_example)
        pub code_example: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.MigrationStep.caveats)
        pub caveats: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.DeprecationInfo.MigrationStep.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MigrationStep {
        fn default() -> &'a MigrationStep {
            <MigrationStep as ::protobuf::Message>::default_instance()
        }
    }

    impl MigrationStep {
        pub fn new() -> MigrationStep {
            ::std::default::Default::default()
        }

        // uint32 step_number = 1;

        pub fn step_number(&self) -> u32 {
            self.step_number
        }

        pub fn clear_step_number(&mut self) {
            self.step_number = 0;
        }

        // Param is passed by value, moved
        pub fn set_step_number(&mut self, v: u32) {
            self.step_number = v;
        }

        // string description = 2;

        pub fn description(&self) -> &str {
            &self.description
        }

        pub fn clear_description(&mut self) {
            self.description.clear();
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            &mut self.description
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.description, ::std::string::String::new())
        }

        // string code_example = 3;

        pub fn code_example(&self) -> &str {
            &self.code_example
        }

        pub fn clear_code_example(&mut self) {
            self.code_example.clear();
        }

        // Param is passed by value, moved
        pub fn set_code_example(&mut self, v: ::std::string::String) {
            self.code_example = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_code_example(&mut self) -> &mut ::std::string::String {
            &mut self.code_example
        }

        // Take field
        pub fn take_code_example(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.code_example, ::std::string::String::new())
        }

        // repeated string caveats = 4;

        pub fn caveats(&self) -> &[::std::string::String] {
            &self.caveats
        }

        pub fn clear_caveats(&mut self) {
            self.caveats.clear();
        }

        // Param is passed by value, moved
        pub fn set_caveats(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.caveats = v;
        }

        // Mutable pointer to the field.
        pub fn mut_caveats(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.caveats
        }

        // Take field
        pub fn take_caveats(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.caveats, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "step_number",
                |m: &MigrationStep| { &m.step_number },
                |m: &mut MigrationStep| { &mut m.step_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "description",
                |m: &MigrationStep| { &m.description },
                |m: &mut MigrationStep| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "code_example",
                |m: &MigrationStep| { &m.code_example },
                |m: &mut MigrationStep| { &mut m.code_example },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "caveats",
                |m: &MigrationStep| { &m.caveats },
                |m: &mut MigrationStep| { &mut m.caveats },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MigrationStep>(
                "DeprecationInfo.MigrationStep",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MigrationStep {
        const NAME: &'static str = "MigrationStep";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.step_number = is.read_uint32()?;
                    },
                    18 => {
                        self.description = is.read_string()?;
                    },
                    26 => {
                        self.code_example = is.read_string()?;
                    },
                    34 => {
                        self.caveats.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.step_number != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.step_number);
            }
            if !self.description.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.description);
            }
            if !self.code_example.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.code_example);
            }
            for value in &self.caveats {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.step_number != 0 {
                os.write_uint32(1, self.step_number)?;
            }
            if !self.description.is_empty() {
                os.write_string(2, &self.description)?;
            }
            if !self.code_example.is_empty() {
                os.write_string(3, &self.code_example)?;
            }
            for v in &self.caveats {
                os.write_string(4, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MigrationStep {
            MigrationStep::new()
        }

        fn clear(&mut self) {
            self.step_number = 0;
            self.description.clear();
            self.code_example.clear();
            self.caveats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MigrationStep {
            static instance: MigrationStep = MigrationStep {
                step_number: 0,
                description: ::std::string::String::new(),
                code_example: ::std::string::String::new(),
                caveats: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MigrationStep {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DeprecationInfo.MigrationStep").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MigrationStep {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MigrationStep {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.DeprecationInfo.CompatibilityLayer)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CompatibilityLayer {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.CompatibilityLayer.provides_compatibility)
        pub provides_compatibility: bool,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.CompatibilityLayer.compatibility_version)
        pub compatibility_version: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.CompatibilityLayer.limitations)
        pub limitations: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.DeprecationInfo.CompatibilityLayer.sunset_date)
        pub sunset_date: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.DeprecationInfo.CompatibilityLayer.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CompatibilityLayer {
        fn default() -> &'a CompatibilityLayer {
            <CompatibilityLayer as ::protobuf::Message>::default_instance()
        }
    }

    impl CompatibilityLayer {
        pub fn new() -> CompatibilityLayer {
            ::std::default::Default::default()
        }

        // bool provides_compatibility = 1;

        pub fn provides_compatibility(&self) -> bool {
            self.provides_compatibility
        }

        pub fn clear_provides_compatibility(&mut self) {
            self.provides_compatibility = false;
        }

        // Param is passed by value, moved
        pub fn set_provides_compatibility(&mut self, v: bool) {
            self.provides_compatibility = v;
        }

        // string compatibility_version = 2;

        pub fn compatibility_version(&self) -> &str {
            &self.compatibility_version
        }

        pub fn clear_compatibility_version(&mut self) {
            self.compatibility_version.clear();
        }

        // Param is passed by value, moved
        pub fn set_compatibility_version(&mut self, v: ::std::string::String) {
            self.compatibility_version = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_compatibility_version(&mut self) -> &mut ::std::string::String {
            &mut self.compatibility_version
        }

        // Take field
        pub fn take_compatibility_version(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.compatibility_version, ::std::string::String::new())
        }

        // repeated string limitations = 3;

        pub fn limitations(&self) -> &[::std::string::String] {
            &self.limitations
        }

        pub fn clear_limitations(&mut self) {
            self.limitations.clear();
        }

        // Param is passed by value, moved
        pub fn set_limitations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.limitations = v;
        }

        // Mutable pointer to the field.
        pub fn mut_limitations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.limitations
        }

        // Take field
        pub fn take_limitations(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.limitations, ::std::vec::Vec::new())
        }

        // string sunset_date = 4;

        pub fn sunset_date(&self) -> &str {
            &self.sunset_date
        }

        pub fn clear_sunset_date(&mut self) {
            self.sunset_date.clear();
        }

        // Param is passed by value, moved
        pub fn set_sunset_date(&mut self, v: ::std::string::String) {
            self.sunset_date = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_sunset_date(&mut self) -> &mut ::std::string::String {
            &mut self.sunset_date
        }

        // Take field
        pub fn take_sunset_date(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.sunset_date, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "provides_compatibility",
                |m: &CompatibilityLayer| { &m.provides_compatibility },
                |m: &mut CompatibilityLayer| { &mut m.provides_compatibility },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "compatibility_version",
                |m: &CompatibilityLayer| { &m.compatibility_version },
                |m: &mut CompatibilityLayer| { &mut m.compatibility_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "limitations",
                |m: &CompatibilityLayer| { &m.limitations },
                |m: &mut CompatibilityLayer| { &mut m.limitations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "sunset_date",
                |m: &CompatibilityLayer| { &m.sunset_date },
                |m: &mut CompatibilityLayer| { &mut m.sunset_date },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompatibilityLayer>(
                "DeprecationInfo.CompatibilityLayer",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CompatibilityLayer {
        const NAME: &'static str = "CompatibilityLayer";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.provides_compatibility = is.read_bool()?;
                    },
                    18 => {
                        self.compatibility_version = is.read_string()?;
                    },
                    26 => {
                        self.limitations.push(is.read_string()?);
                    },
                    34 => {
                        self.sunset_date = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.provides_compatibility != false {
                my_size += 1 + 1;
            }
            if !self.compatibility_version.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.compatibility_version);
            }
            for value in &self.limitations {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if !self.sunset_date.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.sunset_date);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.provides_compatibility != false {
                os.write_bool(1, self.provides_compatibility)?;
            }
            if !self.compatibility_version.is_empty() {
                os.write_string(2, &self.compatibility_version)?;
            }
            for v in &self.limitations {
                os.write_string(3, &v)?;
            };
            if !self.sunset_date.is_empty() {
                os.write_string(4, &self.sunset_date)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CompatibilityLayer {
            CompatibilityLayer::new()
        }

        fn clear(&mut self) {
            self.provides_compatibility = false;
            self.compatibility_version.clear();
            self.limitations.clear();
            self.sunset_date.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CompatibilityLayer {
            static instance: CompatibilityLayer = CompatibilityLayer {
                provides_compatibility: false,
                compatibility_version: ::std::string::String::new(),
                limitations: ::std::vec::Vec::new(),
                sunset_date: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CompatibilityLayer {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DeprecationInfo.CompatibilityLayer").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CompatibilityLayer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CompatibilityLayer {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SafetyFeatures {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SafetyFeatures {
    fn default() -> &'a SafetyFeatures {
        <SafetyFeatures as ::protobuf::Message>::default_instance()
    }
}

impl SafetyFeatures {
    pub fn new() -> SafetyFeatures {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SafetyFeatures>(
            "SafetyFeatures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SafetyFeatures {
    const NAME: &'static str = "SafetyFeatures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SafetyFeatures {
        SafetyFeatures::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SafetyFeatures {
        static instance: SafetyFeatures = SafetyFeatures {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SafetyFeatures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SafetyFeatures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SafetyFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SafetyFeatures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SafetyFeatures`
pub mod safety_features {
    // @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures.BackwardCompatibility)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BackwardCompatibility {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.BackwardCompatibility.is_backward_compatible)
        pub is_backward_compatible: bool,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.BackwardCompatibility.breaking_changes)
        pub breaking_changes: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.BackwardCompatibility.compatibility_fixes)
        pub compatibility_fixes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.BackwardCompatibility.minimum_supported_version)
        pub minimum_supported_version: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.BackwardCompatibility.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BackwardCompatibility {
        fn default() -> &'a BackwardCompatibility {
            <BackwardCompatibility as ::protobuf::Message>::default_instance()
        }
    }

    impl BackwardCompatibility {
        pub fn new() -> BackwardCompatibility {
            ::std::default::Default::default()
        }

        // bool is_backward_compatible = 1;

        pub fn is_backward_compatible(&self) -> bool {
            self.is_backward_compatible
        }

        pub fn clear_is_backward_compatible(&mut self) {
            self.is_backward_compatible = false;
        }

        // Param is passed by value, moved
        pub fn set_is_backward_compatible(&mut self, v: bool) {
            self.is_backward_compatible = v;
        }

        // repeated string breaking_changes = 2;

        pub fn breaking_changes(&self) -> &[::std::string::String] {
            &self.breaking_changes
        }

        pub fn clear_breaking_changes(&mut self) {
            self.breaking_changes.clear();
        }

        // Param is passed by value, moved
        pub fn set_breaking_changes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.breaking_changes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_breaking_changes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.breaking_changes
        }

        // Take field
        pub fn take_breaking_changes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.breaking_changes, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SafetyFeatures.BackwardCompatibility.CompatibilityFixesEntry compatibility_fixes = 3;

        pub fn compatibility_fixes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.compatibility_fixes
        }

        pub fn clear_compatibility_fixes(&mut self) {
            self.compatibility_fixes.clear();
        }

        // Param is passed by value, moved
        pub fn set_compatibility_fixes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.compatibility_fixes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_compatibility_fixes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.compatibility_fixes
        }

        // Take field
        pub fn take_compatibility_fixes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.compatibility_fixes, ::std::collections::HashMap::new())
        }

        // string minimum_supported_version = 4;

        pub fn minimum_supported_version(&self) -> &str {
            &self.minimum_supported_version
        }

        pub fn clear_minimum_supported_version(&mut self) {
            self.minimum_supported_version.clear();
        }

        // Param is passed by value, moved
        pub fn set_minimum_supported_version(&mut self, v: ::std::string::String) {
            self.minimum_supported_version = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_minimum_supported_version(&mut self) -> &mut ::std::string::String {
            &mut self.minimum_supported_version
        }

        // Take field
        pub fn take_minimum_supported_version(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.minimum_supported_version, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "is_backward_compatible",
                |m: &BackwardCompatibility| { &m.is_backward_compatible },
                |m: &mut BackwardCompatibility| { &mut m.is_backward_compatible },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "breaking_changes",
                |m: &BackwardCompatibility| { &m.breaking_changes },
                |m: &mut BackwardCompatibility| { &mut m.breaking_changes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "compatibility_fixes",
                |m: &BackwardCompatibility| { &m.compatibility_fixes },
                |m: &mut BackwardCompatibility| { &mut m.compatibility_fixes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "minimum_supported_version",
                |m: &BackwardCompatibility| { &m.minimum_supported_version },
                |m: &mut BackwardCompatibility| { &mut m.minimum_supported_version },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BackwardCompatibility>(
                "SafetyFeatures.BackwardCompatibility",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BackwardCompatibility {
        const NAME: &'static str = "BackwardCompatibility";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.is_backward_compatible = is.read_bool()?;
                    },
                    18 => {
                        self.breaking_changes.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.compatibility_fixes.insert(key, value);
                    },
                    34 => {
                        self.minimum_supported_version = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.is_backward_compatible != false {
                my_size += 1 + 1;
            }
            for value in &self.breaking_changes {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.compatibility_fixes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if !self.minimum_supported_version.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.minimum_supported_version);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.is_backward_compatible != false {
                os.write_bool(1, self.is_backward_compatible)?;
            }
            for v in &self.breaking_changes {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.compatibility_fixes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if !self.minimum_supported_version.is_empty() {
                os.write_string(4, &self.minimum_supported_version)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BackwardCompatibility {
            BackwardCompatibility::new()
        }

        fn clear(&mut self) {
            self.is_backward_compatible = false;
            self.breaking_changes.clear();
            self.compatibility_fixes.clear();
            self.minimum_supported_version.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BackwardCompatibility {
            static instance: ::protobuf::rt::Lazy<BackwardCompatibility> = ::protobuf::rt::Lazy::new();
            instance.get(BackwardCompatibility::new)
        }
    }

    impl ::protobuf::MessageFull for BackwardCompatibility {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SafetyFeatures.BackwardCompatibility").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BackwardCompatibility {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BackwardCompatibility {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures.Interoperability)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Interoperability {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.Interoperability.supported_platforms)
        pub supported_platforms: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.Interoperability.platform_specific_notes)
        pub platform_specific_notes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.Interoperability.known_limitations)
        pub known_limitations: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.Interoperability.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Interoperability {
        fn default() -> &'a Interoperability {
            <Interoperability as ::protobuf::Message>::default_instance()
        }
    }

    impl Interoperability {
        pub fn new() -> Interoperability {
            ::std::default::Default::default()
        }

        // repeated string supported_platforms = 1;

        pub fn supported_platforms(&self) -> &[::std::string::String] {
            &self.supported_platforms
        }

        pub fn clear_supported_platforms(&mut self) {
            self.supported_platforms.clear();
        }

        // Param is passed by value, moved
        pub fn set_supported_platforms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.supported_platforms = v;
        }

        // Mutable pointer to the field.
        pub fn mut_supported_platforms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.supported_platforms
        }

        // Take field
        pub fn take_supported_platforms(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.supported_platforms, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SafetyFeatures.Interoperability.PlatformSpecificNotesEntry platform_specific_notes = 2;

        pub fn platform_specific_notes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.platform_specific_notes
        }

        pub fn clear_platform_specific_notes(&mut self) {
            self.platform_specific_notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_platform_specific_notes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.platform_specific_notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_platform_specific_notes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.platform_specific_notes
        }

        // Take field
        pub fn take_platform_specific_notes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.platform_specific_notes, ::std::collections::HashMap::new())
        }

        // repeated string known_limitations = 3;

        pub fn known_limitations(&self) -> &[::std::string::String] {
            &self.known_limitations
        }

        pub fn clear_known_limitations(&mut self) {
            self.known_limitations.clear();
        }

        // Param is passed by value, moved
        pub fn set_known_limitations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.known_limitations = v;
        }

        // Mutable pointer to the field.
        pub fn mut_known_limitations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.known_limitations
        }

        // Take field
        pub fn take_known_limitations(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.known_limitations, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "supported_platforms",
                |m: &Interoperability| { &m.supported_platforms },
                |m: &mut Interoperability| { &mut m.supported_platforms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "platform_specific_notes",
                |m: &Interoperability| { &m.platform_specific_notes },
                |m: &mut Interoperability| { &mut m.platform_specific_notes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "known_limitations",
                |m: &Interoperability| { &m.known_limitations },
                |m: &mut Interoperability| { &mut m.known_limitations },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Interoperability>(
                "SafetyFeatures.Interoperability",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Interoperability {
        const NAME: &'static str = "Interoperability";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.supported_platforms.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.platform_specific_notes.insert(key, value);
                    },
                    26 => {
                        self.known_limitations.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.supported_platforms {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.platform_specific_notes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.known_limitations {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.supported_platforms {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.platform_specific_notes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.known_limitations {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Interoperability {
            Interoperability::new()
        }

        fn clear(&mut self) {
            self.supported_platforms.clear();
            self.platform_specific_notes.clear();
            self.known_limitations.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Interoperability {
            static instance: ::protobuf::rt::Lazy<Interoperability> = ::protobuf::rt::Lazy::new();
            instance.get(Interoperability::new)
        }
    }

    impl ::protobuf::MessageFull for Interoperability {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SafetyFeatures.Interoperability").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Interoperability {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Interoperability {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Interoperability`
    pub mod interoperability {
        // @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures.Interoperability.CrossLanguageSupport)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CrossLanguageSupport {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.Interoperability.CrossLanguageSupport.source_language)
            pub source_language: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.Interoperability.CrossLanguageSupport.target_language)
            pub target_language: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.Interoperability.CrossLanguageSupport.conversion_rules)
            pub conversion_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.Interoperability.CrossLanguageSupport.edge_cases)
            pub edge_cases: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.Interoperability.CrossLanguageSupport.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CrossLanguageSupport {
            fn default() -> &'a CrossLanguageSupport {
                <CrossLanguageSupport as ::protobuf::Message>::default_instance()
            }
        }

        impl CrossLanguageSupport {
            pub fn new() -> CrossLanguageSupport {
                ::std::default::Default::default()
            }

            // string source_language = 1;

            pub fn source_language(&self) -> &str {
                &self.source_language
            }

            pub fn clear_source_language(&mut self) {
                self.source_language.clear();
            }

            // Param is passed by value, moved
            pub fn set_source_language(&mut self, v: ::std::string::String) {
                self.source_language = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_source_language(&mut self) -> &mut ::std::string::String {
                &mut self.source_language
            }

            // Take field
            pub fn take_source_language(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.source_language, ::std::string::String::new())
            }

            // string target_language = 2;

            pub fn target_language(&self) -> &str {
                &self.target_language
            }

            pub fn clear_target_language(&mut self) {
                self.target_language.clear();
            }

            // Param is passed by value, moved
            pub fn set_target_language(&mut self, v: ::std::string::String) {
                self.target_language = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_target_language(&mut self) -> &mut ::std::string::String {
                &mut self.target_language
            }

            // Take field
            pub fn take_target_language(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.target_language, ::std::string::String::new())
            }

            // repeated string conversion_rules = 3;

            pub fn conversion_rules(&self) -> &[::std::string::String] {
                &self.conversion_rules
            }

            pub fn clear_conversion_rules(&mut self) {
                self.conversion_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_conversion_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.conversion_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_conversion_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.conversion_rules
            }

            // Take field
            pub fn take_conversion_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.conversion_rules, ::std::vec::Vec::new())
            }

            // repeated string edge_cases = 4;

            pub fn edge_cases(&self) -> &[::std::string::String] {
                &self.edge_cases
            }

            pub fn clear_edge_cases(&mut self) {
                self.edge_cases.clear();
            }

            // Param is passed by value, moved
            pub fn set_edge_cases(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.edge_cases = v;
            }

            // Mutable pointer to the field.
            pub fn mut_edge_cases(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.edge_cases
            }

            // Take field
            pub fn take_edge_cases(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.edge_cases, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "source_language",
                    |m: &CrossLanguageSupport| { &m.source_language },
                    |m: &mut CrossLanguageSupport| { &mut m.source_language },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "target_language",
                    |m: &CrossLanguageSupport| { &m.target_language },
                    |m: &mut CrossLanguageSupport| { &mut m.target_language },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "conversion_rules",
                    |m: &CrossLanguageSupport| { &m.conversion_rules },
                    |m: &mut CrossLanguageSupport| { &mut m.conversion_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "edge_cases",
                    |m: &CrossLanguageSupport| { &m.edge_cases },
                    |m: &mut CrossLanguageSupport| { &mut m.edge_cases },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CrossLanguageSupport>(
                    "SafetyFeatures.Interoperability.CrossLanguageSupport",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CrossLanguageSupport {
            const NAME: &'static str = "CrossLanguageSupport";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.source_language = is.read_string()?;
                        },
                        18 => {
                            self.target_language = is.read_string()?;
                        },
                        26 => {
                            self.conversion_rules.push(is.read_string()?);
                        },
                        34 => {
                            self.edge_cases.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.source_language.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.source_language);
                }
                if !self.target_language.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.target_language);
                }
                for value in &self.conversion_rules {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for value in &self.edge_cases {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.source_language.is_empty() {
                    os.write_string(1, &self.source_language)?;
                }
                if !self.target_language.is_empty() {
                    os.write_string(2, &self.target_language)?;
                }
                for v in &self.conversion_rules {
                    os.write_string(3, &v)?;
                };
                for v in &self.edge_cases {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CrossLanguageSupport {
                CrossLanguageSupport::new()
            }

            fn clear(&mut self) {
                self.source_language.clear();
                self.target_language.clear();
                self.conversion_rules.clear();
                self.edge_cases.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CrossLanguageSupport {
                static instance: CrossLanguageSupport = CrossLanguageSupport {
                    source_language: ::std::string::String::new(),
                    target_language: ::std::string::String::new(),
                    conversion_rules: ::std::vec::Vec::new(),
                    edge_cases: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CrossLanguageSupport {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SafetyFeatures.Interoperability.CrossLanguageSupport").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CrossLanguageSupport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CrossLanguageSupport {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures.SecurityImplications)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SecurityImplications {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.SecurityImplications.security_considerations)
        pub security_considerations: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.SecurityImplications.vulnerability_mitigations)
        pub vulnerability_mitigations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.SecurityImplications.security_best_practices)
        pub security_best_practices: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.SecurityImplications.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SecurityImplications {
        fn default() -> &'a SecurityImplications {
            <SecurityImplications as ::protobuf::Message>::default_instance()
        }
    }

    impl SecurityImplications {
        pub fn new() -> SecurityImplications {
            ::std::default::Default::default()
        }

        // repeated string security_considerations = 1;

        pub fn security_considerations(&self) -> &[::std::string::String] {
            &self.security_considerations
        }

        pub fn clear_security_considerations(&mut self) {
            self.security_considerations.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_considerations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.security_considerations = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_considerations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.security_considerations
        }

        // Take field
        pub fn take_security_considerations(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.security_considerations, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SafetyFeatures.SecurityImplications.VulnerabilityMitigationsEntry vulnerability_mitigations = 2;

        pub fn vulnerability_mitigations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.vulnerability_mitigations
        }

        pub fn clear_vulnerability_mitigations(&mut self) {
            self.vulnerability_mitigations.clear();
        }

        // Param is passed by value, moved
        pub fn set_vulnerability_mitigations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.vulnerability_mitigations = v;
        }

        // Mutable pointer to the field.
        pub fn mut_vulnerability_mitigations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.vulnerability_mitigations
        }

        // Take field
        pub fn take_vulnerability_mitigations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.vulnerability_mitigations, ::std::collections::HashMap::new())
        }

        // repeated string security_best_practices = 3;

        pub fn security_best_practices(&self) -> &[::std::string::String] {
            &self.security_best_practices
        }

        pub fn clear_security_best_practices(&mut self) {
            self.security_best_practices.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_best_practices(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.security_best_practices = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_best_practices(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.security_best_practices
        }

        // Take field
        pub fn take_security_best_practices(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.security_best_practices, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "security_considerations",
                |m: &SecurityImplications| { &m.security_considerations },
                |m: &mut SecurityImplications| { &mut m.security_considerations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "vulnerability_mitigations",
                |m: &SecurityImplications| { &m.vulnerability_mitigations },
                |m: &mut SecurityImplications| { &mut m.vulnerability_mitigations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "security_best_practices",
                |m: &SecurityImplications| { &m.security_best_practices },
                |m: &mut SecurityImplications| { &mut m.security_best_practices },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityImplications>(
                "SafetyFeatures.SecurityImplications",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SecurityImplications {
        const NAME: &'static str = "SecurityImplications";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.security_considerations.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.vulnerability_mitigations.insert(key, value);
                    },
                    26 => {
                        self.security_best_practices.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.security_considerations {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.vulnerability_mitigations {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.security_best_practices {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.security_considerations {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.vulnerability_mitigations {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.security_best_practices {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SecurityImplications {
            SecurityImplications::new()
        }

        fn clear(&mut self) {
            self.security_considerations.clear();
            self.vulnerability_mitigations.clear();
            self.security_best_practices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SecurityImplications {
            static instance: ::protobuf::rt::Lazy<SecurityImplications> = ::protobuf::rt::Lazy::new();
            instance.get(SecurityImplications::new)
        }
    }

    impl ::protobuf::MessageFull for SecurityImplications {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SafetyFeatures.SecurityImplications").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SecurityImplications {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SecurityImplications {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SecurityImplications`
    pub mod security_implications {
        // @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures.SecurityImplications.SecurityAudit)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SecurityAudit {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.SecurityImplications.SecurityAudit.last_audit_date)
            pub last_audit_date: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.SecurityImplications.SecurityAudit.auditor)
            pub auditor: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.SecurityImplications.SecurityAudit.findings)
            pub findings: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.SecurityImplications.SecurityAudit.recommendations)
            pub recommendations: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.SecurityImplications.SecurityAudit.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SecurityAudit {
            fn default() -> &'a SecurityAudit {
                <SecurityAudit as ::protobuf::Message>::default_instance()
            }
        }

        impl SecurityAudit {
            pub fn new() -> SecurityAudit {
                ::std::default::Default::default()
            }

            // string last_audit_date = 1;

            pub fn last_audit_date(&self) -> &str {
                &self.last_audit_date
            }

            pub fn clear_last_audit_date(&mut self) {
                self.last_audit_date.clear();
            }

            // Param is passed by value, moved
            pub fn set_last_audit_date(&mut self, v: ::std::string::String) {
                self.last_audit_date = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_last_audit_date(&mut self) -> &mut ::std::string::String {
                &mut self.last_audit_date
            }

            // Take field
            pub fn take_last_audit_date(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.last_audit_date, ::std::string::String::new())
            }

            // string auditor = 2;

            pub fn auditor(&self) -> &str {
                &self.auditor
            }

            pub fn clear_auditor(&mut self) {
                self.auditor.clear();
            }

            // Param is passed by value, moved
            pub fn set_auditor(&mut self, v: ::std::string::String) {
                self.auditor = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_auditor(&mut self) -> &mut ::std::string::String {
                &mut self.auditor
            }

            // Take field
            pub fn take_auditor(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.auditor, ::std::string::String::new())
            }

            // repeated string findings = 3;

            pub fn findings(&self) -> &[::std::string::String] {
                &self.findings
            }

            pub fn clear_findings(&mut self) {
                self.findings.clear();
            }

            // Param is passed by value, moved
            pub fn set_findings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.findings = v;
            }

            // Mutable pointer to the field.
            pub fn mut_findings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.findings
            }

            // Take field
            pub fn take_findings(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.findings, ::std::vec::Vec::new())
            }

            // repeated string recommendations = 4;

            pub fn recommendations(&self) -> &[::std::string::String] {
                &self.recommendations
            }

            pub fn clear_recommendations(&mut self) {
                self.recommendations.clear();
            }

            // Param is passed by value, moved
            pub fn set_recommendations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.recommendations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_recommendations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.recommendations
            }

            // Take field
            pub fn take_recommendations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.recommendations, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "last_audit_date",
                    |m: &SecurityAudit| { &m.last_audit_date },
                    |m: &mut SecurityAudit| { &mut m.last_audit_date },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "auditor",
                    |m: &SecurityAudit| { &m.auditor },
                    |m: &mut SecurityAudit| { &mut m.auditor },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "findings",
                    |m: &SecurityAudit| { &m.findings },
                    |m: &mut SecurityAudit| { &mut m.findings },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "recommendations",
                    |m: &SecurityAudit| { &m.recommendations },
                    |m: &mut SecurityAudit| { &mut m.recommendations },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityAudit>(
                    "SafetyFeatures.SecurityImplications.SecurityAudit",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SecurityAudit {
            const NAME: &'static str = "SecurityAudit";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.last_audit_date = is.read_string()?;
                        },
                        18 => {
                            self.auditor = is.read_string()?;
                        },
                        26 => {
                            self.findings.push(is.read_string()?);
                        },
                        34 => {
                            self.recommendations.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.last_audit_date.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.last_audit_date);
                }
                if !self.auditor.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.auditor);
                }
                for value in &self.findings {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for value in &self.recommendations {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.last_audit_date.is_empty() {
                    os.write_string(1, &self.last_audit_date)?;
                }
                if !self.auditor.is_empty() {
                    os.write_string(2, &self.auditor)?;
                }
                for v in &self.findings {
                    os.write_string(3, &v)?;
                };
                for v in &self.recommendations {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SecurityAudit {
                SecurityAudit::new()
            }

            fn clear(&mut self) {
                self.last_audit_date.clear();
                self.auditor.clear();
                self.findings.clear();
                self.recommendations.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SecurityAudit {
                static instance: SecurityAudit = SecurityAudit {
                    last_audit_date: ::std::string::String::new(),
                    auditor: ::std::string::String::new(),
                    findings: ::std::vec::Vec::new(),
                    recommendations: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SecurityAudit {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SafetyFeatures.SecurityImplications.SecurityAudit").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SecurityAudit {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SecurityAudit {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures.TestingSpecification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestingSpecification {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.TestingSpecification.required_tests)
        pub required_tests: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.TestingSpecification.test_coverage_requirements)
        pub test_coverage_requirements: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.TestingSpecification.edge_cases)
        pub edge_cases: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.TestingSpecification.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestingSpecification {
        fn default() -> &'a TestingSpecification {
            <TestingSpecification as ::protobuf::Message>::default_instance()
        }
    }

    impl TestingSpecification {
        pub fn new() -> TestingSpecification {
            ::std::default::Default::default()
        }

        // repeated string required_tests = 1;

        pub fn required_tests(&self) -> &[::std::string::String] {
            &self.required_tests
        }

        pub fn clear_required_tests(&mut self) {
            self.required_tests.clear();
        }

        // Param is passed by value, moved
        pub fn set_required_tests(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.required_tests = v;
        }

        // Mutable pointer to the field.
        pub fn mut_required_tests(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.required_tests
        }

        // Take field
        pub fn take_required_tests(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.required_tests, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SafetyFeatures.TestingSpecification.TestCoverageRequirementsEntry test_coverage_requirements = 2;

        pub fn test_coverage_requirements(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.test_coverage_requirements
        }

        pub fn clear_test_coverage_requirements(&mut self) {
            self.test_coverage_requirements.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_coverage_requirements(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.test_coverage_requirements = v;
        }

        // Mutable pointer to the field.
        pub fn mut_test_coverage_requirements(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.test_coverage_requirements
        }

        // Take field
        pub fn take_test_coverage_requirements(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.test_coverage_requirements, ::std::collections::HashMap::new())
        }

        // repeated string edge_cases = 3;

        pub fn edge_cases(&self) -> &[::std::string::String] {
            &self.edge_cases
        }

        pub fn clear_edge_cases(&mut self) {
            self.edge_cases.clear();
        }

        // Param is passed by value, moved
        pub fn set_edge_cases(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.edge_cases = v;
        }

        // Mutable pointer to the field.
        pub fn mut_edge_cases(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.edge_cases
        }

        // Take field
        pub fn take_edge_cases(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.edge_cases, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "required_tests",
                |m: &TestingSpecification| { &m.required_tests },
                |m: &mut TestingSpecification| { &mut m.required_tests },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "test_coverage_requirements",
                |m: &TestingSpecification| { &m.test_coverage_requirements },
                |m: &mut TestingSpecification| { &mut m.test_coverage_requirements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "edge_cases",
                |m: &TestingSpecification| { &m.edge_cases },
                |m: &mut TestingSpecification| { &mut m.edge_cases },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestingSpecification>(
                "SafetyFeatures.TestingSpecification",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestingSpecification {
        const NAME: &'static str = "TestingSpecification";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.required_tests.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.test_coverage_requirements.insert(key, value);
                    },
                    26 => {
                        self.edge_cases.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.required_tests {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.test_coverage_requirements {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.edge_cases {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.required_tests {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.test_coverage_requirements {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.edge_cases {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestingSpecification {
            TestingSpecification::new()
        }

        fn clear(&mut self) {
            self.required_tests.clear();
            self.test_coverage_requirements.clear();
            self.edge_cases.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestingSpecification {
            static instance: ::protobuf::rt::Lazy<TestingSpecification> = ::protobuf::rt::Lazy::new();
            instance.get(TestingSpecification::new)
        }
    }

    impl ::protobuf::MessageFull for TestingSpecification {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SafetyFeatures.TestingSpecification").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestingSpecification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestingSpecification {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TestingSpecification`
    pub mod testing_specification {
        // @@protoc_insertion_point(message:kymera_mappings.SafetyFeatures.TestingSpecification.TestCase)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TestCase {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.TestingSpecification.TestCase.test_id)
            pub test_id: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.TestingSpecification.TestCase.description)
            pub description: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.TestingSpecification.TestCase.prerequisites)
            pub prerequisites: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.SafetyFeatures.TestingSpecification.TestCase.expected_results)
            pub expected_results: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.SafetyFeatures.TestingSpecification.TestCase.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TestCase {
            fn default() -> &'a TestCase {
                <TestCase as ::protobuf::Message>::default_instance()
            }
        }

        impl TestCase {
            pub fn new() -> TestCase {
                ::std::default::Default::default()
            }

            // string test_id = 1;

            pub fn test_id(&self) -> &str {
                &self.test_id
            }

            pub fn clear_test_id(&mut self) {
                self.test_id.clear();
            }

            // Param is passed by value, moved
            pub fn set_test_id(&mut self, v: ::std::string::String) {
                self.test_id = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_test_id(&mut self) -> &mut ::std::string::String {
                &mut self.test_id
            }

            // Take field
            pub fn take_test_id(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.test_id, ::std::string::String::new())
            }

            // string description = 2;

            pub fn description(&self) -> &str {
                &self.description
            }

            pub fn clear_description(&mut self) {
                self.description.clear();
            }

            // Param is passed by value, moved
            pub fn set_description(&mut self, v: ::std::string::String) {
                self.description = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_description(&mut self) -> &mut ::std::string::String {
                &mut self.description
            }

            // Take field
            pub fn take_description(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.description, ::std::string::String::new())
            }

            // repeated string prerequisites = 3;

            pub fn prerequisites(&self) -> &[::std::string::String] {
                &self.prerequisites
            }

            pub fn clear_prerequisites(&mut self) {
                self.prerequisites.clear();
            }

            // Param is passed by value, moved
            pub fn set_prerequisites(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.prerequisites = v;
            }

            // Mutable pointer to the field.
            pub fn mut_prerequisites(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.prerequisites
            }

            // Take field
            pub fn take_prerequisites(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.prerequisites, ::std::vec::Vec::new())
            }

            // repeated string expected_results = 4;

            pub fn expected_results(&self) -> &[::std::string::String] {
                &self.expected_results
            }

            pub fn clear_expected_results(&mut self) {
                self.expected_results.clear();
            }

            // Param is passed by value, moved
            pub fn set_expected_results(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.expected_results = v;
            }

            // Mutable pointer to the field.
            pub fn mut_expected_results(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.expected_results
            }

            // Take field
            pub fn take_expected_results(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.expected_results, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "test_id",
                    |m: &TestCase| { &m.test_id },
                    |m: &mut TestCase| { &mut m.test_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "description",
                    |m: &TestCase| { &m.description },
                    |m: &mut TestCase| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "prerequisites",
                    |m: &TestCase| { &m.prerequisites },
                    |m: &mut TestCase| { &mut m.prerequisites },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "expected_results",
                    |m: &TestCase| { &m.expected_results },
                    |m: &mut TestCase| { &mut m.expected_results },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestCase>(
                    "SafetyFeatures.TestingSpecification.TestCase",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TestCase {
            const NAME: &'static str = "TestCase";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.test_id = is.read_string()?;
                        },
                        18 => {
                            self.description = is.read_string()?;
                        },
                        26 => {
                            self.prerequisites.push(is.read_string()?);
                        },
                        34 => {
                            self.expected_results.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.test_id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.test_id);
                }
                if !self.description.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.description);
                }
                for value in &self.prerequisites {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for value in &self.expected_results {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.test_id.is_empty() {
                    os.write_string(1, &self.test_id)?;
                }
                if !self.description.is_empty() {
                    os.write_string(2, &self.description)?;
                }
                for v in &self.prerequisites {
                    os.write_string(3, &v)?;
                };
                for v in &self.expected_results {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TestCase {
                TestCase::new()
            }

            fn clear(&mut self) {
                self.test_id.clear();
                self.description.clear();
                self.prerequisites.clear();
                self.expected_results.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TestCase {
                static instance: TestCase = TestCase {
                    test_id: ::std::string::String::new(),
                    description: ::std::string::String::new(),
                    prerequisites: ::std::vec::Vec::new(),
                    expected_results: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for TestCase {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("SafetyFeatures.TestingSpecification.TestCase").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TestCase {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TestCase {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.PerformanceMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerformanceMetrics {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PerformanceMetrics {
    fn default() -> &'a PerformanceMetrics {
        <PerformanceMetrics as ::protobuf::Message>::default_instance()
    }
}

impl PerformanceMetrics {
    pub fn new() -> PerformanceMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceMetrics>(
            "PerformanceMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PerformanceMetrics {
    const NAME: &'static str = "PerformanceMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PerformanceMetrics {
        PerformanceMetrics::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PerformanceMetrics {
        static instance: PerformanceMetrics = PerformanceMetrics {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PerformanceMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PerformanceMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PerformanceMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerformanceMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PerformanceMetrics`
pub mod performance_metrics {
    // @@protoc_insertion_point(message:kymera_mappings.PerformanceMetrics.RuntimeMetrics)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuntimeMetrics {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.RuntimeMetrics.execution_time_ns)
        pub execution_time_ns: u64,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.RuntimeMetrics.memory_usage_bytes)
        pub memory_usage_bytes: u64,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.RuntimeMetrics.cpu_utilization)
        pub cpu_utilization: f64,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.RuntimeMetrics.thread_count)
        pub thread_count: u32,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.RuntimeMetrics.peak_memory_usage)
        pub peak_memory_usage: u64,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.RuntimeMetrics.average_latency_ms)
        pub average_latency_ms: f64,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceMetrics.RuntimeMetrics.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuntimeMetrics {
        fn default() -> &'a RuntimeMetrics {
            <RuntimeMetrics as ::protobuf::Message>::default_instance()
        }
    }

    impl RuntimeMetrics {
        pub fn new() -> RuntimeMetrics {
            ::std::default::Default::default()
        }

        // uint64 execution_time_ns = 1;

        pub fn execution_time_ns(&self) -> u64 {
            self.execution_time_ns
        }

        pub fn clear_execution_time_ns(&mut self) {
            self.execution_time_ns = 0;
        }

        // Param is passed by value, moved
        pub fn set_execution_time_ns(&mut self, v: u64) {
            self.execution_time_ns = v;
        }

        // uint64 memory_usage_bytes = 2;

        pub fn memory_usage_bytes(&self) -> u64 {
            self.memory_usage_bytes
        }

        pub fn clear_memory_usage_bytes(&mut self) {
            self.memory_usage_bytes = 0;
        }

        // Param is passed by value, moved
        pub fn set_memory_usage_bytes(&mut self, v: u64) {
            self.memory_usage_bytes = v;
        }

        // double cpu_utilization = 3;

        pub fn cpu_utilization(&self) -> f64 {
            self.cpu_utilization
        }

        pub fn clear_cpu_utilization(&mut self) {
            self.cpu_utilization = 0.;
        }

        // Param is passed by value, moved
        pub fn set_cpu_utilization(&mut self, v: f64) {
            self.cpu_utilization = v;
        }

        // uint32 thread_count = 4;

        pub fn thread_count(&self) -> u32 {
            self.thread_count
        }

        pub fn clear_thread_count(&mut self) {
            self.thread_count = 0;
        }

        // Param is passed by value, moved
        pub fn set_thread_count(&mut self, v: u32) {
            self.thread_count = v;
        }

        // uint64 peak_memory_usage = 5;

        pub fn peak_memory_usage(&self) -> u64 {
            self.peak_memory_usage
        }

        pub fn clear_peak_memory_usage(&mut self) {
            self.peak_memory_usage = 0;
        }

        // Param is passed by value, moved
        pub fn set_peak_memory_usage(&mut self, v: u64) {
            self.peak_memory_usage = v;
        }

        // double average_latency_ms = 6;

        pub fn average_latency_ms(&self) -> f64 {
            self.average_latency_ms
        }

        pub fn clear_average_latency_ms(&mut self) {
            self.average_latency_ms = 0.;
        }

        // Param is passed by value, moved
        pub fn set_average_latency_ms(&mut self, v: f64) {
            self.average_latency_ms = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "execution_time_ns",
                |m: &RuntimeMetrics| { &m.execution_time_ns },
                |m: &mut RuntimeMetrics| { &mut m.execution_time_ns },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "memory_usage_bytes",
                |m: &RuntimeMetrics| { &m.memory_usage_bytes },
                |m: &mut RuntimeMetrics| { &mut m.memory_usage_bytes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "cpu_utilization",
                |m: &RuntimeMetrics| { &m.cpu_utilization },
                |m: &mut RuntimeMetrics| { &mut m.cpu_utilization },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "thread_count",
                |m: &RuntimeMetrics| { &m.thread_count },
                |m: &mut RuntimeMetrics| { &mut m.thread_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "peak_memory_usage",
                |m: &RuntimeMetrics| { &m.peak_memory_usage },
                |m: &mut RuntimeMetrics| { &mut m.peak_memory_usage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "average_latency_ms",
                |m: &RuntimeMetrics| { &m.average_latency_ms },
                |m: &mut RuntimeMetrics| { &mut m.average_latency_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeMetrics>(
                "PerformanceMetrics.RuntimeMetrics",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuntimeMetrics {
        const NAME: &'static str = "RuntimeMetrics";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.execution_time_ns = is.read_uint64()?;
                    },
                    16 => {
                        self.memory_usage_bytes = is.read_uint64()?;
                    },
                    25 => {
                        self.cpu_utilization = is.read_double()?;
                    },
                    32 => {
                        self.thread_count = is.read_uint32()?;
                    },
                    40 => {
                        self.peak_memory_usage = is.read_uint64()?;
                    },
                    49 => {
                        self.average_latency_ms = is.read_double()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.execution_time_ns != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.execution_time_ns);
            }
            if self.memory_usage_bytes != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.memory_usage_bytes);
            }
            if self.cpu_utilization != 0. {
                my_size += 1 + 8;
            }
            if self.thread_count != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.thread_count);
            }
            if self.peak_memory_usage != 0 {
                my_size += ::protobuf::rt::uint64_size(5, self.peak_memory_usage);
            }
            if self.average_latency_ms != 0. {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.execution_time_ns != 0 {
                os.write_uint64(1, self.execution_time_ns)?;
            }
            if self.memory_usage_bytes != 0 {
                os.write_uint64(2, self.memory_usage_bytes)?;
            }
            if self.cpu_utilization != 0. {
                os.write_double(3, self.cpu_utilization)?;
            }
            if self.thread_count != 0 {
                os.write_uint32(4, self.thread_count)?;
            }
            if self.peak_memory_usage != 0 {
                os.write_uint64(5, self.peak_memory_usage)?;
            }
            if self.average_latency_ms != 0. {
                os.write_double(6, self.average_latency_ms)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuntimeMetrics {
            RuntimeMetrics::new()
        }

        fn clear(&mut self) {
            self.execution_time_ns = 0;
            self.memory_usage_bytes = 0;
            self.cpu_utilization = 0.;
            self.thread_count = 0;
            self.peak_memory_usage = 0;
            self.average_latency_ms = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuntimeMetrics {
            static instance: RuntimeMetrics = RuntimeMetrics {
                execution_time_ns: 0,
                memory_usage_bytes: 0,
                cpu_utilization: 0.,
                thread_count: 0,
                peak_memory_usage: 0,
                average_latency_ms: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RuntimeMetrics {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PerformanceMetrics.RuntimeMetrics").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuntimeMetrics {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuntimeMetrics {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.PerformanceMetrics.ResourceUsage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ResourceUsage {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.ResourceUsage.stack_size)
        pub stack_size: u64,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.ResourceUsage.heap_size)
        pub heap_size: u64,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.ResourceUsage.file_descriptors)
        pub file_descriptors: u32,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.ResourceUsage.network_connections)
        pub network_connections: u32,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.ResourceUsage.custom_metrics)
        pub custom_metrics: ::std::collections::HashMap<::std::string::String, u64>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceMetrics.ResourceUsage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ResourceUsage {
        fn default() -> &'a ResourceUsage {
            <ResourceUsage as ::protobuf::Message>::default_instance()
        }
    }

    impl ResourceUsage {
        pub fn new() -> ResourceUsage {
            ::std::default::Default::default()
        }

        // uint64 stack_size = 1;

        pub fn stack_size(&self) -> u64 {
            self.stack_size
        }

        pub fn clear_stack_size(&mut self) {
            self.stack_size = 0;
        }

        // Param is passed by value, moved
        pub fn set_stack_size(&mut self, v: u64) {
            self.stack_size = v;
        }

        // uint64 heap_size = 2;

        pub fn heap_size(&self) -> u64 {
            self.heap_size
        }

        pub fn clear_heap_size(&mut self) {
            self.heap_size = 0;
        }

        // Param is passed by value, moved
        pub fn set_heap_size(&mut self, v: u64) {
            self.heap_size = v;
        }

        // uint32 file_descriptors = 3;

        pub fn file_descriptors(&self) -> u32 {
            self.file_descriptors
        }

        pub fn clear_file_descriptors(&mut self) {
            self.file_descriptors = 0;
        }

        // Param is passed by value, moved
        pub fn set_file_descriptors(&mut self, v: u32) {
            self.file_descriptors = v;
        }

        // uint32 network_connections = 4;

        pub fn network_connections(&self) -> u32 {
            self.network_connections
        }

        pub fn clear_network_connections(&mut self) {
            self.network_connections = 0;
        }

        // Param is passed by value, moved
        pub fn set_network_connections(&mut self, v: u32) {
            self.network_connections = v;
        }

        // repeated .kymera_mappings.PerformanceMetrics.ResourceUsage.CustomMetricsEntry custom_metrics = 5;

        pub fn custom_metrics(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
            &self.custom_metrics
        }

        pub fn clear_custom_metrics(&mut self) {
            self.custom_metrics.clear();
        }

        // Param is passed by value, moved
        pub fn set_custom_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
            self.custom_metrics = v;
        }

        // Mutable pointer to the field.
        pub fn mut_custom_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
            &mut self.custom_metrics
        }

        // Take field
        pub fn take_custom_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
            ::std::mem::replace(&mut self.custom_metrics, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "stack_size",
                |m: &ResourceUsage| { &m.stack_size },
                |m: &mut ResourceUsage| { &mut m.stack_size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "heap_size",
                |m: &ResourceUsage| { &m.heap_size },
                |m: &mut ResourceUsage| { &mut m.heap_size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "file_descriptors",
                |m: &ResourceUsage| { &m.file_descriptors },
                |m: &mut ResourceUsage| { &mut m.file_descriptors },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "network_connections",
                |m: &ResourceUsage| { &m.network_connections },
                |m: &mut ResourceUsage| { &mut m.network_connections },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "custom_metrics",
                |m: &ResourceUsage| { &m.custom_metrics },
                |m: &mut ResourceUsage| { &mut m.custom_metrics },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ResourceUsage>(
                "PerformanceMetrics.ResourceUsage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ResourceUsage {
        const NAME: &'static str = "ResourceUsage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stack_size = is.read_uint64()?;
                    },
                    16 => {
                        self.heap_size = is.read_uint64()?;
                    },
                    24 => {
                        self.file_descriptors = is.read_uint32()?;
                    },
                    32 => {
                        self.network_connections = is.read_uint32()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                16 => value = is.read_uint64()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.custom_metrics.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.stack_size != 0 {
                my_size += ::protobuf::rt::uint64_size(1, self.stack_size);
            }
            if self.heap_size != 0 {
                my_size += ::protobuf::rt::uint64_size(2, self.heap_size);
            }
            if self.file_descriptors != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.file_descriptors);
            }
            if self.network_connections != 0 {
                my_size += ::protobuf::rt::uint32_size(4, self.network_connections);
            }
            for (k, v) in &self.custom_metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::uint64_size(2, *v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.stack_size != 0 {
                os.write_uint64(1, self.stack_size)?;
            }
            if self.heap_size != 0 {
                os.write_uint64(2, self.heap_size)?;
            }
            if self.file_descriptors != 0 {
                os.write_uint32(3, self.file_descriptors)?;
            }
            if self.network_connections != 0 {
                os.write_uint32(4, self.network_connections)?;
            }
            for (k, v) in &self.custom_metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::uint64_size(2, *v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_uint64(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ResourceUsage {
            ResourceUsage::new()
        }

        fn clear(&mut self) {
            self.stack_size = 0;
            self.heap_size = 0;
            self.file_descriptors = 0;
            self.network_connections = 0;
            self.custom_metrics.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ResourceUsage {
            static instance: ::protobuf::rt::Lazy<ResourceUsage> = ::protobuf::rt::Lazy::new();
            instance.get(ResourceUsage::new)
        }
    }

    impl ::protobuf::MessageFull for ResourceUsage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PerformanceMetrics.ResourceUsage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ResourceUsage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ResourceUsage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.PerformanceMetrics.PerformanceProfile)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PerformanceProfile {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.PerformanceProfile.hotspots)
        pub hotspots: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.PerformanceProfile.optimization_targets)
        pub optimization_targets: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.PerformanceProfile.benchmarks)
        pub benchmarks: ::std::collections::HashMap<::std::string::String, f64>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceMetrics.PerformanceProfile.performance_notes)
        pub performance_notes: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceMetrics.PerformanceProfile.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PerformanceProfile {
        fn default() -> &'a PerformanceProfile {
            <PerformanceProfile as ::protobuf::Message>::default_instance()
        }
    }

    impl PerformanceProfile {
        pub fn new() -> PerformanceProfile {
            ::std::default::Default::default()
        }

        // repeated string hotspots = 1;

        pub fn hotspots(&self) -> &[::std::string::String] {
            &self.hotspots
        }

        pub fn clear_hotspots(&mut self) {
            self.hotspots.clear();
        }

        // Param is passed by value, moved
        pub fn set_hotspots(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.hotspots = v;
        }

        // Mutable pointer to the field.
        pub fn mut_hotspots(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.hotspots
        }

        // Take field
        pub fn take_hotspots(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.hotspots, ::std::vec::Vec::new())
        }

        // repeated string optimization_targets = 2;

        pub fn optimization_targets(&self) -> &[::std::string::String] {
            &self.optimization_targets
        }

        pub fn clear_optimization_targets(&mut self) {
            self.optimization_targets.clear();
        }

        // Param is passed by value, moved
        pub fn set_optimization_targets(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.optimization_targets = v;
        }

        // Mutable pointer to the field.
        pub fn mut_optimization_targets(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.optimization_targets
        }

        // Take field
        pub fn take_optimization_targets(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.optimization_targets, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.PerformanceMetrics.PerformanceProfile.BenchmarksEntry benchmarks = 3;

        pub fn benchmarks(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
            &self.benchmarks
        }

        pub fn clear_benchmarks(&mut self) {
            self.benchmarks.clear();
        }

        // Param is passed by value, moved
        pub fn set_benchmarks(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
            self.benchmarks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_benchmarks(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
            &mut self.benchmarks
        }

        // Take field
        pub fn take_benchmarks(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
            ::std::mem::replace(&mut self.benchmarks, ::std::collections::HashMap::new())
        }

        // repeated string performance_notes = 4;

        pub fn performance_notes(&self) -> &[::std::string::String] {
            &self.performance_notes
        }

        pub fn clear_performance_notes(&mut self) {
            self.performance_notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_performance_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.performance_notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_performance_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.performance_notes
        }

        // Take field
        pub fn take_performance_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.performance_notes, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hotspots",
                |m: &PerformanceProfile| { &m.hotspots },
                |m: &mut PerformanceProfile| { &mut m.hotspots },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "optimization_targets",
                |m: &PerformanceProfile| { &m.optimization_targets },
                |m: &mut PerformanceProfile| { &mut m.optimization_targets },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "benchmarks",
                |m: &PerformanceProfile| { &m.benchmarks },
                |m: &mut PerformanceProfile| { &mut m.benchmarks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "performance_notes",
                |m: &PerformanceProfile| { &m.performance_notes },
                |m: &mut PerformanceProfile| { &mut m.performance_notes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceProfile>(
                "PerformanceMetrics.PerformanceProfile",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PerformanceProfile {
        const NAME: &'static str = "PerformanceProfile";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.hotspots.push(is.read_string()?);
                    },
                    18 => {
                        self.optimization_targets.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                17 => value = is.read_double()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.benchmarks.insert(key, value);
                    },
                    34 => {
                        self.performance_notes.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.hotspots {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for value in &self.optimization_targets {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.benchmarks {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.performance_notes {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.hotspots {
                os.write_string(1, &v)?;
            };
            for v in &self.optimization_targets {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.benchmarks {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_double(2, *v)?;
            };
            for v in &self.performance_notes {
                os.write_string(4, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PerformanceProfile {
            PerformanceProfile::new()
        }

        fn clear(&mut self) {
            self.hotspots.clear();
            self.optimization_targets.clear();
            self.benchmarks.clear();
            self.performance_notes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PerformanceProfile {
            static instance: ::protobuf::rt::Lazy<PerformanceProfile> = ::protobuf::rt::Lazy::new();
            instance.get(PerformanceProfile::new)
        }
    }

    impl ::protobuf::MessageFull for PerformanceProfile {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PerformanceMetrics.PerformanceProfile").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PerformanceProfile {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PerformanceProfile {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.SecurityFeatures)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecurityFeatures {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.SecurityFeatures.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecurityFeatures {
    fn default() -> &'a SecurityFeatures {
        <SecurityFeatures as ::protobuf::Message>::default_instance()
    }
}

impl SecurityFeatures {
    pub fn new() -> SecurityFeatures {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityFeatures>(
            "SecurityFeatures",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecurityFeatures {
    const NAME: &'static str = "SecurityFeatures";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecurityFeatures {
        SecurityFeatures::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecurityFeatures {
        static instance: SecurityFeatures = SecurityFeatures {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecurityFeatures {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecurityFeatures").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecurityFeatures {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityFeatures {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SecurityFeatures`
pub mod security_features {
    // @@protoc_insertion_point(message:kymera_mappings.SecurityFeatures.SecurityCheck)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SecurityCheck {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityCheck.vulnerability_checks)
        pub vulnerability_checks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityCheck.security_policies)
        pub security_policies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityCheck.requires_audit)
        pub requires_audit: bool,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityCheck.compliance_requirements)
        pub compliance_requirements: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityCheck.security_level)
        pub security_level: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityFeatures.SecurityCheck.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SecurityCheck {
        fn default() -> &'a SecurityCheck {
            <SecurityCheck as ::protobuf::Message>::default_instance()
        }
    }

    impl SecurityCheck {
        pub fn new() -> SecurityCheck {
            ::std::default::Default::default()
        }

        // repeated string vulnerability_checks = 1;

        pub fn vulnerability_checks(&self) -> &[::std::string::String] {
            &self.vulnerability_checks
        }

        pub fn clear_vulnerability_checks(&mut self) {
            self.vulnerability_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_vulnerability_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.vulnerability_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_vulnerability_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.vulnerability_checks
        }

        // Take field
        pub fn take_vulnerability_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.vulnerability_checks, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SecurityFeatures.SecurityCheck.SecurityPoliciesEntry security_policies = 2;

        pub fn security_policies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.security_policies
        }

        pub fn clear_security_policies(&mut self) {
            self.security_policies.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.security_policies = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.security_policies
        }

        // Take field
        pub fn take_security_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.security_policies, ::std::collections::HashMap::new())
        }

        // bool requires_audit = 3;

        pub fn requires_audit(&self) -> bool {
            self.requires_audit
        }

        pub fn clear_requires_audit(&mut self) {
            self.requires_audit = false;
        }

        // Param is passed by value, moved
        pub fn set_requires_audit(&mut self, v: bool) {
            self.requires_audit = v;
        }

        // repeated string compliance_requirements = 4;

        pub fn compliance_requirements(&self) -> &[::std::string::String] {
            &self.compliance_requirements
        }

        pub fn clear_compliance_requirements(&mut self) {
            self.compliance_requirements.clear();
        }

        // Param is passed by value, moved
        pub fn set_compliance_requirements(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.compliance_requirements = v;
        }

        // Mutable pointer to the field.
        pub fn mut_compliance_requirements(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.compliance_requirements
        }

        // Take field
        pub fn take_compliance_requirements(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.compliance_requirements, ::std::vec::Vec::new())
        }

        // string security_level = 5;

        pub fn security_level(&self) -> &str {
            &self.security_level
        }

        pub fn clear_security_level(&mut self) {
            self.security_level.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_level(&mut self, v: ::std::string::String) {
            self.security_level = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_security_level(&mut self) -> &mut ::std::string::String {
            &mut self.security_level
        }

        // Take field
        pub fn take_security_level(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.security_level, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "vulnerability_checks",
                |m: &SecurityCheck| { &m.vulnerability_checks },
                |m: &mut SecurityCheck| { &mut m.vulnerability_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "security_policies",
                |m: &SecurityCheck| { &m.security_policies },
                |m: &mut SecurityCheck| { &mut m.security_policies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "requires_audit",
                |m: &SecurityCheck| { &m.requires_audit },
                |m: &mut SecurityCheck| { &mut m.requires_audit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "compliance_requirements",
                |m: &SecurityCheck| { &m.compliance_requirements },
                |m: &mut SecurityCheck| { &mut m.compliance_requirements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "security_level",
                |m: &SecurityCheck| { &m.security_level },
                |m: &mut SecurityCheck| { &mut m.security_level },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityCheck>(
                "SecurityFeatures.SecurityCheck",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SecurityCheck {
        const NAME: &'static str = "SecurityCheck";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.vulnerability_checks.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.security_policies.insert(key, value);
                    },
                    24 => {
                        self.requires_audit = is.read_bool()?;
                    },
                    34 => {
                        self.compliance_requirements.push(is.read_string()?);
                    },
                    42 => {
                        self.security_level = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.vulnerability_checks {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.security_policies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.requires_audit != false {
                my_size += 1 + 1;
            }
            for value in &self.compliance_requirements {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            if !self.security_level.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.security_level);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.vulnerability_checks {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.security_policies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.requires_audit != false {
                os.write_bool(3, self.requires_audit)?;
            }
            for v in &self.compliance_requirements {
                os.write_string(4, &v)?;
            };
            if !self.security_level.is_empty() {
                os.write_string(5, &self.security_level)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SecurityCheck {
            SecurityCheck::new()
        }

        fn clear(&mut self) {
            self.vulnerability_checks.clear();
            self.security_policies.clear();
            self.requires_audit = false;
            self.compliance_requirements.clear();
            self.security_level.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SecurityCheck {
            static instance: ::protobuf::rt::Lazy<SecurityCheck> = ::protobuf::rt::Lazy::new();
            instance.get(SecurityCheck::new)
        }
    }

    impl ::protobuf::MessageFull for SecurityCheck {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityFeatures.SecurityCheck").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SecurityCheck {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SecurityCheck {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.SecurityFeatures.SecurityAudit)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SecurityAudit {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityAudit.audit_id)
        pub audit_id: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityAudit.auditor)
        pub auditor: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityAudit.audit_date)
        pub audit_date: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityAudit.findings)
        pub findings: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityAudit.recommendations)
        pub recommendations: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityAudit.passed_audit)
        pub passed_audit: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityFeatures.SecurityAudit.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SecurityAudit {
        fn default() -> &'a SecurityAudit {
            <SecurityAudit as ::protobuf::Message>::default_instance()
        }
    }

    impl SecurityAudit {
        pub fn new() -> SecurityAudit {
            ::std::default::Default::default()
        }

        // string audit_id = 1;

        pub fn audit_id(&self) -> &str {
            &self.audit_id
        }

        pub fn clear_audit_id(&mut self) {
            self.audit_id.clear();
        }

        // Param is passed by value, moved
        pub fn set_audit_id(&mut self, v: ::std::string::String) {
            self.audit_id = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_audit_id(&mut self) -> &mut ::std::string::String {
            &mut self.audit_id
        }

        // Take field
        pub fn take_audit_id(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.audit_id, ::std::string::String::new())
        }

        // string auditor = 2;

        pub fn auditor(&self) -> &str {
            &self.auditor
        }

        pub fn clear_auditor(&mut self) {
            self.auditor.clear();
        }

        // Param is passed by value, moved
        pub fn set_auditor(&mut self, v: ::std::string::String) {
            self.auditor = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_auditor(&mut self) -> &mut ::std::string::String {
            &mut self.auditor
        }

        // Take field
        pub fn take_auditor(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.auditor, ::std::string::String::new())
        }

        // string audit_date = 3;

        pub fn audit_date(&self) -> &str {
            &self.audit_date
        }

        pub fn clear_audit_date(&mut self) {
            self.audit_date.clear();
        }

        // Param is passed by value, moved
        pub fn set_audit_date(&mut self, v: ::std::string::String) {
            self.audit_date = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_audit_date(&mut self) -> &mut ::std::string::String {
            &mut self.audit_date
        }

        // Take field
        pub fn take_audit_date(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.audit_date, ::std::string::String::new())
        }

        // repeated string findings = 4;

        pub fn findings(&self) -> &[::std::string::String] {
            &self.findings
        }

        pub fn clear_findings(&mut self) {
            self.findings.clear();
        }

        // Param is passed by value, moved
        pub fn set_findings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.findings = v;
        }

        // Mutable pointer to the field.
        pub fn mut_findings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.findings
        }

        // Take field
        pub fn take_findings(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.findings, ::std::vec::Vec::new())
        }

        // repeated string recommendations = 5;

        pub fn recommendations(&self) -> &[::std::string::String] {
            &self.recommendations
        }

        pub fn clear_recommendations(&mut self) {
            self.recommendations.clear();
        }

        // Param is passed by value, moved
        pub fn set_recommendations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.recommendations = v;
        }

        // Mutable pointer to the field.
        pub fn mut_recommendations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.recommendations
        }

        // Take field
        pub fn take_recommendations(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.recommendations, ::std::vec::Vec::new())
        }

        // bool passed_audit = 6;

        pub fn passed_audit(&self) -> bool {
            self.passed_audit
        }

        pub fn clear_passed_audit(&mut self) {
            self.passed_audit = false;
        }

        // Param is passed by value, moved
        pub fn set_passed_audit(&mut self, v: bool) {
            self.passed_audit = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "audit_id",
                |m: &SecurityAudit| { &m.audit_id },
                |m: &mut SecurityAudit| { &mut m.audit_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "auditor",
                |m: &SecurityAudit| { &m.auditor },
                |m: &mut SecurityAudit| { &mut m.auditor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "audit_date",
                |m: &SecurityAudit| { &m.audit_date },
                |m: &mut SecurityAudit| { &mut m.audit_date },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "findings",
                |m: &SecurityAudit| { &m.findings },
                |m: &mut SecurityAudit| { &mut m.findings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "recommendations",
                |m: &SecurityAudit| { &m.recommendations },
                |m: &mut SecurityAudit| { &mut m.recommendations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "passed_audit",
                |m: &SecurityAudit| { &m.passed_audit },
                |m: &mut SecurityAudit| { &mut m.passed_audit },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityAudit>(
                "SecurityFeatures.SecurityAudit",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SecurityAudit {
        const NAME: &'static str = "SecurityAudit";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.audit_id = is.read_string()?;
                    },
                    18 => {
                        self.auditor = is.read_string()?;
                    },
                    26 => {
                        self.audit_date = is.read_string()?;
                    },
                    34 => {
                        self.findings.push(is.read_string()?);
                    },
                    42 => {
                        self.recommendations.push(is.read_string()?);
                    },
                    48 => {
                        self.passed_audit = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.audit_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.audit_id);
            }
            if !self.auditor.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.auditor);
            }
            if !self.audit_date.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.audit_date);
            }
            for value in &self.findings {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.recommendations {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            if self.passed_audit != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.audit_id.is_empty() {
                os.write_string(1, &self.audit_id)?;
            }
            if !self.auditor.is_empty() {
                os.write_string(2, &self.auditor)?;
            }
            if !self.audit_date.is_empty() {
                os.write_string(3, &self.audit_date)?;
            }
            for v in &self.findings {
                os.write_string(4, &v)?;
            };
            for v in &self.recommendations {
                os.write_string(5, &v)?;
            };
            if self.passed_audit != false {
                os.write_bool(6, self.passed_audit)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SecurityAudit {
            SecurityAudit::new()
        }

        fn clear(&mut self) {
            self.audit_id.clear();
            self.auditor.clear();
            self.audit_date.clear();
            self.findings.clear();
            self.recommendations.clear();
            self.passed_audit = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SecurityAudit {
            static instance: SecurityAudit = SecurityAudit {
                audit_id: ::std::string::String::new(),
                auditor: ::std::string::String::new(),
                audit_date: ::std::string::String::new(),
                findings: ::std::vec::Vec::new(),
                recommendations: ::std::vec::Vec::new(),
                passed_audit: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SecurityAudit {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityFeatures.SecurityAudit").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SecurityAudit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SecurityAudit {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.SecurityFeatures.SecurityPolicy)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SecurityPolicy {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityPolicy.policy_id)
        pub policy_id: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityPolicy.policy_name)
        pub policy_name: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityPolicy.description)
        pub description: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityPolicy.requirements)
        pub requirements: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityPolicy.enforcement_rules)
        pub enforcement_rules: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityFeatures.SecurityPolicy.mandatory)
        pub mandatory: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityFeatures.SecurityPolicy.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SecurityPolicy {
        fn default() -> &'a SecurityPolicy {
            <SecurityPolicy as ::protobuf::Message>::default_instance()
        }
    }

    impl SecurityPolicy {
        pub fn new() -> SecurityPolicy {
            ::std::default::Default::default()
        }

        // string policy_id = 1;

        pub fn policy_id(&self) -> &str {
            &self.policy_id
        }

        pub fn clear_policy_id(&mut self) {
            self.policy_id.clear();
        }

        // Param is passed by value, moved
        pub fn set_policy_id(&mut self, v: ::std::string::String) {
            self.policy_id = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_policy_id(&mut self) -> &mut ::std::string::String {
            &mut self.policy_id
        }

        // Take field
        pub fn take_policy_id(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.policy_id, ::std::string::String::new())
        }

        // string policy_name = 2;

        pub fn policy_name(&self) -> &str {
            &self.policy_name
        }

        pub fn clear_policy_name(&mut self) {
            self.policy_name.clear();
        }

        // Param is passed by value, moved
        pub fn set_policy_name(&mut self, v: ::std::string::String) {
            self.policy_name = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_policy_name(&mut self) -> &mut ::std::string::String {
            &mut self.policy_name
        }

        // Take field
        pub fn take_policy_name(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.policy_name, ::std::string::String::new())
        }

        // string description = 3;

        pub fn description(&self) -> &str {
            &self.description
        }

        pub fn clear_description(&mut self) {
            self.description.clear();
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            &mut self.description
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.description, ::std::string::String::new())
        }

        // repeated string requirements = 4;

        pub fn requirements(&self) -> &[::std::string::String] {
            &self.requirements
        }

        pub fn clear_requirements(&mut self) {
            self.requirements.clear();
        }

        // Param is passed by value, moved
        pub fn set_requirements(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.requirements = v;
        }

        // Mutable pointer to the field.
        pub fn mut_requirements(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.requirements
        }

        // Take field
        pub fn take_requirements(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.requirements, ::std::vec::Vec::new())
        }

        // repeated string enforcement_rules = 5;

        pub fn enforcement_rules(&self) -> &[::std::string::String] {
            &self.enforcement_rules
        }

        pub fn clear_enforcement_rules(&mut self) {
            self.enforcement_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_enforcement_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.enforcement_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_enforcement_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.enforcement_rules
        }

        // Take field
        pub fn take_enforcement_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.enforcement_rules, ::std::vec::Vec::new())
        }

        // bool mandatory = 6;

        pub fn mandatory(&self) -> bool {
            self.mandatory
        }

        pub fn clear_mandatory(&mut self) {
            self.mandatory = false;
        }

        // Param is passed by value, moved
        pub fn set_mandatory(&mut self, v: bool) {
            self.mandatory = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "policy_id",
                |m: &SecurityPolicy| { &m.policy_id },
                |m: &mut SecurityPolicy| { &mut m.policy_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "policy_name",
                |m: &SecurityPolicy| { &m.policy_name },
                |m: &mut SecurityPolicy| { &mut m.policy_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "description",
                |m: &SecurityPolicy| { &m.description },
                |m: &mut SecurityPolicy| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "requirements",
                |m: &SecurityPolicy| { &m.requirements },
                |m: &mut SecurityPolicy| { &mut m.requirements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "enforcement_rules",
                |m: &SecurityPolicy| { &m.enforcement_rules },
                |m: &mut SecurityPolicy| { &mut m.enforcement_rules },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "mandatory",
                |m: &SecurityPolicy| { &m.mandatory },
                |m: &mut SecurityPolicy| { &mut m.mandatory },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityPolicy>(
                "SecurityFeatures.SecurityPolicy",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SecurityPolicy {
        const NAME: &'static str = "SecurityPolicy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.policy_id = is.read_string()?;
                    },
                    18 => {
                        self.policy_name = is.read_string()?;
                    },
                    26 => {
                        self.description = is.read_string()?;
                    },
                    34 => {
                        self.requirements.push(is.read_string()?);
                    },
                    42 => {
                        self.enforcement_rules.push(is.read_string()?);
                    },
                    48 => {
                        self.mandatory = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.policy_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.policy_id);
            }
            if !self.policy_name.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.policy_name);
            }
            if !self.description.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.description);
            }
            for value in &self.requirements {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for value in &self.enforcement_rules {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            if self.mandatory != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.policy_id.is_empty() {
                os.write_string(1, &self.policy_id)?;
            }
            if !self.policy_name.is_empty() {
                os.write_string(2, &self.policy_name)?;
            }
            if !self.description.is_empty() {
                os.write_string(3, &self.description)?;
            }
            for v in &self.requirements {
                os.write_string(4, &v)?;
            };
            for v in &self.enforcement_rules {
                os.write_string(5, &v)?;
            };
            if self.mandatory != false {
                os.write_bool(6, self.mandatory)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SecurityPolicy {
            SecurityPolicy::new()
        }

        fn clear(&mut self) {
            self.policy_id.clear();
            self.policy_name.clear();
            self.description.clear();
            self.requirements.clear();
            self.enforcement_rules.clear();
            self.mandatory = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SecurityPolicy {
            static instance: SecurityPolicy = SecurityPolicy {
                policy_id: ::std::string::String::new(),
                policy_name: ::std::string::String::new(),
                description: ::std::string::String::new(),
                requirements: ::std::vec::Vec::new(),
                enforcement_rules: ::std::vec::Vec::new(),
                mandatory: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SecurityPolicy {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityFeatures.SecurityPolicy").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SecurityPolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SecurityPolicy {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.TestingSuite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TestingSuite {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.TestingSuite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestingSuite {
    fn default() -> &'a TestingSuite {
        <TestingSuite as ::protobuf::Message>::default_instance()
    }
}

impl TestingSuite {
    pub fn new() -> TestingSuite {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestingSuite>(
            "TestingSuite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestingSuite {
    const NAME: &'static str = "TestingSuite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestingSuite {
        TestingSuite::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestingSuite {
        static instance: TestingSuite = TestingSuite {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TestingSuite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestingSuite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestingSuite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestingSuite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TestingSuite`
pub mod testing_suite {
    // @@protoc_insertion_point(message:kymera_mappings.TestingSuite.TestDefinition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestDefinition {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestDefinition.test_name)
        pub test_name: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestDefinition.test_cases)
        pub test_cases: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestDefinition.expected_results)
        pub expected_results: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestDefinition.prerequisites)
        pub prerequisites: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestDefinition.automated)
        pub automated: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.TestingSuite.TestDefinition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestDefinition {
        fn default() -> &'a TestDefinition {
            <TestDefinition as ::protobuf::Message>::default_instance()
        }
    }

    impl TestDefinition {
        pub fn new() -> TestDefinition {
            ::std::default::Default::default()
        }

        // string test_name = 1;

        pub fn test_name(&self) -> &str {
            &self.test_name
        }

        pub fn clear_test_name(&mut self) {
            self.test_name.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_name(&mut self, v: ::std::string::String) {
            self.test_name = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_test_name(&mut self) -> &mut ::std::string::String {
            &mut self.test_name
        }

        // Take field
        pub fn take_test_name(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.test_name, ::std::string::String::new())
        }

        // repeated string test_cases = 2;

        pub fn test_cases(&self) -> &[::std::string::String] {
            &self.test_cases
        }

        pub fn clear_test_cases(&mut self) {
            self.test_cases.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_cases(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.test_cases = v;
        }

        // Mutable pointer to the field.
        pub fn mut_test_cases(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.test_cases
        }

        // Take field
        pub fn take_test_cases(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.test_cases, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingSuite.TestDefinition.ExpectedResultsEntry expected_results = 3;

        pub fn expected_results(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.expected_results
        }

        pub fn clear_expected_results(&mut self) {
            self.expected_results.clear();
        }

        // Param is passed by value, moved
        pub fn set_expected_results(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.expected_results = v;
        }

        // Mutable pointer to the field.
        pub fn mut_expected_results(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.expected_results
        }

        // Take field
        pub fn take_expected_results(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.expected_results, ::std::collections::HashMap::new())
        }

        // repeated string prerequisites = 4;

        pub fn prerequisites(&self) -> &[::std::string::String] {
            &self.prerequisites
        }

        pub fn clear_prerequisites(&mut self) {
            self.prerequisites.clear();
        }

        // Param is passed by value, moved
        pub fn set_prerequisites(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.prerequisites = v;
        }

        // Mutable pointer to the field.
        pub fn mut_prerequisites(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.prerequisites
        }

        // Take field
        pub fn take_prerequisites(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.prerequisites, ::std::vec::Vec::new())
        }

        // bool automated = 5;

        pub fn automated(&self) -> bool {
            self.automated
        }

        pub fn clear_automated(&mut self) {
            self.automated = false;
        }

        // Param is passed by value, moved
        pub fn set_automated(&mut self, v: bool) {
            self.automated = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "test_name",
                |m: &TestDefinition| { &m.test_name },
                |m: &mut TestDefinition| { &mut m.test_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "test_cases",
                |m: &TestDefinition| { &m.test_cases },
                |m: &mut TestDefinition| { &mut m.test_cases },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "expected_results",
                |m: &TestDefinition| { &m.expected_results },
                |m: &mut TestDefinition| { &mut m.expected_results },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "prerequisites",
                |m: &TestDefinition| { &m.prerequisites },
                |m: &mut TestDefinition| { &mut m.prerequisites },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "automated",
                |m: &TestDefinition| { &m.automated },
                |m: &mut TestDefinition| { &mut m.automated },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestDefinition>(
                "TestingSuite.TestDefinition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestDefinition {
        const NAME: &'static str = "TestDefinition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.test_name = is.read_string()?;
                    },
                    18 => {
                        self.test_cases.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.expected_results.insert(key, value);
                    },
                    34 => {
                        self.prerequisites.push(is.read_string()?);
                    },
                    40 => {
                        self.automated = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.test_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.test_name);
            }
            for value in &self.test_cases {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.expected_results {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.prerequisites {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            if self.automated != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.test_name.is_empty() {
                os.write_string(1, &self.test_name)?;
            }
            for v in &self.test_cases {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.expected_results {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.prerequisites {
                os.write_string(4, &v)?;
            };
            if self.automated != false {
                os.write_bool(5, self.automated)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestDefinition {
            TestDefinition::new()
        }

        fn clear(&mut self) {
            self.test_name.clear();
            self.test_cases.clear();
            self.expected_results.clear();
            self.prerequisites.clear();
            self.automated = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestDefinition {
            static instance: ::protobuf::rt::Lazy<TestDefinition> = ::protobuf::rt::Lazy::new();
            instance.get(TestDefinition::new)
        }
    }

    impl ::protobuf::MessageFull for TestDefinition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestingSuite.TestDefinition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestDefinition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestDefinition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.TestingSuite.TestCase)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestCase {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCase.case_id)
        pub case_id: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCase.description)
        pub description: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCase.input_data)
        pub input_data: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCase.expected_output)
        pub expected_output: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCase.test_parameters)
        pub test_parameters: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCase.validation_rules)
        pub validation_rules: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.TestingSuite.TestCase.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestCase {
        fn default() -> &'a TestCase {
            <TestCase as ::protobuf::Message>::default_instance()
        }
    }

    impl TestCase {
        pub fn new() -> TestCase {
            ::std::default::Default::default()
        }

        // string case_id = 1;

        pub fn case_id(&self) -> &str {
            &self.case_id
        }

        pub fn clear_case_id(&mut self) {
            self.case_id.clear();
        }

        // Param is passed by value, moved
        pub fn set_case_id(&mut self, v: ::std::string::String) {
            self.case_id = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_case_id(&mut self) -> &mut ::std::string::String {
            &mut self.case_id
        }

        // Take field
        pub fn take_case_id(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.case_id, ::std::string::String::new())
        }

        // string description = 2;

        pub fn description(&self) -> &str {
            &self.description
        }

        pub fn clear_description(&mut self) {
            self.description.clear();
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            &mut self.description
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.description, ::std::string::String::new())
        }

        // repeated string input_data = 3;

        pub fn input_data(&self) -> &[::std::string::String] {
            &self.input_data
        }

        pub fn clear_input_data(&mut self) {
            self.input_data.clear();
        }

        // Param is passed by value, moved
        pub fn set_input_data(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.input_data = v;
        }

        // Mutable pointer to the field.
        pub fn mut_input_data(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.input_data
        }

        // Take field
        pub fn take_input_data(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.input_data, ::std::vec::Vec::new())
        }

        // repeated string expected_output = 4;

        pub fn expected_output(&self) -> &[::std::string::String] {
            &self.expected_output
        }

        pub fn clear_expected_output(&mut self) {
            self.expected_output.clear();
        }

        // Param is passed by value, moved
        pub fn set_expected_output(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.expected_output = v;
        }

        // Mutable pointer to the field.
        pub fn mut_expected_output(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.expected_output
        }

        // Take field
        pub fn take_expected_output(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.expected_output, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingSuite.TestCase.TestParametersEntry test_parameters = 5;

        pub fn test_parameters(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.test_parameters
        }

        pub fn clear_test_parameters(&mut self) {
            self.test_parameters.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_parameters(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.test_parameters = v;
        }

        // Mutable pointer to the field.
        pub fn mut_test_parameters(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.test_parameters
        }

        // Take field
        pub fn take_test_parameters(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.test_parameters, ::std::collections::HashMap::new())
        }

        // repeated string validation_rules = 6;

        pub fn validation_rules(&self) -> &[::std::string::String] {
            &self.validation_rules
        }

        pub fn clear_validation_rules(&mut self) {
            self.validation_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_validation_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.validation_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_validation_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.validation_rules
        }

        // Take field
        pub fn take_validation_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.validation_rules, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "case_id",
                |m: &TestCase| { &m.case_id },
                |m: &mut TestCase| { &mut m.case_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "description",
                |m: &TestCase| { &m.description },
                |m: &mut TestCase| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "input_data",
                |m: &TestCase| { &m.input_data },
                |m: &mut TestCase| { &mut m.input_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "expected_output",
                |m: &TestCase| { &m.expected_output },
                |m: &mut TestCase| { &mut m.expected_output },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "test_parameters",
                |m: &TestCase| { &m.test_parameters },
                |m: &mut TestCase| { &mut m.test_parameters },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "validation_rules",
                |m: &TestCase| { &m.validation_rules },
                |m: &mut TestCase| { &mut m.validation_rules },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestCase>(
                "TestingSuite.TestCase",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestCase {
        const NAME: &'static str = "TestCase";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.case_id = is.read_string()?;
                    },
                    18 => {
                        self.description = is.read_string()?;
                    },
                    26 => {
                        self.input_data.push(is.read_string()?);
                    },
                    34 => {
                        self.expected_output.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.test_parameters.insert(key, value);
                    },
                    50 => {
                        self.validation_rules.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.case_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.case_id);
            }
            if !self.description.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.description);
            }
            for value in &self.input_data {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for value in &self.expected_output {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.test_parameters {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.validation_rules {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.case_id.is_empty() {
                os.write_string(1, &self.case_id)?;
            }
            if !self.description.is_empty() {
                os.write_string(2, &self.description)?;
            }
            for v in &self.input_data {
                os.write_string(3, &v)?;
            };
            for v in &self.expected_output {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.test_parameters {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.validation_rules {
                os.write_string(6, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestCase {
            TestCase::new()
        }

        fn clear(&mut self) {
            self.case_id.clear();
            self.description.clear();
            self.input_data.clear();
            self.expected_output.clear();
            self.test_parameters.clear();
            self.validation_rules.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestCase {
            static instance: ::protobuf::rt::Lazy<TestCase> = ::protobuf::rt::Lazy::new();
            instance.get(TestCase::new)
        }
    }

    impl ::protobuf::MessageFull for TestCase {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestingSuite.TestCase").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestCase {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestCase {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.TestingSuite.TestResults)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestResults {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestResults.test_id)
        pub test_id: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestResults.passed)
        pub passed: bool,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestResults.failures)
        pub failures: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestResults.execution_time)
        pub execution_time: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestResults.metrics)
        pub metrics: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestResults.notes)
        pub notes: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.TestingSuite.TestResults.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestResults {
        fn default() -> &'a TestResults {
            <TestResults as ::protobuf::Message>::default_instance()
        }
    }

    impl TestResults {
        pub fn new() -> TestResults {
            ::std::default::Default::default()
        }

        // string test_id = 1;

        pub fn test_id(&self) -> &str {
            &self.test_id
        }

        pub fn clear_test_id(&mut self) {
            self.test_id.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_id(&mut self, v: ::std::string::String) {
            self.test_id = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_test_id(&mut self) -> &mut ::std::string::String {
            &mut self.test_id
        }

        // Take field
        pub fn take_test_id(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.test_id, ::std::string::String::new())
        }

        // bool passed = 2;

        pub fn passed(&self) -> bool {
            self.passed
        }

        pub fn clear_passed(&mut self) {
            self.passed = false;
        }

        // Param is passed by value, moved
        pub fn set_passed(&mut self, v: bool) {
            self.passed = v;
        }

        // repeated string failures = 3;

        pub fn failures(&self) -> &[::std::string::String] {
            &self.failures
        }

        pub fn clear_failures(&mut self) {
            self.failures.clear();
        }

        // Param is passed by value, moved
        pub fn set_failures(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.failures = v;
        }

        // Mutable pointer to the field.
        pub fn mut_failures(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.failures
        }

        // Take field
        pub fn take_failures(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.failures, ::std::vec::Vec::new())
        }

        // string execution_time = 4;

        pub fn execution_time(&self) -> &str {
            &self.execution_time
        }

        pub fn clear_execution_time(&mut self) {
            self.execution_time.clear();
        }

        // Param is passed by value, moved
        pub fn set_execution_time(&mut self, v: ::std::string::String) {
            self.execution_time = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_execution_time(&mut self) -> &mut ::std::string::String {
            &mut self.execution_time
        }

        // Take field
        pub fn take_execution_time(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.execution_time, ::std::string::String::new())
        }

        // repeated .kymera_mappings.TestingSuite.TestResults.MetricsEntry metrics = 5;

        pub fn metrics(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.metrics
        }

        pub fn clear_metrics(&mut self) {
            self.metrics.clear();
        }

        // Param is passed by value, moved
        pub fn set_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.metrics = v;
        }

        // Mutable pointer to the field.
        pub fn mut_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.metrics
        }

        // Take field
        pub fn take_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.metrics, ::std::collections::HashMap::new())
        }

        // repeated string notes = 6;

        pub fn notes(&self) -> &[::std::string::String] {
            &self.notes
        }

        pub fn clear_notes(&mut self) {
            self.notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.notes
        }

        // Take field
        pub fn take_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.notes, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "test_id",
                |m: &TestResults| { &m.test_id },
                |m: &mut TestResults| { &mut m.test_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "passed",
                |m: &TestResults| { &m.passed },
                |m: &mut TestResults| { &mut m.passed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "failures",
                |m: &TestResults| { &m.failures },
                |m: &mut TestResults| { &mut m.failures },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "execution_time",
                |m: &TestResults| { &m.execution_time },
                |m: &mut TestResults| { &mut m.execution_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "metrics",
                |m: &TestResults| { &m.metrics },
                |m: &mut TestResults| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "notes",
                |m: &TestResults| { &m.notes },
                |m: &mut TestResults| { &mut m.notes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestResults>(
                "TestingSuite.TestResults",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestResults {
        const NAME: &'static str = "TestResults";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.test_id = is.read_string()?;
                    },
                    16 => {
                        self.passed = is.read_bool()?;
                    },
                    26 => {
                        self.failures.push(is.read_string()?);
                    },
                    34 => {
                        self.execution_time = is.read_string()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.metrics.insert(key, value);
                    },
                    50 => {
                        self.notes.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.test_id.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.test_id);
            }
            if self.passed != false {
                my_size += 1 + 1;
            }
            for value in &self.failures {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if !self.execution_time.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.execution_time);
            }
            for (k, v) in &self.metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.notes {
                my_size += ::protobuf::rt::string_size(6, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.test_id.is_empty() {
                os.write_string(1, &self.test_id)?;
            }
            if self.passed != false {
                os.write_bool(2, self.passed)?;
            }
            for v in &self.failures {
                os.write_string(3, &v)?;
            };
            if !self.execution_time.is_empty() {
                os.write_string(4, &self.execution_time)?;
            }
            for (k, v) in &self.metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.notes {
                os.write_string(6, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestResults {
            TestResults::new()
        }

        fn clear(&mut self) {
            self.test_id.clear();
            self.passed = false;
            self.failures.clear();
            self.execution_time.clear();
            self.metrics.clear();
            self.notes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestResults {
            static instance: ::protobuf::rt::Lazy<TestResults> = ::protobuf::rt::Lazy::new();
            instance.get(TestResults::new)
        }
    }

    impl ::protobuf::MessageFull for TestResults {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestingSuite.TestResults").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestResults {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestResults {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.TestingSuite.TestCoverage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestCoverage {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCoverage.line_coverage)
        pub line_coverage: f64,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCoverage.branch_coverage)
        pub branch_coverage: f64,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCoverage.uncovered_areas)
        pub uncovered_areas: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCoverage.coverage_metrics)
        pub coverage_metrics: ::std::collections::HashMap<::std::string::String, f64>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingSuite.TestCoverage.coverage_goals)
        pub coverage_goals: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.TestingSuite.TestCoverage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestCoverage {
        fn default() -> &'a TestCoverage {
            <TestCoverage as ::protobuf::Message>::default_instance()
        }
    }

    impl TestCoverage {
        pub fn new() -> TestCoverage {
            ::std::default::Default::default()
        }

        // double line_coverage = 1;

        pub fn line_coverage(&self) -> f64 {
            self.line_coverage
        }

        pub fn clear_line_coverage(&mut self) {
            self.line_coverage = 0.;
        }

        // Param is passed by value, moved
        pub fn set_line_coverage(&mut self, v: f64) {
            self.line_coverage = v;
        }

        // double branch_coverage = 2;

        pub fn branch_coverage(&self) -> f64 {
            self.branch_coverage
        }

        pub fn clear_branch_coverage(&mut self) {
            self.branch_coverage = 0.;
        }

        // Param is passed by value, moved
        pub fn set_branch_coverage(&mut self, v: f64) {
            self.branch_coverage = v;
        }

        // repeated string uncovered_areas = 3;

        pub fn uncovered_areas(&self) -> &[::std::string::String] {
            &self.uncovered_areas
        }

        pub fn clear_uncovered_areas(&mut self) {
            self.uncovered_areas.clear();
        }

        // Param is passed by value, moved
        pub fn set_uncovered_areas(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.uncovered_areas = v;
        }

        // Mutable pointer to the field.
        pub fn mut_uncovered_areas(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.uncovered_areas
        }

        // Take field
        pub fn take_uncovered_areas(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.uncovered_areas, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingSuite.TestCoverage.CoverageMetricsEntry coverage_metrics = 4;

        pub fn coverage_metrics(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
            &self.coverage_metrics
        }

        pub fn clear_coverage_metrics(&mut self) {
            self.coverage_metrics.clear();
        }

        // Param is passed by value, moved
        pub fn set_coverage_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
            self.coverage_metrics = v;
        }

        // Mutable pointer to the field.
        pub fn mut_coverage_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
            &mut self.coverage_metrics
        }

        // Take field
        pub fn take_coverage_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
            ::std::mem::replace(&mut self.coverage_metrics, ::std::collections::HashMap::new())
        }

        // repeated string coverage_goals = 5;

        pub fn coverage_goals(&self) -> &[::std::string::String] {
            &self.coverage_goals
        }

        pub fn clear_coverage_goals(&mut self) {
            self.coverage_goals.clear();
        }

        // Param is passed by value, moved
        pub fn set_coverage_goals(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.coverage_goals = v;
        }

        // Mutable pointer to the field.
        pub fn mut_coverage_goals(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.coverage_goals
        }

        // Take field
        pub fn take_coverage_goals(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.coverage_goals, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "line_coverage",
                |m: &TestCoverage| { &m.line_coverage },
                |m: &mut TestCoverage| { &mut m.line_coverage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "branch_coverage",
                |m: &TestCoverage| { &m.branch_coverage },
                |m: &mut TestCoverage| { &mut m.branch_coverage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "uncovered_areas",
                |m: &TestCoverage| { &m.uncovered_areas },
                |m: &mut TestCoverage| { &mut m.uncovered_areas },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "coverage_metrics",
                |m: &TestCoverage| { &m.coverage_metrics },
                |m: &mut TestCoverage| { &mut m.coverage_metrics },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "coverage_goals",
                |m: &TestCoverage| { &m.coverage_goals },
                |m: &mut TestCoverage| { &mut m.coverage_goals },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestCoverage>(
                "TestingSuite.TestCoverage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestCoverage {
        const NAME: &'static str = "TestCoverage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.line_coverage = is.read_double()?;
                    },
                    17 => {
                        self.branch_coverage = is.read_double()?;
                    },
                    26 => {
                        self.uncovered_areas.push(is.read_string()?);
                    },
                    34 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                17 => value = is.read_double()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.coverage_metrics.insert(key, value);
                    },
                    42 => {
                        self.coverage_goals.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.line_coverage != 0. {
                my_size += 1 + 8;
            }
            if self.branch_coverage != 0. {
                my_size += 1 + 8;
            }
            for value in &self.uncovered_areas {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for (k, v) in &self.coverage_metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.coverage_goals {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.line_coverage != 0. {
                os.write_double(1, self.line_coverage)?;
            }
            if self.branch_coverage != 0. {
                os.write_double(2, self.branch_coverage)?;
            }
            for v in &self.uncovered_areas {
                os.write_string(3, &v)?;
            };
            for (k, v) in &self.coverage_metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                os.write_raw_varint32(34)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_double(2, *v)?;
            };
            for v in &self.coverage_goals {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestCoverage {
            TestCoverage::new()
        }

        fn clear(&mut self) {
            self.line_coverage = 0.;
            self.branch_coverage = 0.;
            self.uncovered_areas.clear();
            self.coverage_metrics.clear();
            self.coverage_goals.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestCoverage {
            static instance: ::protobuf::rt::Lazy<TestCoverage> = ::protobuf::rt::Lazy::new();
            instance.get(TestCoverage::new)
        }
    }

    impl ::protobuf::MessageFull for TestCoverage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestingSuite.TestCoverage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestCoverage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestCoverage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SecurityEnhancement {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SecurityEnhancement {
    fn default() -> &'a SecurityEnhancement {
        <SecurityEnhancement as ::protobuf::Message>::default_instance()
    }
}

impl SecurityEnhancement {
    pub fn new() -> SecurityEnhancement {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityEnhancement>(
            "SecurityEnhancement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SecurityEnhancement {
    const NAME: &'static str = "SecurityEnhancement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SecurityEnhancement {
        SecurityEnhancement::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SecurityEnhancement {
        static instance: SecurityEnhancement = SecurityEnhancement {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SecurityEnhancement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SecurityEnhancement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SecurityEnhancement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityEnhancement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SecurityEnhancement`
pub mod security_enhancement {
    // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancement.RuntimeSecurity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuntimeSecurity {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.RuntimeSecurity.sanitization_rules)
        pub sanitization_rules: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.RuntimeSecurity.security_boundaries)
        pub security_boundaries: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.RuntimeSecurity.enforce_memory_safety)
        pub enforce_memory_safety: bool,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.RuntimeSecurity.validation_checks)
        pub validation_checks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.RuntimeSecurity.security_policies)
        pub security_policies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancement.RuntimeSecurity.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuntimeSecurity {
        fn default() -> &'a RuntimeSecurity {
            <RuntimeSecurity as ::protobuf::Message>::default_instance()
        }
    }

    impl RuntimeSecurity {
        pub fn new() -> RuntimeSecurity {
            ::std::default::Default::default()
        }

        // repeated string sanitization_rules = 1;

        pub fn sanitization_rules(&self) -> &[::std::string::String] {
            &self.sanitization_rules
        }

        pub fn clear_sanitization_rules(&mut self) {
            self.sanitization_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_sanitization_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.sanitization_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_sanitization_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.sanitization_rules
        }

        // Take field
        pub fn take_sanitization_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.sanitization_rules, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SecurityEnhancement.RuntimeSecurity.SecurityBoundariesEntry security_boundaries = 2;

        pub fn security_boundaries(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.security_boundaries
        }

        pub fn clear_security_boundaries(&mut self) {
            self.security_boundaries.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_boundaries(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.security_boundaries = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_boundaries(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.security_boundaries
        }

        // Take field
        pub fn take_security_boundaries(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.security_boundaries, ::std::collections::HashMap::new())
        }

        // bool enforce_memory_safety = 3;

        pub fn enforce_memory_safety(&self) -> bool {
            self.enforce_memory_safety
        }

        pub fn clear_enforce_memory_safety(&mut self) {
            self.enforce_memory_safety = false;
        }

        // Param is passed by value, moved
        pub fn set_enforce_memory_safety(&mut self, v: bool) {
            self.enforce_memory_safety = v;
        }

        // repeated string validation_checks = 4;

        pub fn validation_checks(&self) -> &[::std::string::String] {
            &self.validation_checks
        }

        pub fn clear_validation_checks(&mut self) {
            self.validation_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_validation_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.validation_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_validation_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.validation_checks
        }

        // Take field
        pub fn take_validation_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.validation_checks, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SecurityEnhancement.RuntimeSecurity.SecurityPoliciesEntry security_policies = 5;

        pub fn security_policies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.security_policies
        }

        pub fn clear_security_policies(&mut self) {
            self.security_policies.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.security_policies = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.security_policies
        }

        // Take field
        pub fn take_security_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.security_policies, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "sanitization_rules",
                |m: &RuntimeSecurity| { &m.sanitization_rules },
                |m: &mut RuntimeSecurity| { &mut m.sanitization_rules },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "security_boundaries",
                |m: &RuntimeSecurity| { &m.security_boundaries },
                |m: &mut RuntimeSecurity| { &mut m.security_boundaries },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "enforce_memory_safety",
                |m: &RuntimeSecurity| { &m.enforce_memory_safety },
                |m: &mut RuntimeSecurity| { &mut m.enforce_memory_safety },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "validation_checks",
                |m: &RuntimeSecurity| { &m.validation_checks },
                |m: &mut RuntimeSecurity| { &mut m.validation_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "security_policies",
                |m: &RuntimeSecurity| { &m.security_policies },
                |m: &mut RuntimeSecurity| { &mut m.security_policies },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeSecurity>(
                "SecurityEnhancement.RuntimeSecurity",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuntimeSecurity {
        const NAME: &'static str = "RuntimeSecurity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.sanitization_rules.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.security_boundaries.insert(key, value);
                    },
                    24 => {
                        self.enforce_memory_safety = is.read_bool()?;
                    },
                    34 => {
                        self.validation_checks.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.security_policies.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.sanitization_rules {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.security_boundaries {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.enforce_memory_safety != false {
                my_size += 1 + 1;
            }
            for value in &self.validation_checks {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.security_policies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.sanitization_rules {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.security_boundaries {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.enforce_memory_safety != false {
                os.write_bool(3, self.enforce_memory_safety)?;
            }
            for v in &self.validation_checks {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.security_policies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuntimeSecurity {
            RuntimeSecurity::new()
        }

        fn clear(&mut self) {
            self.sanitization_rules.clear();
            self.security_boundaries.clear();
            self.enforce_memory_safety = false;
            self.validation_checks.clear();
            self.security_policies.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuntimeSecurity {
            static instance: ::protobuf::rt::Lazy<RuntimeSecurity> = ::protobuf::rt::Lazy::new();
            instance.get(RuntimeSecurity::new)
        }
    }

    impl ::protobuf::MessageFull for RuntimeSecurity {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityEnhancement.RuntimeSecurity").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuntimeSecurity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuntimeSecurity {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancement.CrossLanguageSecurity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CrossLanguageSecurity {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.CrossLanguageSecurity.type_safety_rules)
        pub type_safety_rules: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.CrossLanguageSecurity.conversion_safeguards)
        pub conversion_safeguards: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.CrossLanguageSecurity.security_invariants)
        pub security_invariants: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.CrossLanguageSecurity.strict_type_checking)
        pub strict_type_checking: bool,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.CrossLanguageSecurity.boundary_checks)
        pub boundary_checks: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancement.CrossLanguageSecurity.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CrossLanguageSecurity {
        fn default() -> &'a CrossLanguageSecurity {
            <CrossLanguageSecurity as ::protobuf::Message>::default_instance()
        }
    }

    impl CrossLanguageSecurity {
        pub fn new() -> CrossLanguageSecurity {
            ::std::default::Default::default()
        }

        // repeated string type_safety_rules = 1;

        pub fn type_safety_rules(&self) -> &[::std::string::String] {
            &self.type_safety_rules
        }

        pub fn clear_type_safety_rules(&mut self) {
            self.type_safety_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_type_safety_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.type_safety_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_type_safety_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.type_safety_rules
        }

        // Take field
        pub fn take_type_safety_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.type_safety_rules, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SecurityEnhancement.CrossLanguageSecurity.ConversionSafeguardsEntry conversion_safeguards = 2;

        pub fn conversion_safeguards(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.conversion_safeguards
        }

        pub fn clear_conversion_safeguards(&mut self) {
            self.conversion_safeguards.clear();
        }

        // Param is passed by value, moved
        pub fn set_conversion_safeguards(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.conversion_safeguards = v;
        }

        // Mutable pointer to the field.
        pub fn mut_conversion_safeguards(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.conversion_safeguards
        }

        // Take field
        pub fn take_conversion_safeguards(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.conversion_safeguards, ::std::collections::HashMap::new())
        }

        // repeated string security_invariants = 3;

        pub fn security_invariants(&self) -> &[::std::string::String] {
            &self.security_invariants
        }

        pub fn clear_security_invariants(&mut self) {
            self.security_invariants.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_invariants(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.security_invariants = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_invariants(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.security_invariants
        }

        // Take field
        pub fn take_security_invariants(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.security_invariants, ::std::vec::Vec::new())
        }

        // bool strict_type_checking = 4;

        pub fn strict_type_checking(&self) -> bool {
            self.strict_type_checking
        }

        pub fn clear_strict_type_checking(&mut self) {
            self.strict_type_checking = false;
        }

        // Param is passed by value, moved
        pub fn set_strict_type_checking(&mut self, v: bool) {
            self.strict_type_checking = v;
        }

        // repeated string boundary_checks = 5;

        pub fn boundary_checks(&self) -> &[::std::string::String] {
            &self.boundary_checks
        }

        pub fn clear_boundary_checks(&mut self) {
            self.boundary_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_boundary_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.boundary_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_boundary_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.boundary_checks
        }

        // Take field
        pub fn take_boundary_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.boundary_checks, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type_safety_rules",
                |m: &CrossLanguageSecurity| { &m.type_safety_rules },
                |m: &mut CrossLanguageSecurity| { &mut m.type_safety_rules },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "conversion_safeguards",
                |m: &CrossLanguageSecurity| { &m.conversion_safeguards },
                |m: &mut CrossLanguageSecurity| { &mut m.conversion_safeguards },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "security_invariants",
                |m: &CrossLanguageSecurity| { &m.security_invariants },
                |m: &mut CrossLanguageSecurity| { &mut m.security_invariants },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "strict_type_checking",
                |m: &CrossLanguageSecurity| { &m.strict_type_checking },
                |m: &mut CrossLanguageSecurity| { &mut m.strict_type_checking },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "boundary_checks",
                |m: &CrossLanguageSecurity| { &m.boundary_checks },
                |m: &mut CrossLanguageSecurity| { &mut m.boundary_checks },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CrossLanguageSecurity>(
                "SecurityEnhancement.CrossLanguageSecurity",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CrossLanguageSecurity {
        const NAME: &'static str = "CrossLanguageSecurity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_safety_rules.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.conversion_safeguards.insert(key, value);
                    },
                    26 => {
                        self.security_invariants.push(is.read_string()?);
                    },
                    32 => {
                        self.strict_type_checking = is.read_bool()?;
                    },
                    42 => {
                        self.boundary_checks.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.type_safety_rules {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.conversion_safeguards {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.security_invariants {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if self.strict_type_checking != false {
                my_size += 1 + 1;
            }
            for value in &self.boundary_checks {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.type_safety_rules {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.conversion_safeguards {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.security_invariants {
                os.write_string(3, &v)?;
            };
            if self.strict_type_checking != false {
                os.write_bool(4, self.strict_type_checking)?;
            }
            for v in &self.boundary_checks {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CrossLanguageSecurity {
            CrossLanguageSecurity::new()
        }

        fn clear(&mut self) {
            self.type_safety_rules.clear();
            self.conversion_safeguards.clear();
            self.security_invariants.clear();
            self.strict_type_checking = false;
            self.boundary_checks.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CrossLanguageSecurity {
            static instance: ::protobuf::rt::Lazy<CrossLanguageSecurity> = ::protobuf::rt::Lazy::new();
            instance.get(CrossLanguageSecurity::new)
        }
    }

    impl ::protobuf::MessageFull for CrossLanguageSecurity {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityEnhancement.CrossLanguageSecurity").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CrossLanguageSecurity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CrossLanguageSecurity {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.SecurityEnhancement.SecurityContext)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SecurityContext {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.SecurityContext.execution_context)
        pub execution_context: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.SecurityContext.active_policies)
        pub active_policies: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.SecurityContext.security_state)
        pub security_state: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.SecurityContext.in_trusted_context)
        pub in_trusted_context: bool,
        // @@protoc_insertion_point(field:kymera_mappings.SecurityEnhancement.SecurityContext.security_stack)
        pub security_stack: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.SecurityEnhancement.SecurityContext.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SecurityContext {
        fn default() -> &'a SecurityContext {
            <SecurityContext as ::protobuf::Message>::default_instance()
        }
    }

    impl SecurityContext {
        pub fn new() -> SecurityContext {
            ::std::default::Default::default()
        }

        // string execution_context = 1;

        pub fn execution_context(&self) -> &str {
            &self.execution_context
        }

        pub fn clear_execution_context(&mut self) {
            self.execution_context.clear();
        }

        // Param is passed by value, moved
        pub fn set_execution_context(&mut self, v: ::std::string::String) {
            self.execution_context = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_execution_context(&mut self) -> &mut ::std::string::String {
            &mut self.execution_context
        }

        // Take field
        pub fn take_execution_context(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.execution_context, ::std::string::String::new())
        }

        // repeated string active_policies = 2;

        pub fn active_policies(&self) -> &[::std::string::String] {
            &self.active_policies
        }

        pub fn clear_active_policies(&mut self) {
            self.active_policies.clear();
        }

        // Param is passed by value, moved
        pub fn set_active_policies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.active_policies = v;
        }

        // Mutable pointer to the field.
        pub fn mut_active_policies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.active_policies
        }

        // Take field
        pub fn take_active_policies(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.active_policies, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.SecurityEnhancement.SecurityContext.SecurityStateEntry security_state = 3;

        pub fn security_state(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.security_state
        }

        pub fn clear_security_state(&mut self) {
            self.security_state.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_state(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.security_state = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_state(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.security_state
        }

        // Take field
        pub fn take_security_state(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.security_state, ::std::collections::HashMap::new())
        }

        // bool in_trusted_context = 4;

        pub fn in_trusted_context(&self) -> bool {
            self.in_trusted_context
        }

        pub fn clear_in_trusted_context(&mut self) {
            self.in_trusted_context = false;
        }

        // Param is passed by value, moved
        pub fn set_in_trusted_context(&mut self, v: bool) {
            self.in_trusted_context = v;
        }

        // repeated string security_stack = 5;

        pub fn security_stack(&self) -> &[::std::string::String] {
            &self.security_stack
        }

        pub fn clear_security_stack(&mut self) {
            self.security_stack.clear();
        }

        // Param is passed by value, moved
        pub fn set_security_stack(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.security_stack = v;
        }

        // Mutable pointer to the field.
        pub fn mut_security_stack(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.security_stack
        }

        // Take field
        pub fn take_security_stack(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.security_stack, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "execution_context",
                |m: &SecurityContext| { &m.execution_context },
                |m: &mut SecurityContext| { &mut m.execution_context },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "active_policies",
                |m: &SecurityContext| { &m.active_policies },
                |m: &mut SecurityContext| { &mut m.active_policies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "security_state",
                |m: &SecurityContext| { &m.security_state },
                |m: &mut SecurityContext| { &mut m.security_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "in_trusted_context",
                |m: &SecurityContext| { &m.in_trusted_context },
                |m: &mut SecurityContext| { &mut m.in_trusted_context },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "security_stack",
                |m: &SecurityContext| { &m.security_stack },
                |m: &mut SecurityContext| { &mut m.security_stack },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityContext>(
                "SecurityEnhancement.SecurityContext",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SecurityContext {
        const NAME: &'static str = "SecurityContext";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.execution_context = is.read_string()?;
                    },
                    18 => {
                        self.active_policies.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.security_state.insert(key, value);
                    },
                    32 => {
                        self.in_trusted_context = is.read_bool()?;
                    },
                    42 => {
                        self.security_stack.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.execution_context.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.execution_context);
            }
            for value in &self.active_policies {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.security_state {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.in_trusted_context != false {
                my_size += 1 + 1;
            }
            for value in &self.security_stack {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.execution_context.is_empty() {
                os.write_string(1, &self.execution_context)?;
            }
            for v in &self.active_policies {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.security_state {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.in_trusted_context != false {
                os.write_bool(4, self.in_trusted_context)?;
            }
            for v in &self.security_stack {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SecurityContext {
            SecurityContext::new()
        }

        fn clear(&mut self) {
            self.execution_context.clear();
            self.active_policies.clear();
            self.security_state.clear();
            self.in_trusted_context = false;
            self.security_stack.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SecurityContext {
            static instance: ::protobuf::rt::Lazy<SecurityContext> = ::protobuf::rt::Lazy::new();
            instance.get(SecurityContext::new)
        }
    }

    impl ::protobuf::MessageFull for SecurityContext {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SecurityEnhancement.SecurityContext").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SecurityContext {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SecurityContext {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.PerformanceOptimization)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PerformanceOptimization {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceOptimization.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PerformanceOptimization {
    fn default() -> &'a PerformanceOptimization {
        <PerformanceOptimization as ::protobuf::Message>::default_instance()
    }
}

impl PerformanceOptimization {
    pub fn new() -> PerformanceOptimization {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceOptimization>(
            "PerformanceOptimization",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PerformanceOptimization {
    const NAME: &'static str = "PerformanceOptimization";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PerformanceOptimization {
        PerformanceOptimization::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PerformanceOptimization {
        static instance: PerformanceOptimization = PerformanceOptimization {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PerformanceOptimization {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PerformanceOptimization").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PerformanceOptimization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PerformanceOptimization {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PerformanceOptimization`
pub mod performance_optimization {
    // @@protoc_insertion_point(message:kymera_mappings.PerformanceOptimization.CompilerHints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CompilerHints {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.CompilerHints.optimization_flags)
        pub optimization_flags: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.CompilerHints.inline_hints)
        pub inline_hints: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.CompilerHints.allow_unsafe_optimizations)
        pub allow_unsafe_optimizations: bool,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.CompilerHints.specialization_hints)
        pub specialization_hints: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.CompilerHints.codegen_hints)
        pub codegen_hints: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceOptimization.CompilerHints.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CompilerHints {
        fn default() -> &'a CompilerHints {
            <CompilerHints as ::protobuf::Message>::default_instance()
        }
    }

    impl CompilerHints {
        pub fn new() -> CompilerHints {
            ::std::default::Default::default()
        }

        // repeated string optimization_flags = 1;

        pub fn optimization_flags(&self) -> &[::std::string::String] {
            &self.optimization_flags
        }

        pub fn clear_optimization_flags(&mut self) {
            self.optimization_flags.clear();
        }

        // Param is passed by value, moved
        pub fn set_optimization_flags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.optimization_flags = v;
        }

        // Mutable pointer to the field.
        pub fn mut_optimization_flags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.optimization_flags
        }

        // Take field
        pub fn take_optimization_flags(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.optimization_flags, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.PerformanceOptimization.CompilerHints.InlineHintsEntry inline_hints = 2;

        pub fn inline_hints(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.inline_hints
        }

        pub fn clear_inline_hints(&mut self) {
            self.inline_hints.clear();
        }

        // Param is passed by value, moved
        pub fn set_inline_hints(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.inline_hints = v;
        }

        // Mutable pointer to the field.
        pub fn mut_inline_hints(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.inline_hints
        }

        // Take field
        pub fn take_inline_hints(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.inline_hints, ::std::collections::HashMap::new())
        }

        // bool allow_unsafe_optimizations = 3;

        pub fn allow_unsafe_optimizations(&self) -> bool {
            self.allow_unsafe_optimizations
        }

        pub fn clear_allow_unsafe_optimizations(&mut self) {
            self.allow_unsafe_optimizations = false;
        }

        // Param is passed by value, moved
        pub fn set_allow_unsafe_optimizations(&mut self, v: bool) {
            self.allow_unsafe_optimizations = v;
        }

        // repeated string specialization_hints = 4;

        pub fn specialization_hints(&self) -> &[::std::string::String] {
            &self.specialization_hints
        }

        pub fn clear_specialization_hints(&mut self) {
            self.specialization_hints.clear();
        }

        // Param is passed by value, moved
        pub fn set_specialization_hints(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.specialization_hints = v;
        }

        // Mutable pointer to the field.
        pub fn mut_specialization_hints(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.specialization_hints
        }

        // Take field
        pub fn take_specialization_hints(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.specialization_hints, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.PerformanceOptimization.CompilerHints.CodegenHintsEntry codegen_hints = 5;

        pub fn codegen_hints(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.codegen_hints
        }

        pub fn clear_codegen_hints(&mut self) {
            self.codegen_hints.clear();
        }

        // Param is passed by value, moved
        pub fn set_codegen_hints(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.codegen_hints = v;
        }

        // Mutable pointer to the field.
        pub fn mut_codegen_hints(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.codegen_hints
        }

        // Take field
        pub fn take_codegen_hints(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.codegen_hints, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "optimization_flags",
                |m: &CompilerHints| { &m.optimization_flags },
                |m: &mut CompilerHints| { &mut m.optimization_flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "inline_hints",
                |m: &CompilerHints| { &m.inline_hints },
                |m: &mut CompilerHints| { &mut m.inline_hints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "allow_unsafe_optimizations",
                |m: &CompilerHints| { &m.allow_unsafe_optimizations },
                |m: &mut CompilerHints| { &mut m.allow_unsafe_optimizations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "specialization_hints",
                |m: &CompilerHints| { &m.specialization_hints },
                |m: &mut CompilerHints| { &mut m.specialization_hints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "codegen_hints",
                |m: &CompilerHints| { &m.codegen_hints },
                |m: &mut CompilerHints| { &mut m.codegen_hints },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompilerHints>(
                "PerformanceOptimization.CompilerHints",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CompilerHints {
        const NAME: &'static str = "CompilerHints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.optimization_flags.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.inline_hints.insert(key, value);
                    },
                    24 => {
                        self.allow_unsafe_optimizations = is.read_bool()?;
                    },
                    34 => {
                        self.specialization_hints.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.codegen_hints.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.optimization_flags {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.inline_hints {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.allow_unsafe_optimizations != false {
                my_size += 1 + 1;
            }
            for value in &self.specialization_hints {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.codegen_hints {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.optimization_flags {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.inline_hints {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.allow_unsafe_optimizations != false {
                os.write_bool(3, self.allow_unsafe_optimizations)?;
            }
            for v in &self.specialization_hints {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.codegen_hints {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CompilerHints {
            CompilerHints::new()
        }

        fn clear(&mut self) {
            self.optimization_flags.clear();
            self.inline_hints.clear();
            self.allow_unsafe_optimizations = false;
            self.specialization_hints.clear();
            self.codegen_hints.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CompilerHints {
            static instance: ::protobuf::rt::Lazy<CompilerHints> = ::protobuf::rt::Lazy::new();
            instance.get(CompilerHints::new)
        }
    }

    impl ::protobuf::MessageFull for CompilerHints {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PerformanceOptimization.CompilerHints").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CompilerHints {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CompilerHints {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.PerformanceOptimization.RuntimeOptimizations)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuntimeOptimizations {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.RuntimeOptimizations.cache_strategy)
        pub cache_strategy: u32,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.RuntimeOptimizations.hot_path_optimizations)
        pub hot_path_optimizations: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.RuntimeOptimizations.memory_layout_hints)
        pub memory_layout_hints: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.RuntimeOptimizations.enable_jit)
        pub enable_jit: bool,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.RuntimeOptimizations.optimization_barriers)
        pub optimization_barriers: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceOptimization.RuntimeOptimizations.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuntimeOptimizations {
        fn default() -> &'a RuntimeOptimizations {
            <RuntimeOptimizations as ::protobuf::Message>::default_instance()
        }
    }

    impl RuntimeOptimizations {
        pub fn new() -> RuntimeOptimizations {
            ::std::default::Default::default()
        }

        // uint32 cache_strategy = 1;

        pub fn cache_strategy(&self) -> u32 {
            self.cache_strategy
        }

        pub fn clear_cache_strategy(&mut self) {
            self.cache_strategy = 0;
        }

        // Param is passed by value, moved
        pub fn set_cache_strategy(&mut self, v: u32) {
            self.cache_strategy = v;
        }

        // repeated string hot_path_optimizations = 2;

        pub fn hot_path_optimizations(&self) -> &[::std::string::String] {
            &self.hot_path_optimizations
        }

        pub fn clear_hot_path_optimizations(&mut self) {
            self.hot_path_optimizations.clear();
        }

        // Param is passed by value, moved
        pub fn set_hot_path_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.hot_path_optimizations = v;
        }

        // Mutable pointer to the field.
        pub fn mut_hot_path_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.hot_path_optimizations
        }

        // Take field
        pub fn take_hot_path_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.hot_path_optimizations, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.PerformanceOptimization.RuntimeOptimizations.MemoryLayoutHintsEntry memory_layout_hints = 3;

        pub fn memory_layout_hints(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.memory_layout_hints
        }

        pub fn clear_memory_layout_hints(&mut self) {
            self.memory_layout_hints.clear();
        }

        // Param is passed by value, moved
        pub fn set_memory_layout_hints(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.memory_layout_hints = v;
        }

        // Mutable pointer to the field.
        pub fn mut_memory_layout_hints(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.memory_layout_hints
        }

        // Take field
        pub fn take_memory_layout_hints(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.memory_layout_hints, ::std::collections::HashMap::new())
        }

        // bool enable_jit = 4;

        pub fn enable_jit(&self) -> bool {
            self.enable_jit
        }

        pub fn clear_enable_jit(&mut self) {
            self.enable_jit = false;
        }

        // Param is passed by value, moved
        pub fn set_enable_jit(&mut self, v: bool) {
            self.enable_jit = v;
        }

        // repeated string optimization_barriers = 5;

        pub fn optimization_barriers(&self) -> &[::std::string::String] {
            &self.optimization_barriers
        }

        pub fn clear_optimization_barriers(&mut self) {
            self.optimization_barriers.clear();
        }

        // Param is passed by value, moved
        pub fn set_optimization_barriers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.optimization_barriers = v;
        }

        // Mutable pointer to the field.
        pub fn mut_optimization_barriers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.optimization_barriers
        }

        // Take field
        pub fn take_optimization_barriers(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.optimization_barriers, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "cache_strategy",
                |m: &RuntimeOptimizations| { &m.cache_strategy },
                |m: &mut RuntimeOptimizations| { &mut m.cache_strategy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hot_path_optimizations",
                |m: &RuntimeOptimizations| { &m.hot_path_optimizations },
                |m: &mut RuntimeOptimizations| { &mut m.hot_path_optimizations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "memory_layout_hints",
                |m: &RuntimeOptimizations| { &m.memory_layout_hints },
                |m: &mut RuntimeOptimizations| { &mut m.memory_layout_hints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "enable_jit",
                |m: &RuntimeOptimizations| { &m.enable_jit },
                |m: &mut RuntimeOptimizations| { &mut m.enable_jit },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "optimization_barriers",
                |m: &RuntimeOptimizations| { &m.optimization_barriers },
                |m: &mut RuntimeOptimizations| { &mut m.optimization_barriers },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeOptimizations>(
                "PerformanceOptimization.RuntimeOptimizations",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuntimeOptimizations {
        const NAME: &'static str = "RuntimeOptimizations";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.cache_strategy = is.read_uint32()?;
                    },
                    18 => {
                        self.hot_path_optimizations.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.memory_layout_hints.insert(key, value);
                    },
                    32 => {
                        self.enable_jit = is.read_bool()?;
                    },
                    42 => {
                        self.optimization_barriers.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.cache_strategy != 0 {
                my_size += ::protobuf::rt::uint32_size(1, self.cache_strategy);
            }
            for value in &self.hot_path_optimizations {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.memory_layout_hints {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.enable_jit != false {
                my_size += 1 + 1;
            }
            for value in &self.optimization_barriers {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.cache_strategy != 0 {
                os.write_uint32(1, self.cache_strategy)?;
            }
            for v in &self.hot_path_optimizations {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.memory_layout_hints {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.enable_jit != false {
                os.write_bool(4, self.enable_jit)?;
            }
            for v in &self.optimization_barriers {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuntimeOptimizations {
            RuntimeOptimizations::new()
        }

        fn clear(&mut self) {
            self.cache_strategy = 0;
            self.hot_path_optimizations.clear();
            self.memory_layout_hints.clear();
            self.enable_jit = false;
            self.optimization_barriers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuntimeOptimizations {
            static instance: ::protobuf::rt::Lazy<RuntimeOptimizations> = ::protobuf::rt::Lazy::new();
            instance.get(RuntimeOptimizations::new)
        }
    }

    impl ::protobuf::MessageFull for RuntimeOptimizations {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PerformanceOptimization.RuntimeOptimizations").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuntimeOptimizations {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuntimeOptimizations {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.PerformanceOptimization.OptimizationProfile)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct OptimizationProfile {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.OptimizationProfile.critical_paths)
        pub critical_paths: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.OptimizationProfile.performance_targets)
        pub performance_targets: ::std::collections::HashMap<::std::string::String, f64>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.OptimizationProfile.optimization_constraints)
        pub optimization_constraints: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.OptimizationProfile.profile_guided)
        pub profile_guided: bool,
        // @@protoc_insertion_point(field:kymera_mappings.PerformanceOptimization.OptimizationProfile.tuning_parameters)
        pub tuning_parameters: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.PerformanceOptimization.OptimizationProfile.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a OptimizationProfile {
        fn default() -> &'a OptimizationProfile {
            <OptimizationProfile as ::protobuf::Message>::default_instance()
        }
    }

    impl OptimizationProfile {
        pub fn new() -> OptimizationProfile {
            ::std::default::Default::default()
        }

        // repeated string critical_paths = 1;

        pub fn critical_paths(&self) -> &[::std::string::String] {
            &self.critical_paths
        }

        pub fn clear_critical_paths(&mut self) {
            self.critical_paths.clear();
        }

        // Param is passed by value, moved
        pub fn set_critical_paths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.critical_paths = v;
        }

        // Mutable pointer to the field.
        pub fn mut_critical_paths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.critical_paths
        }

        // Take field
        pub fn take_critical_paths(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.critical_paths, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.PerformanceOptimization.OptimizationProfile.PerformanceTargetsEntry performance_targets = 2;

        pub fn performance_targets(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
            &self.performance_targets
        }

        pub fn clear_performance_targets(&mut self) {
            self.performance_targets.clear();
        }

        // Param is passed by value, moved
        pub fn set_performance_targets(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
            self.performance_targets = v;
        }

        // Mutable pointer to the field.
        pub fn mut_performance_targets(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
            &mut self.performance_targets
        }

        // Take field
        pub fn take_performance_targets(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
            ::std::mem::replace(&mut self.performance_targets, ::std::collections::HashMap::new())
        }

        // repeated string optimization_constraints = 3;

        pub fn optimization_constraints(&self) -> &[::std::string::String] {
            &self.optimization_constraints
        }

        pub fn clear_optimization_constraints(&mut self) {
            self.optimization_constraints.clear();
        }

        // Param is passed by value, moved
        pub fn set_optimization_constraints(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.optimization_constraints = v;
        }

        // Mutable pointer to the field.
        pub fn mut_optimization_constraints(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.optimization_constraints
        }

        // Take field
        pub fn take_optimization_constraints(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.optimization_constraints, ::std::vec::Vec::new())
        }

        // bool profile_guided = 4;

        pub fn profile_guided(&self) -> bool {
            self.profile_guided
        }

        pub fn clear_profile_guided(&mut self) {
            self.profile_guided = false;
        }

        // Param is passed by value, moved
        pub fn set_profile_guided(&mut self, v: bool) {
            self.profile_guided = v;
        }

        // repeated .kymera_mappings.PerformanceOptimization.OptimizationProfile.TuningParametersEntry tuning_parameters = 5;

        pub fn tuning_parameters(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.tuning_parameters
        }

        pub fn clear_tuning_parameters(&mut self) {
            self.tuning_parameters.clear();
        }

        // Param is passed by value, moved
        pub fn set_tuning_parameters(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.tuning_parameters = v;
        }

        // Mutable pointer to the field.
        pub fn mut_tuning_parameters(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.tuning_parameters
        }

        // Take field
        pub fn take_tuning_parameters(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.tuning_parameters, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "critical_paths",
                |m: &OptimizationProfile| { &m.critical_paths },
                |m: &mut OptimizationProfile| { &mut m.critical_paths },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "performance_targets",
                |m: &OptimizationProfile| { &m.performance_targets },
                |m: &mut OptimizationProfile| { &mut m.performance_targets },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "optimization_constraints",
                |m: &OptimizationProfile| { &m.optimization_constraints },
                |m: &mut OptimizationProfile| { &mut m.optimization_constraints },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "profile_guided",
                |m: &OptimizationProfile| { &m.profile_guided },
                |m: &mut OptimizationProfile| { &mut m.profile_guided },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "tuning_parameters",
                |m: &OptimizationProfile| { &m.tuning_parameters },
                |m: &mut OptimizationProfile| { &mut m.tuning_parameters },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptimizationProfile>(
                "PerformanceOptimization.OptimizationProfile",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for OptimizationProfile {
        const NAME: &'static str = "OptimizationProfile";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.critical_paths.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                17 => value = is.read_double()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.performance_targets.insert(key, value);
                    },
                    26 => {
                        self.optimization_constraints.push(is.read_string()?);
                    },
                    32 => {
                        self.profile_guided = is.read_bool()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.tuning_parameters.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.critical_paths {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.performance_targets {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.optimization_constraints {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if self.profile_guided != false {
                my_size += 1 + 1;
            }
            for (k, v) in &self.tuning_parameters {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.critical_paths {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.performance_targets {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_double(2, *v)?;
            };
            for v in &self.optimization_constraints {
                os.write_string(3, &v)?;
            };
            if self.profile_guided != false {
                os.write_bool(4, self.profile_guided)?;
            }
            for (k, v) in &self.tuning_parameters {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> OptimizationProfile {
            OptimizationProfile::new()
        }

        fn clear(&mut self) {
            self.critical_paths.clear();
            self.performance_targets.clear();
            self.optimization_constraints.clear();
            self.profile_guided = false;
            self.tuning_parameters.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static OptimizationProfile {
            static instance: ::protobuf::rt::Lazy<OptimizationProfile> = ::protobuf::rt::Lazy::new();
            instance.get(OptimizationProfile::new)
        }
    }

    impl ::protobuf::MessageFull for OptimizationProfile {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PerformanceOptimization.OptimizationProfile").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for OptimizationProfile {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for OptimizationProfile {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.TestingEnhancement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TestingEnhancement {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.TestingEnhancement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TestingEnhancement {
    fn default() -> &'a TestingEnhancement {
        <TestingEnhancement as ::protobuf::Message>::default_instance()
    }
}

impl TestingEnhancement {
    pub fn new() -> TestingEnhancement {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestingEnhancement>(
            "TestingEnhancement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TestingEnhancement {
    const NAME: &'static str = "TestingEnhancement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TestingEnhancement {
        TestingEnhancement::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TestingEnhancement {
        static instance: TestingEnhancement = TestingEnhancement {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TestingEnhancement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TestingEnhancement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TestingEnhancement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TestingEnhancement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TestingEnhancement`
pub mod testing_enhancement {
    // @@protoc_insertion_point(message:kymera_mappings.TestingEnhancement.PropertyTesting)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PropertyTesting {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.PropertyTesting.invariants)
        pub invariants: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.PropertyTesting.generators)
        pub generators: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.PropertyTesting.test_iterations)
        pub test_iterations: u32,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.PropertyTesting.properties)
        pub properties: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.PropertyTesting.shrinking_rules)
        pub shrinking_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.TestingEnhancement.PropertyTesting.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PropertyTesting {
        fn default() -> &'a PropertyTesting {
            <PropertyTesting as ::protobuf::Message>::default_instance()
        }
    }

    impl PropertyTesting {
        pub fn new() -> PropertyTesting {
            ::std::default::Default::default()
        }

        // repeated string invariants = 1;

        pub fn invariants(&self) -> &[::std::string::String] {
            &self.invariants
        }

        pub fn clear_invariants(&mut self) {
            self.invariants.clear();
        }

        // Param is passed by value, moved
        pub fn set_invariants(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.invariants = v;
        }

        // Mutable pointer to the field.
        pub fn mut_invariants(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.invariants
        }

        // Take field
        pub fn take_invariants(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.invariants, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingEnhancement.PropertyTesting.GeneratorsEntry generators = 2;

        pub fn generators(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.generators
        }

        pub fn clear_generators(&mut self) {
            self.generators.clear();
        }

        // Param is passed by value, moved
        pub fn set_generators(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.generators = v;
        }

        // Mutable pointer to the field.
        pub fn mut_generators(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.generators
        }

        // Take field
        pub fn take_generators(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.generators, ::std::collections::HashMap::new())
        }

        // uint32 test_iterations = 3;

        pub fn test_iterations(&self) -> u32 {
            self.test_iterations
        }

        pub fn clear_test_iterations(&mut self) {
            self.test_iterations = 0;
        }

        // Param is passed by value, moved
        pub fn set_test_iterations(&mut self, v: u32) {
            self.test_iterations = v;
        }

        // repeated string properties = 4;

        pub fn properties(&self) -> &[::std::string::String] {
            &self.properties
        }

        pub fn clear_properties(&mut self) {
            self.properties.clear();
        }

        // Param is passed by value, moved
        pub fn set_properties(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.properties = v;
        }

        // Mutable pointer to the field.
        pub fn mut_properties(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.properties
        }

        // Take field
        pub fn take_properties(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.properties, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingEnhancement.PropertyTesting.ShrinkingRulesEntry shrinking_rules = 5;

        pub fn shrinking_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.shrinking_rules
        }

        pub fn clear_shrinking_rules(&mut self) {
            self.shrinking_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_shrinking_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.shrinking_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_shrinking_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.shrinking_rules
        }

        // Take field
        pub fn take_shrinking_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.shrinking_rules, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "invariants",
                |m: &PropertyTesting| { &m.invariants },
                |m: &mut PropertyTesting| { &mut m.invariants },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "generators",
                |m: &PropertyTesting| { &m.generators },
                |m: &mut PropertyTesting| { &mut m.generators },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "test_iterations",
                |m: &PropertyTesting| { &m.test_iterations },
                |m: &mut PropertyTesting| { &mut m.test_iterations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "properties",
                |m: &PropertyTesting| { &m.properties },
                |m: &mut PropertyTesting| { &mut m.properties },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "shrinking_rules",
                |m: &PropertyTesting| { &m.shrinking_rules },
                |m: &mut PropertyTesting| { &mut m.shrinking_rules },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PropertyTesting>(
                "TestingEnhancement.PropertyTesting",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PropertyTesting {
        const NAME: &'static str = "PropertyTesting";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.invariants.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.generators.insert(key, value);
                    },
                    24 => {
                        self.test_iterations = is.read_uint32()?;
                    },
                    34 => {
                        self.properties.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.shrinking_rules.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.invariants {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.generators {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.test_iterations != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.test_iterations);
            }
            for value in &self.properties {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.shrinking_rules {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.invariants {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.generators {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.test_iterations != 0 {
                os.write_uint32(3, self.test_iterations)?;
            }
            for v in &self.properties {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.shrinking_rules {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PropertyTesting {
            PropertyTesting::new()
        }

        fn clear(&mut self) {
            self.invariants.clear();
            self.generators.clear();
            self.test_iterations = 0;
            self.properties.clear();
            self.shrinking_rules.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PropertyTesting {
            static instance: ::protobuf::rt::Lazy<PropertyTesting> = ::protobuf::rt::Lazy::new();
            instance.get(PropertyTesting::new)
        }
    }

    impl ::protobuf::MessageFull for PropertyTesting {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestingEnhancement.PropertyTesting").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PropertyTesting {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PropertyTesting {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.TestingEnhancement.FuzzTesting)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FuzzTesting {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.FuzzTesting.fuzz_targets)
        pub fuzz_targets: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.FuzzTesting.mutation_strategies)
        pub mutation_strategies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.FuzzTesting.fuzz_iterations)
        pub fuzz_iterations: u32,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.FuzzTesting.corpus)
        pub corpus: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.FuzzTesting.coverage_goals)
        pub coverage_goals: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.TestingEnhancement.FuzzTesting.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FuzzTesting {
        fn default() -> &'a FuzzTesting {
            <FuzzTesting as ::protobuf::Message>::default_instance()
        }
    }

    impl FuzzTesting {
        pub fn new() -> FuzzTesting {
            ::std::default::Default::default()
        }

        // repeated string fuzz_targets = 1;

        pub fn fuzz_targets(&self) -> &[::std::string::String] {
            &self.fuzz_targets
        }

        pub fn clear_fuzz_targets(&mut self) {
            self.fuzz_targets.clear();
        }

        // Param is passed by value, moved
        pub fn set_fuzz_targets(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.fuzz_targets = v;
        }

        // Mutable pointer to the field.
        pub fn mut_fuzz_targets(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.fuzz_targets
        }

        // Take field
        pub fn take_fuzz_targets(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.fuzz_targets, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingEnhancement.FuzzTesting.MutationStrategiesEntry mutation_strategies = 2;

        pub fn mutation_strategies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.mutation_strategies
        }

        pub fn clear_mutation_strategies(&mut self) {
            self.mutation_strategies.clear();
        }

        // Param is passed by value, moved
        pub fn set_mutation_strategies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.mutation_strategies = v;
        }

        // Mutable pointer to the field.
        pub fn mut_mutation_strategies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.mutation_strategies
        }

        // Take field
        pub fn take_mutation_strategies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.mutation_strategies, ::std::collections::HashMap::new())
        }

        // uint32 fuzz_iterations = 3;

        pub fn fuzz_iterations(&self) -> u32 {
            self.fuzz_iterations
        }

        pub fn clear_fuzz_iterations(&mut self) {
            self.fuzz_iterations = 0;
        }

        // Param is passed by value, moved
        pub fn set_fuzz_iterations(&mut self, v: u32) {
            self.fuzz_iterations = v;
        }

        // repeated string corpus = 4;

        pub fn corpus(&self) -> &[::std::string::String] {
            &self.corpus
        }

        pub fn clear_corpus(&mut self) {
            self.corpus.clear();
        }

        // Param is passed by value, moved
        pub fn set_corpus(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.corpus = v;
        }

        // Mutable pointer to the field.
        pub fn mut_corpus(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.corpus
        }

        // Take field
        pub fn take_corpus(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.corpus, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingEnhancement.FuzzTesting.CoverageGoalsEntry coverage_goals = 5;

        pub fn coverage_goals(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.coverage_goals
        }

        pub fn clear_coverage_goals(&mut self) {
            self.coverage_goals.clear();
        }

        // Param is passed by value, moved
        pub fn set_coverage_goals(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.coverage_goals = v;
        }

        // Mutable pointer to the field.
        pub fn mut_coverage_goals(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.coverage_goals
        }

        // Take field
        pub fn take_coverage_goals(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.coverage_goals, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "fuzz_targets",
                |m: &FuzzTesting| { &m.fuzz_targets },
                |m: &mut FuzzTesting| { &mut m.fuzz_targets },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "mutation_strategies",
                |m: &FuzzTesting| { &m.mutation_strategies },
                |m: &mut FuzzTesting| { &mut m.mutation_strategies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fuzz_iterations",
                |m: &FuzzTesting| { &m.fuzz_iterations },
                |m: &mut FuzzTesting| { &mut m.fuzz_iterations },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "corpus",
                |m: &FuzzTesting| { &m.corpus },
                |m: &mut FuzzTesting| { &mut m.corpus },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "coverage_goals",
                |m: &FuzzTesting| { &m.coverage_goals },
                |m: &mut FuzzTesting| { &mut m.coverage_goals },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FuzzTesting>(
                "TestingEnhancement.FuzzTesting",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FuzzTesting {
        const NAME: &'static str = "FuzzTesting";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.fuzz_targets.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.mutation_strategies.insert(key, value);
                    },
                    24 => {
                        self.fuzz_iterations = is.read_uint32()?;
                    },
                    34 => {
                        self.corpus.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.coverage_goals.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.fuzz_targets {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.mutation_strategies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.fuzz_iterations != 0 {
                my_size += ::protobuf::rt::uint32_size(3, self.fuzz_iterations);
            }
            for value in &self.corpus {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.coverage_goals {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.fuzz_targets {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.mutation_strategies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.fuzz_iterations != 0 {
                os.write_uint32(3, self.fuzz_iterations)?;
            }
            for v in &self.corpus {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.coverage_goals {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FuzzTesting {
            FuzzTesting::new()
        }

        fn clear(&mut self) {
            self.fuzz_targets.clear();
            self.mutation_strategies.clear();
            self.fuzz_iterations = 0;
            self.corpus.clear();
            self.coverage_goals.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FuzzTesting {
            static instance: ::protobuf::rt::Lazy<FuzzTesting> = ::protobuf::rt::Lazy::new();
            instance.get(FuzzTesting::new)
        }
    }

    impl ::protobuf::MessageFull for FuzzTesting {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestingEnhancement.FuzzTesting").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FuzzTesting {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FuzzTesting {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.TestingEnhancement.TestOracle)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestOracle {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.TestOracle.validation_rules)
        pub validation_rules: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.TestOracle.expected_behaviors)
        pub expected_behaviors: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.TestOracle.invariant_checks)
        pub invariant_checks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.TestOracle.strict_validation)
        pub strict_validation: bool,
        // @@protoc_insertion_point(field:kymera_mappings.TestingEnhancement.TestOracle.test_matrices)
        pub test_matrices: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.TestingEnhancement.TestOracle.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestOracle {
        fn default() -> &'a TestOracle {
            <TestOracle as ::protobuf::Message>::default_instance()
        }
    }

    impl TestOracle {
        pub fn new() -> TestOracle {
            ::std::default::Default::default()
        }

        // repeated string validation_rules = 1;

        pub fn validation_rules(&self) -> &[::std::string::String] {
            &self.validation_rules
        }

        pub fn clear_validation_rules(&mut self) {
            self.validation_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_validation_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.validation_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_validation_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.validation_rules
        }

        // Take field
        pub fn take_validation_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.validation_rules, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.TestingEnhancement.TestOracle.ExpectedBehaviorsEntry expected_behaviors = 2;

        pub fn expected_behaviors(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.expected_behaviors
        }

        pub fn clear_expected_behaviors(&mut self) {
            self.expected_behaviors.clear();
        }

        // Param is passed by value, moved
        pub fn set_expected_behaviors(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.expected_behaviors = v;
        }

        // Mutable pointer to the field.
        pub fn mut_expected_behaviors(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.expected_behaviors
        }

        // Take field
        pub fn take_expected_behaviors(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.expected_behaviors, ::std::collections::HashMap::new())
        }

        // repeated string invariant_checks = 3;

        pub fn invariant_checks(&self) -> &[::std::string::String] {
            &self.invariant_checks
        }

        pub fn clear_invariant_checks(&mut self) {
            self.invariant_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_invariant_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.invariant_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_invariant_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.invariant_checks
        }

        // Take field
        pub fn take_invariant_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.invariant_checks, ::std::vec::Vec::new())
        }

        // bool strict_validation = 4;

        pub fn strict_validation(&self) -> bool {
            self.strict_validation
        }

        pub fn clear_strict_validation(&mut self) {
            self.strict_validation = false;
        }

        // Param is passed by value, moved
        pub fn set_strict_validation(&mut self, v: bool) {
            self.strict_validation = v;
        }

        // repeated .kymera_mappings.TestingEnhancement.TestOracle.TestMatricesEntry test_matrices = 5;

        pub fn test_matrices(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.test_matrices
        }

        pub fn clear_test_matrices(&mut self) {
            self.test_matrices.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_matrices(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.test_matrices = v;
        }

        // Mutable pointer to the field.
        pub fn mut_test_matrices(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.test_matrices
        }

        // Take field
        pub fn take_test_matrices(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.test_matrices, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "validation_rules",
                |m: &TestOracle| { &m.validation_rules },
                |m: &mut TestOracle| { &mut m.validation_rules },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "expected_behaviors",
                |m: &TestOracle| { &m.expected_behaviors },
                |m: &mut TestOracle| { &mut m.expected_behaviors },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "invariant_checks",
                |m: &TestOracle| { &m.invariant_checks },
                |m: &mut TestOracle| { &mut m.invariant_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "strict_validation",
                |m: &TestOracle| { &m.strict_validation },
                |m: &mut TestOracle| { &mut m.strict_validation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "test_matrices",
                |m: &TestOracle| { &m.test_matrices },
                |m: &mut TestOracle| { &mut m.test_matrices },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestOracle>(
                "TestingEnhancement.TestOracle",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestOracle {
        const NAME: &'static str = "TestOracle";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.validation_rules.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.expected_behaviors.insert(key, value);
                    },
                    26 => {
                        self.invariant_checks.push(is.read_string()?);
                    },
                    32 => {
                        self.strict_validation = is.read_bool()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.test_matrices.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.validation_rules {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.expected_behaviors {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.invariant_checks {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if self.strict_validation != false {
                my_size += 1 + 1;
            }
            for (k, v) in &self.test_matrices {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.validation_rules {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.expected_behaviors {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.invariant_checks {
                os.write_string(3, &v)?;
            };
            if self.strict_validation != false {
                os.write_bool(4, self.strict_validation)?;
            }
            for (k, v) in &self.test_matrices {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestOracle {
            TestOracle::new()
        }

        fn clear(&mut self) {
            self.validation_rules.clear();
            self.expected_behaviors.clear();
            self.invariant_checks.clear();
            self.strict_validation = false;
            self.test_matrices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestOracle {
            static instance: ::protobuf::rt::Lazy<TestOracle> = ::protobuf::rt::Lazy::new();
            instance.get(TestOracle::new)
        }
    }

    impl ::protobuf::MessageFull for TestOracle {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("TestingEnhancement.TestOracle").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestOracle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestOracle {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.LanguageIntegration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LanguageIntegration {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.LanguageIntegration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LanguageIntegration {
    fn default() -> &'a LanguageIntegration {
        <LanguageIntegration as ::protobuf::Message>::default_instance()
    }
}

impl LanguageIntegration {
    pub fn new() -> LanguageIntegration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanguageIntegration>(
            "LanguageIntegration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LanguageIntegration {
    const NAME: &'static str = "LanguageIntegration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LanguageIntegration {
        LanguageIntegration::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LanguageIntegration {
        static instance: LanguageIntegration = LanguageIntegration {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LanguageIntegration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LanguageIntegration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LanguageIntegration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LanguageIntegration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LanguageIntegration`
pub mod language_integration {
    // @@protoc_insertion_point(message:kymera_mappings.LanguageIntegration.FFIDefinition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FFIDefinition {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.FFIDefinition.abi_specifications)
        pub abi_specifications: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.FFIDefinition.type_mappings)
        pub type_mappings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.FFIDefinition.calling_conventions)
        pub calling_conventions: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.FFIDefinition.safety_checks)
        pub safety_checks: bool,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.FFIDefinition.marshalling_rules)
        pub marshalling_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageIntegration.FFIDefinition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FFIDefinition {
        fn default() -> &'a FFIDefinition {
            <FFIDefinition as ::protobuf::Message>::default_instance()
        }
    }

    impl FFIDefinition {
        pub fn new() -> FFIDefinition {
            ::std::default::Default::default()
        }

        // repeated string abi_specifications = 1;

        pub fn abi_specifications(&self) -> &[::std::string::String] {
            &self.abi_specifications
        }

        pub fn clear_abi_specifications(&mut self) {
            self.abi_specifications.clear();
        }

        // Param is passed by value, moved
        pub fn set_abi_specifications(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.abi_specifications = v;
        }

        // Mutable pointer to the field.
        pub fn mut_abi_specifications(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.abi_specifications
        }

        // Take field
        pub fn take_abi_specifications(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.abi_specifications, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.LanguageIntegration.FFIDefinition.TypeMappingsEntry type_mappings = 2;

        pub fn type_mappings(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.type_mappings
        }

        pub fn clear_type_mappings(&mut self) {
            self.type_mappings.clear();
        }

        // Param is passed by value, moved
        pub fn set_type_mappings(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.type_mappings = v;
        }

        // Mutable pointer to the field.
        pub fn mut_type_mappings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.type_mappings
        }

        // Take field
        pub fn take_type_mappings(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.type_mappings, ::std::collections::HashMap::new())
        }

        // repeated string calling_conventions = 3;

        pub fn calling_conventions(&self) -> &[::std::string::String] {
            &self.calling_conventions
        }

        pub fn clear_calling_conventions(&mut self) {
            self.calling_conventions.clear();
        }

        // Param is passed by value, moved
        pub fn set_calling_conventions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.calling_conventions = v;
        }

        // Mutable pointer to the field.
        pub fn mut_calling_conventions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.calling_conventions
        }

        // Take field
        pub fn take_calling_conventions(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.calling_conventions, ::std::vec::Vec::new())
        }

        // bool safety_checks = 4;

        pub fn safety_checks(&self) -> bool {
            self.safety_checks
        }

        pub fn clear_safety_checks(&mut self) {
            self.safety_checks = false;
        }

        // Param is passed by value, moved
        pub fn set_safety_checks(&mut self, v: bool) {
            self.safety_checks = v;
        }

        // repeated .kymera_mappings.LanguageIntegration.FFIDefinition.MarshallingRulesEntry marshalling_rules = 5;

        pub fn marshalling_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.marshalling_rules
        }

        pub fn clear_marshalling_rules(&mut self) {
            self.marshalling_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_marshalling_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.marshalling_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_marshalling_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.marshalling_rules
        }

        // Take field
        pub fn take_marshalling_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.marshalling_rules, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "abi_specifications",
                |m: &FFIDefinition| { &m.abi_specifications },
                |m: &mut FFIDefinition| { &mut m.abi_specifications },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "type_mappings",
                |m: &FFIDefinition| { &m.type_mappings },
                |m: &mut FFIDefinition| { &mut m.type_mappings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "calling_conventions",
                |m: &FFIDefinition| { &m.calling_conventions },
                |m: &mut FFIDefinition| { &mut m.calling_conventions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "safety_checks",
                |m: &FFIDefinition| { &m.safety_checks },
                |m: &mut FFIDefinition| { &mut m.safety_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "marshalling_rules",
                |m: &FFIDefinition| { &m.marshalling_rules },
                |m: &mut FFIDefinition| { &mut m.marshalling_rules },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FFIDefinition>(
                "LanguageIntegration.FFIDefinition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FFIDefinition {
        const NAME: &'static str = "FFIDefinition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.abi_specifications.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.type_mappings.insert(key, value);
                    },
                    26 => {
                        self.calling_conventions.push(is.read_string()?);
                    },
                    32 => {
                        self.safety_checks = is.read_bool()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.marshalling_rules.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.abi_specifications {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.type_mappings {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.calling_conventions {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if self.safety_checks != false {
                my_size += 1 + 1;
            }
            for (k, v) in &self.marshalling_rules {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.abi_specifications {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.type_mappings {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.calling_conventions {
                os.write_string(3, &v)?;
            };
            if self.safety_checks != false {
                os.write_bool(4, self.safety_checks)?;
            }
            for (k, v) in &self.marshalling_rules {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FFIDefinition {
            FFIDefinition::new()
        }

        fn clear(&mut self) {
            self.abi_specifications.clear();
            self.type_mappings.clear();
            self.calling_conventions.clear();
            self.safety_checks = false;
            self.marshalling_rules.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FFIDefinition {
            static instance: ::protobuf::rt::Lazy<FFIDefinition> = ::protobuf::rt::Lazy::new();
            instance.get(FFIDefinition::new)
        }
    }

    impl ::protobuf::MessageFull for FFIDefinition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageIntegration.FFIDefinition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FFIDefinition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FFIDefinition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageIntegration.InteropValidation)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InteropValidation {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.InteropValidation.compatibility_checks)
        pub compatibility_checks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.InteropValidation.conversion_rules)
        pub conversion_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.InteropValidation.strict_validation)
        pub strict_validation: bool,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.InteropValidation.boundary_checks)
        pub boundary_checks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.InteropValidation.validation_state)
        pub validation_state: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageIntegration.InteropValidation.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InteropValidation {
        fn default() -> &'a InteropValidation {
            <InteropValidation as ::protobuf::Message>::default_instance()
        }
    }

    impl InteropValidation {
        pub fn new() -> InteropValidation {
            ::std::default::Default::default()
        }

        // repeated string compatibility_checks = 1;

        pub fn compatibility_checks(&self) -> &[::std::string::String] {
            &self.compatibility_checks
        }

        pub fn clear_compatibility_checks(&mut self) {
            self.compatibility_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_compatibility_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.compatibility_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_compatibility_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.compatibility_checks
        }

        // Take field
        pub fn take_compatibility_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.compatibility_checks, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.LanguageIntegration.InteropValidation.ConversionRulesEntry conversion_rules = 2;

        pub fn conversion_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.conversion_rules
        }

        pub fn clear_conversion_rules(&mut self) {
            self.conversion_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_conversion_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.conversion_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_conversion_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.conversion_rules
        }

        // Take field
        pub fn take_conversion_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.conversion_rules, ::std::collections::HashMap::new())
        }

        // bool strict_validation = 3;

        pub fn strict_validation(&self) -> bool {
            self.strict_validation
        }

        pub fn clear_strict_validation(&mut self) {
            self.strict_validation = false;
        }

        // Param is passed by value, moved
        pub fn set_strict_validation(&mut self, v: bool) {
            self.strict_validation = v;
        }

        // repeated string boundary_checks = 4;

        pub fn boundary_checks(&self) -> &[::std::string::String] {
            &self.boundary_checks
        }

        pub fn clear_boundary_checks(&mut self) {
            self.boundary_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_boundary_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.boundary_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_boundary_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.boundary_checks
        }

        // Take field
        pub fn take_boundary_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.boundary_checks, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.LanguageIntegration.InteropValidation.ValidationStateEntry validation_state = 5;

        pub fn validation_state(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.validation_state
        }

        pub fn clear_validation_state(&mut self) {
            self.validation_state.clear();
        }

        // Param is passed by value, moved
        pub fn set_validation_state(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.validation_state = v;
        }

        // Mutable pointer to the field.
        pub fn mut_validation_state(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.validation_state
        }

        // Take field
        pub fn take_validation_state(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.validation_state, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "compatibility_checks",
                |m: &InteropValidation| { &m.compatibility_checks },
                |m: &mut InteropValidation| { &mut m.compatibility_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "conversion_rules",
                |m: &InteropValidation| { &m.conversion_rules },
                |m: &mut InteropValidation| { &mut m.conversion_rules },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "strict_validation",
                |m: &InteropValidation| { &m.strict_validation },
                |m: &mut InteropValidation| { &mut m.strict_validation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "boundary_checks",
                |m: &InteropValidation| { &m.boundary_checks },
                |m: &mut InteropValidation| { &mut m.boundary_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "validation_state",
                |m: &InteropValidation| { &m.validation_state },
                |m: &mut InteropValidation| { &mut m.validation_state },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InteropValidation>(
                "LanguageIntegration.InteropValidation",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InteropValidation {
        const NAME: &'static str = "InteropValidation";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.compatibility_checks.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.conversion_rules.insert(key, value);
                    },
                    24 => {
                        self.strict_validation = is.read_bool()?;
                    },
                    34 => {
                        self.boundary_checks.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.validation_state.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.compatibility_checks {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.conversion_rules {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.strict_validation != false {
                my_size += 1 + 1;
            }
            for value in &self.boundary_checks {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.validation_state {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.compatibility_checks {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.conversion_rules {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.strict_validation != false {
                os.write_bool(3, self.strict_validation)?;
            }
            for v in &self.boundary_checks {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.validation_state {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InteropValidation {
            InteropValidation::new()
        }

        fn clear(&mut self) {
            self.compatibility_checks.clear();
            self.conversion_rules.clear();
            self.strict_validation = false;
            self.boundary_checks.clear();
            self.validation_state.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InteropValidation {
            static instance: ::protobuf::rt::Lazy<InteropValidation> = ::protobuf::rt::Lazy::new();
            instance.get(InteropValidation::new)
        }
    }

    impl ::protobuf::MessageFull for InteropValidation {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageIntegration.InteropValidation").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InteropValidation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InteropValidation {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageIntegration.IntegrationContext)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct IntegrationContext {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.IntegrationContext.source_language)
        pub source_language: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.IntegrationContext.target_language)
        pub target_language: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.IntegrationContext.active_bindings)
        pub active_bindings: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.IntegrationContext.context_state)
        pub context_state: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageIntegration.IntegrationContext.safe_mode)
        pub safe_mode: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageIntegration.IntegrationContext.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IntegrationContext {
        fn default() -> &'a IntegrationContext {
            <IntegrationContext as ::protobuf::Message>::default_instance()
        }
    }

    impl IntegrationContext {
        pub fn new() -> IntegrationContext {
            ::std::default::Default::default()
        }

        // string source_language = 1;

        pub fn source_language(&self) -> &str {
            &self.source_language
        }

        pub fn clear_source_language(&mut self) {
            self.source_language.clear();
        }

        // Param is passed by value, moved
        pub fn set_source_language(&mut self, v: ::std::string::String) {
            self.source_language = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_source_language(&mut self) -> &mut ::std::string::String {
            &mut self.source_language
        }

        // Take field
        pub fn take_source_language(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.source_language, ::std::string::String::new())
        }

        // string target_language = 2;

        pub fn target_language(&self) -> &str {
            &self.target_language
        }

        pub fn clear_target_language(&mut self) {
            self.target_language.clear();
        }

        // Param is passed by value, moved
        pub fn set_target_language(&mut self, v: ::std::string::String) {
            self.target_language = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_target_language(&mut self) -> &mut ::std::string::String {
            &mut self.target_language
        }

        // Take field
        pub fn take_target_language(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.target_language, ::std::string::String::new())
        }

        // repeated string active_bindings = 3;

        pub fn active_bindings(&self) -> &[::std::string::String] {
            &self.active_bindings
        }

        pub fn clear_active_bindings(&mut self) {
            self.active_bindings.clear();
        }

        // Param is passed by value, moved
        pub fn set_active_bindings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.active_bindings = v;
        }

        // Mutable pointer to the field.
        pub fn mut_active_bindings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.active_bindings
        }

        // Take field
        pub fn take_active_bindings(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.active_bindings, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.LanguageIntegration.IntegrationContext.ContextStateEntry context_state = 4;

        pub fn context_state(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.context_state
        }

        pub fn clear_context_state(&mut self) {
            self.context_state.clear();
        }

        // Param is passed by value, moved
        pub fn set_context_state(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.context_state = v;
        }

        // Mutable pointer to the field.
        pub fn mut_context_state(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.context_state
        }

        // Take field
        pub fn take_context_state(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.context_state, ::std::collections::HashMap::new())
        }

        // bool safe_mode = 5;

        pub fn safe_mode(&self) -> bool {
            self.safe_mode
        }

        pub fn clear_safe_mode(&mut self) {
            self.safe_mode = false;
        }

        // Param is passed by value, moved
        pub fn set_safe_mode(&mut self, v: bool) {
            self.safe_mode = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "source_language",
                |m: &IntegrationContext| { &m.source_language },
                |m: &mut IntegrationContext| { &mut m.source_language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "target_language",
                |m: &IntegrationContext| { &m.target_language },
                |m: &mut IntegrationContext| { &mut m.target_language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "active_bindings",
                |m: &IntegrationContext| { &m.active_bindings },
                |m: &mut IntegrationContext| { &mut m.active_bindings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "context_state",
                |m: &IntegrationContext| { &m.context_state },
                |m: &mut IntegrationContext| { &mut m.context_state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "safe_mode",
                |m: &IntegrationContext| { &m.safe_mode },
                |m: &mut IntegrationContext| { &mut m.safe_mode },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IntegrationContext>(
                "LanguageIntegration.IntegrationContext",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for IntegrationContext {
        const NAME: &'static str = "IntegrationContext";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.source_language = is.read_string()?;
                    },
                    18 => {
                        self.target_language = is.read_string()?;
                    },
                    26 => {
                        self.active_bindings.push(is.read_string()?);
                    },
                    34 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.context_state.insert(key, value);
                    },
                    40 => {
                        self.safe_mode = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.source_language.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.source_language);
            }
            if !self.target_language.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.target_language);
            }
            for value in &self.active_bindings {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for (k, v) in &self.context_state {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.safe_mode != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.source_language.is_empty() {
                os.write_string(1, &self.source_language)?;
            }
            if !self.target_language.is_empty() {
                os.write_string(2, &self.target_language)?;
            }
            for v in &self.active_bindings {
                os.write_string(3, &v)?;
            };
            for (k, v) in &self.context_state {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(34)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.safe_mode != false {
                os.write_bool(5, self.safe_mode)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IntegrationContext {
            IntegrationContext::new()
        }

        fn clear(&mut self) {
            self.source_language.clear();
            self.target_language.clear();
            self.active_bindings.clear();
            self.context_state.clear();
            self.safe_mode = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IntegrationContext {
            static instance: ::protobuf::rt::Lazy<IntegrationContext> = ::protobuf::rt::Lazy::new();
            instance.get(IntegrationContext::new)
        }
    }

    impl ::protobuf::MessageFull for IntegrationContext {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageIntegration.IntegrationContext").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IntegrationContext {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for IntegrationContext {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:kymera_mappings.FFISystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FFISystem {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FFISystem {
    fn default() -> &'a FFISystem {
        <FFISystem as ::protobuf::Message>::default_instance()
    }
}

impl FFISystem {
    pub fn new() -> FFISystem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FFISystem>(
            "FFISystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FFISystem {
    const NAME: &'static str = "FFISystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FFISystem {
        FFISystem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FFISystem {
        static instance: FFISystem = FFISystem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FFISystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FFISystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FFISystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FFISystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FFISystem`
pub mod ffisystem {
    // @@protoc_insertion_point(message:kymera_mappings.FFISystem.FFIDefinition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FFIDefinition {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.FFIDefinition.abi_version)
        pub abi_version: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.FFIDefinition.supported_languages)
        pub supported_languages: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.FFIDefinition.calling_conventions)
        pub calling_conventions: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.FFIDefinition.safety_checks_enabled)
        pub safety_checks_enabled: bool,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.FFIDefinition.ffi_features)
        pub ffi_features: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.FFIDefinition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FFIDefinition {
        fn default() -> &'a FFIDefinition {
            <FFIDefinition as ::protobuf::Message>::default_instance()
        }
    }

    impl FFIDefinition {
        pub fn new() -> FFIDefinition {
            ::std::default::Default::default()
        }

        // string abi_version = 1;

        pub fn abi_version(&self) -> &str {
            &self.abi_version
        }

        pub fn clear_abi_version(&mut self) {
            self.abi_version.clear();
        }

        // Param is passed by value, moved
        pub fn set_abi_version(&mut self, v: ::std::string::String) {
            self.abi_version = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_abi_version(&mut self) -> &mut ::std::string::String {
            &mut self.abi_version
        }

        // Take field
        pub fn take_abi_version(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.abi_version, ::std::string::String::new())
        }

        // repeated string supported_languages = 2;

        pub fn supported_languages(&self) -> &[::std::string::String] {
            &self.supported_languages
        }

        pub fn clear_supported_languages(&mut self) {
            self.supported_languages.clear();
        }

        // Param is passed by value, moved
        pub fn set_supported_languages(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.supported_languages = v;
        }

        // Mutable pointer to the field.
        pub fn mut_supported_languages(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.supported_languages
        }

        // Take field
        pub fn take_supported_languages(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.supported_languages, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.FFISystem.FFIDefinition.CallingConventionsEntry calling_conventions = 3;

        pub fn calling_conventions(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.calling_conventions
        }

        pub fn clear_calling_conventions(&mut self) {
            self.calling_conventions.clear();
        }

        // Param is passed by value, moved
        pub fn set_calling_conventions(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.calling_conventions = v;
        }

        // Mutable pointer to the field.
        pub fn mut_calling_conventions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.calling_conventions
        }

        // Take field
        pub fn take_calling_conventions(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.calling_conventions, ::std::collections::HashMap::new())
        }

        // bool safety_checks_enabled = 4;

        pub fn safety_checks_enabled(&self) -> bool {
            self.safety_checks_enabled
        }

        pub fn clear_safety_checks_enabled(&mut self) {
            self.safety_checks_enabled = false;
        }

        // Param is passed by value, moved
        pub fn set_safety_checks_enabled(&mut self, v: bool) {
            self.safety_checks_enabled = v;
        }

        // repeated string ffi_features = 5;

        pub fn ffi_features(&self) -> &[::std::string::String] {
            &self.ffi_features
        }

        pub fn clear_ffi_features(&mut self) {
            self.ffi_features.clear();
        }

        // Param is passed by value, moved
        pub fn set_ffi_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.ffi_features = v;
        }

        // Mutable pointer to the field.
        pub fn mut_ffi_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.ffi_features
        }

        // Take field
        pub fn take_ffi_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.ffi_features, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "abi_version",
                |m: &FFIDefinition| { &m.abi_version },
                |m: &mut FFIDefinition| { &mut m.abi_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "supported_languages",
                |m: &FFIDefinition| { &m.supported_languages },
                |m: &mut FFIDefinition| { &mut m.supported_languages },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "calling_conventions",
                |m: &FFIDefinition| { &m.calling_conventions },
                |m: &mut FFIDefinition| { &mut m.calling_conventions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "safety_checks_enabled",
                |m: &FFIDefinition| { &m.safety_checks_enabled },
                |m: &mut FFIDefinition| { &mut m.safety_checks_enabled },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "ffi_features",
                |m: &FFIDefinition| { &m.ffi_features },
                |m: &mut FFIDefinition| { &mut m.ffi_features },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FFIDefinition>(
                "FFISystem.FFIDefinition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FFIDefinition {
        const NAME: &'static str = "FFIDefinition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.abi_version = is.read_string()?;
                    },
                    18 => {
                        self.supported_languages.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.calling_conventions.insert(key, value);
                    },
                    32 => {
                        self.safety_checks_enabled = is.read_bool()?;
                    },
                    42 => {
                        self.ffi_features.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.abi_version.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.abi_version);
            }
            for value in &self.supported_languages {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.calling_conventions {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.safety_checks_enabled != false {
                my_size += 1 + 1;
            }
            for value in &self.ffi_features {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.abi_version.is_empty() {
                os.write_string(1, &self.abi_version)?;
            }
            for v in &self.supported_languages {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.calling_conventions {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.safety_checks_enabled != false {
                os.write_bool(4, self.safety_checks_enabled)?;
            }
            for v in &self.ffi_features {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FFIDefinition {
            FFIDefinition::new()
        }

        fn clear(&mut self) {
            self.abi_version.clear();
            self.supported_languages.clear();
            self.calling_conventions.clear();
            self.safety_checks_enabled = false;
            self.ffi_features.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FFIDefinition {
            static instance: ::protobuf::rt::Lazy<FFIDefinition> = ::protobuf::rt::Lazy::new();
            instance.get(FFIDefinition::new)
        }
    }

    impl ::protobuf::MessageFull for FFIDefinition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FFISystem.FFIDefinition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FFIDefinition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FFIDefinition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.FFISystem.LanguageBinding)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LanguageBinding {
        // message oneof groups
        pub binding: ::std::option::Option<language_binding::Binding>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.LanguageBinding.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LanguageBinding {
        fn default() -> &'a LanguageBinding {
            <LanguageBinding as ::protobuf::Message>::default_instance()
        }
    }

    impl LanguageBinding {
        pub fn new() -> LanguageBinding {
            ::std::default::Default::default()
        }

        // .kymera_mappings.FFISystem.LanguageBinding.RustBinding rust = 1;

        pub fn rust(&self) -> &language_binding::RustBinding {
            match self.binding {
                ::std::option::Option::Some(language_binding::Binding::Rust(ref v)) => v,
                _ => <language_binding::RustBinding as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_rust(&mut self) {
            self.binding = ::std::option::Option::None;
        }

        pub fn has_rust(&self) -> bool {
            match self.binding {
                ::std::option::Option::Some(language_binding::Binding::Rust(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_rust(&mut self, v: language_binding::RustBinding) {
            self.binding = ::std::option::Option::Some(language_binding::Binding::Rust(v))
        }

        // Mutable pointer to the field.
        pub fn mut_rust(&mut self) -> &mut language_binding::RustBinding {
            if let ::std::option::Option::Some(language_binding::Binding::Rust(_)) = self.binding {
            } else {
                self.binding = ::std::option::Option::Some(language_binding::Binding::Rust(language_binding::RustBinding::new()));
            }
            match self.binding {
                ::std::option::Option::Some(language_binding::Binding::Rust(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_rust(&mut self) -> language_binding::RustBinding {
            if self.has_rust() {
                match self.binding.take() {
                    ::std::option::Option::Some(language_binding::Binding::Rust(v)) => v,
                    _ => panic!(),
                }
            } else {
                language_binding::RustBinding::new()
            }
        }

        // .kymera_mappings.FFISystem.LanguageBinding.PythonBinding python = 2;

        pub fn python(&self) -> &language_binding::PythonBinding {
            match self.binding {
                ::std::option::Option::Some(language_binding::Binding::Python(ref v)) => v,
                _ => <language_binding::PythonBinding as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_python(&mut self) {
            self.binding = ::std::option::Option::None;
        }

        pub fn has_python(&self) -> bool {
            match self.binding {
                ::std::option::Option::Some(language_binding::Binding::Python(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_python(&mut self, v: language_binding::PythonBinding) {
            self.binding = ::std::option::Option::Some(language_binding::Binding::Python(v))
        }

        // Mutable pointer to the field.
        pub fn mut_python(&mut self) -> &mut language_binding::PythonBinding {
            if let ::std::option::Option::Some(language_binding::Binding::Python(_)) = self.binding {
            } else {
                self.binding = ::std::option::Option::Some(language_binding::Binding::Python(language_binding::PythonBinding::new()));
            }
            match self.binding {
                ::std::option::Option::Some(language_binding::Binding::Python(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_python(&mut self) -> language_binding::PythonBinding {
            if self.has_python() {
                match self.binding.take() {
                    ::std::option::Option::Some(language_binding::Binding::Python(v)) => v,
                    _ => panic!(),
                }
            } else {
                language_binding::PythonBinding::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, language_binding::RustBinding>(
                "rust",
                LanguageBinding::has_rust,
                LanguageBinding::rust,
                LanguageBinding::mut_rust,
                LanguageBinding::set_rust,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, language_binding::PythonBinding>(
                "python",
                LanguageBinding::has_python,
                LanguageBinding::python,
                LanguageBinding::mut_python,
                LanguageBinding::set_python,
            ));
            oneofs.push(language_binding::Binding::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanguageBinding>(
                "FFISystem.LanguageBinding",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LanguageBinding {
        const NAME: &'static str = "LanguageBinding";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.binding = ::std::option::Option::Some(language_binding::Binding::Rust(is.read_message()?));
                    },
                    18 => {
                        self.binding = ::std::option::Option::Some(language_binding::Binding::Python(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.binding {
                match v {
                    &language_binding::Binding::Rust(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &language_binding::Binding::Python(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.binding {
                match v {
                    &language_binding::Binding::Rust(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &language_binding::Binding::Python(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LanguageBinding {
            LanguageBinding::new()
        }

        fn clear(&mut self) {
            self.binding = ::std::option::Option::None;
            self.binding = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LanguageBinding {
            static instance: LanguageBinding = LanguageBinding {
                binding: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LanguageBinding {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FFISystem.LanguageBinding").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LanguageBinding {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LanguageBinding {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `LanguageBinding`
    pub mod language_binding {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:kymera_mappings.FFISystem.LanguageBinding.binding)
        pub enum Binding {
            // @@protoc_insertion_point(oneof_field:kymera_mappings.FFISystem.LanguageBinding.rust)
            Rust(RustBinding),
            // @@protoc_insertion_point(oneof_field:kymera_mappings.FFISystem.LanguageBinding.python)
            Python(PythonBinding),
        }

        impl ::protobuf::Oneof for Binding {
        }

        impl ::protobuf::OneofFull for Binding {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::LanguageBinding as ::protobuf::MessageFull>::descriptor().oneof_by_name("binding").unwrap()).clone()
            }
        }

        impl Binding {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Binding>("binding")
            }
        }
        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.LanguageBinding.RustBinding)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RustBinding {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.RustBinding.crate_name)
            pub crate_name: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.RustBinding.crate_version)
            pub crate_version: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.RustBinding.exported_symbols)
            pub exported_symbols: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.RustBinding.type_mappings)
            pub type_mappings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.RustBinding.no_std)
            pub no_std: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.LanguageBinding.RustBinding.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RustBinding {
            fn default() -> &'a RustBinding {
                <RustBinding as ::protobuf::Message>::default_instance()
            }
        }

        impl RustBinding {
            pub fn new() -> RustBinding {
                ::std::default::Default::default()
            }

            // string crate_name = 1;

            pub fn crate_name(&self) -> &str {
                &self.crate_name
            }

            pub fn clear_crate_name(&mut self) {
                self.crate_name.clear();
            }

            // Param is passed by value, moved
            pub fn set_crate_name(&mut self, v: ::std::string::String) {
                self.crate_name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_crate_name(&mut self) -> &mut ::std::string::String {
                &mut self.crate_name
            }

            // Take field
            pub fn take_crate_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.crate_name, ::std::string::String::new())
            }

            // string crate_version = 2;

            pub fn crate_version(&self) -> &str {
                &self.crate_version
            }

            pub fn clear_crate_version(&mut self) {
                self.crate_version.clear();
            }

            // Param is passed by value, moved
            pub fn set_crate_version(&mut self, v: ::std::string::String) {
                self.crate_version = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_crate_version(&mut self) -> &mut ::std::string::String {
                &mut self.crate_version
            }

            // Take field
            pub fn take_crate_version(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.crate_version, ::std::string::String::new())
            }

            // repeated string exported_symbols = 3;

            pub fn exported_symbols(&self) -> &[::std::string::String] {
                &self.exported_symbols
            }

            pub fn clear_exported_symbols(&mut self) {
                self.exported_symbols.clear();
            }

            // Param is passed by value, moved
            pub fn set_exported_symbols(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.exported_symbols = v;
            }

            // Mutable pointer to the field.
            pub fn mut_exported_symbols(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.exported_symbols
            }

            // Take field
            pub fn take_exported_symbols(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.exported_symbols, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.LanguageBinding.RustBinding.TypeMappingsEntry type_mappings = 4;

            pub fn type_mappings(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.type_mappings
            }

            pub fn clear_type_mappings(&mut self) {
                self.type_mappings.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_mappings(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.type_mappings = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_mappings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.type_mappings
            }

            // Take field
            pub fn take_type_mappings(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.type_mappings, ::std::collections::HashMap::new())
            }

            // bool no_std = 5;

            pub fn no_std(&self) -> bool {
                self.no_std
            }

            pub fn clear_no_std(&mut self) {
                self.no_std = false;
            }

            // Param is passed by value, moved
            pub fn set_no_std(&mut self, v: bool) {
                self.no_std = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "crate_name",
                    |m: &RustBinding| { &m.crate_name },
                    |m: &mut RustBinding| { &mut m.crate_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "crate_version",
                    |m: &RustBinding| { &m.crate_version },
                    |m: &mut RustBinding| { &mut m.crate_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "exported_symbols",
                    |m: &RustBinding| { &m.exported_symbols },
                    |m: &mut RustBinding| { &mut m.exported_symbols },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "type_mappings",
                    |m: &RustBinding| { &m.type_mappings },
                    |m: &mut RustBinding| { &mut m.type_mappings },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "no_std",
                    |m: &RustBinding| { &m.no_std },
                    |m: &mut RustBinding| { &mut m.no_std },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RustBinding>(
                    "FFISystem.LanguageBinding.RustBinding",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RustBinding {
            const NAME: &'static str = "RustBinding";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.crate_name = is.read_string()?;
                        },
                        18 => {
                            self.crate_version = is.read_string()?;
                        },
                        26 => {
                            self.exported_symbols.push(is.read_string()?);
                        },
                        34 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.type_mappings.insert(key, value);
                        },
                        40 => {
                            self.no_std = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.crate_name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.crate_name);
                }
                if !self.crate_version.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.crate_version);
                }
                for value in &self.exported_symbols {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for (k, v) in &self.type_mappings {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.no_std != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.crate_name.is_empty() {
                    os.write_string(1, &self.crate_name)?;
                }
                if !self.crate_version.is_empty() {
                    os.write_string(2, &self.crate_version)?;
                }
                for v in &self.exported_symbols {
                    os.write_string(3, &v)?;
                };
                for (k, v) in &self.type_mappings {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(34)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.no_std != false {
                    os.write_bool(5, self.no_std)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RustBinding {
                RustBinding::new()
            }

            fn clear(&mut self) {
                self.crate_name.clear();
                self.crate_version.clear();
                self.exported_symbols.clear();
                self.type_mappings.clear();
                self.no_std = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RustBinding {
                static instance: ::protobuf::rt::Lazy<RustBinding> = ::protobuf::rt::Lazy::new();
                instance.get(RustBinding::new)
            }
        }

        impl ::protobuf::MessageFull for RustBinding {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.LanguageBinding.RustBinding").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RustBinding {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RustBinding {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.LanguageBinding.PythonBinding)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PythonBinding {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.PythonBinding.module_name)
            pub module_name: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.PythonBinding.module_version)
            pub module_version: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.PythonBinding.exported_functions)
            pub exported_functions: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.PythonBinding.type_conversions)
            pub type_conversions: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.LanguageBinding.PythonBinding.gil_release)
            pub gil_release: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.LanguageBinding.PythonBinding.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PythonBinding {
            fn default() -> &'a PythonBinding {
                <PythonBinding as ::protobuf::Message>::default_instance()
            }
        }

        impl PythonBinding {
            pub fn new() -> PythonBinding {
                ::std::default::Default::default()
            }

            // string module_name = 1;

            pub fn module_name(&self) -> &str {
                &self.module_name
            }

            pub fn clear_module_name(&mut self) {
                self.module_name.clear();
            }

            // Param is passed by value, moved
            pub fn set_module_name(&mut self, v: ::std::string::String) {
                self.module_name = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
                &mut self.module_name
            }

            // Take field
            pub fn take_module_name(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.module_name, ::std::string::String::new())
            }

            // string module_version = 2;

            pub fn module_version(&self) -> &str {
                &self.module_version
            }

            pub fn clear_module_version(&mut self) {
                self.module_version.clear();
            }

            // Param is passed by value, moved
            pub fn set_module_version(&mut self, v: ::std::string::String) {
                self.module_version = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_module_version(&mut self) -> &mut ::std::string::String {
                &mut self.module_version
            }

            // Take field
            pub fn take_module_version(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.module_version, ::std::string::String::new())
            }

            // repeated string exported_functions = 3;

            pub fn exported_functions(&self) -> &[::std::string::String] {
                &self.exported_functions
            }

            pub fn clear_exported_functions(&mut self) {
                self.exported_functions.clear();
            }

            // Param is passed by value, moved
            pub fn set_exported_functions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.exported_functions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_exported_functions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.exported_functions
            }

            // Take field
            pub fn take_exported_functions(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.exported_functions, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.LanguageBinding.PythonBinding.TypeConversionsEntry type_conversions = 4;

            pub fn type_conversions(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.type_conversions
            }

            pub fn clear_type_conversions(&mut self) {
                self.type_conversions.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_conversions(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.type_conversions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_conversions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.type_conversions
            }

            // Take field
            pub fn take_type_conversions(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.type_conversions, ::std::collections::HashMap::new())
            }

            // bool gil_release = 5;

            pub fn gil_release(&self) -> bool {
                self.gil_release
            }

            pub fn clear_gil_release(&mut self) {
                self.gil_release = false;
            }

            // Param is passed by value, moved
            pub fn set_gil_release(&mut self, v: bool) {
                self.gil_release = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "module_name",
                    |m: &PythonBinding| { &m.module_name },
                    |m: &mut PythonBinding| { &mut m.module_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "module_version",
                    |m: &PythonBinding| { &m.module_version },
                    |m: &mut PythonBinding| { &mut m.module_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "exported_functions",
                    |m: &PythonBinding| { &m.exported_functions },
                    |m: &mut PythonBinding| { &mut m.exported_functions },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "type_conversions",
                    |m: &PythonBinding| { &m.type_conversions },
                    |m: &mut PythonBinding| { &mut m.type_conversions },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "gil_release",
                    |m: &PythonBinding| { &m.gil_release },
                    |m: &mut PythonBinding| { &mut m.gil_release },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PythonBinding>(
                    "FFISystem.LanguageBinding.PythonBinding",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PythonBinding {
            const NAME: &'static str = "PythonBinding";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.module_name = is.read_string()?;
                        },
                        18 => {
                            self.module_version = is.read_string()?;
                        },
                        26 => {
                            self.exported_functions.push(is.read_string()?);
                        },
                        34 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.type_conversions.insert(key, value);
                        },
                        40 => {
                            self.gil_release = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.module_name.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.module_name);
                }
                if !self.module_version.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.module_version);
                }
                for value in &self.exported_functions {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for (k, v) in &self.type_conversions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.gil_release != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.module_name.is_empty() {
                    os.write_string(1, &self.module_name)?;
                }
                if !self.module_version.is_empty() {
                    os.write_string(2, &self.module_version)?;
                }
                for v in &self.exported_functions {
                    os.write_string(3, &v)?;
                };
                for (k, v) in &self.type_conversions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(34)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.gil_release != false {
                    os.write_bool(5, self.gil_release)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PythonBinding {
                PythonBinding::new()
            }

            fn clear(&mut self) {
                self.module_name.clear();
                self.module_version.clear();
                self.exported_functions.clear();
                self.type_conversions.clear();
                self.gil_release = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PythonBinding {
                static instance: ::protobuf::rt::Lazy<PythonBinding> = ::protobuf::rt::Lazy::new();
                instance.get(PythonBinding::new)
            }
        }

        impl ::protobuf::MessageFull for PythonBinding {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.LanguageBinding.PythonBinding").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PythonBinding {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PythonBinding {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.FFISystem.CrossLanguageMemory)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CrossLanguageMemory {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.memory_strategy)
        pub memory_strategy: ::protobuf::MessageField<cross_language_memory::MemoryStrategy>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.alignment_requirement)
        pub alignment_requirement: u32,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.protected_regions)
        pub protected_regions: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.leak_detection)
        pub leak_detection: bool,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.memory_policies)
        pub memory_policies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.CrossLanguageMemory.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CrossLanguageMemory {
        fn default() -> &'a CrossLanguageMemory {
            <CrossLanguageMemory as ::protobuf::Message>::default_instance()
        }
    }

    impl CrossLanguageMemory {
        pub fn new() -> CrossLanguageMemory {
            ::std::default::Default::default()
        }

        // .kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy memory_strategy = 1;

        pub fn memory_strategy(&self) -> &cross_language_memory::MemoryStrategy {
            self.memory_strategy.as_ref().unwrap_or_else(|| <cross_language_memory::MemoryStrategy as ::protobuf::Message>::default_instance())
        }

        pub fn clear_memory_strategy(&mut self) {
            self.memory_strategy.clear();
        }

        pub fn has_memory_strategy(&self) -> bool {
            self.memory_strategy.is_some()
        }

        // Param is passed by value, moved
        pub fn set_memory_strategy(&mut self, v: cross_language_memory::MemoryStrategy) {
            self.memory_strategy = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_memory_strategy(&mut self) -> &mut cross_language_memory::MemoryStrategy {
            self.memory_strategy.mut_or_insert_default()
        }

        // Take field
        pub fn take_memory_strategy(&mut self) -> cross_language_memory::MemoryStrategy {
            self.memory_strategy.take().unwrap_or_else(|| cross_language_memory::MemoryStrategy::new())
        }

        // uint32 alignment_requirement = 2;

        pub fn alignment_requirement(&self) -> u32 {
            self.alignment_requirement
        }

        pub fn clear_alignment_requirement(&mut self) {
            self.alignment_requirement = 0;
        }

        // Param is passed by value, moved
        pub fn set_alignment_requirement(&mut self, v: u32) {
            self.alignment_requirement = v;
        }

        // repeated string protected_regions = 3;

        pub fn protected_regions(&self) -> &[::std::string::String] {
            &self.protected_regions
        }

        pub fn clear_protected_regions(&mut self) {
            self.protected_regions.clear();
        }

        // Param is passed by value, moved
        pub fn set_protected_regions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.protected_regions = v;
        }

        // Mutable pointer to the field.
        pub fn mut_protected_regions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.protected_regions
        }

        // Take field
        pub fn take_protected_regions(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.protected_regions, ::std::vec::Vec::new())
        }

        // bool leak_detection = 4;

        pub fn leak_detection(&self) -> bool {
            self.leak_detection
        }

        pub fn clear_leak_detection(&mut self) {
            self.leak_detection = false;
        }

        // Param is passed by value, moved
        pub fn set_leak_detection(&mut self, v: bool) {
            self.leak_detection = v;
        }

        // repeated .kymera_mappings.FFISystem.CrossLanguageMemory.MemoryPoliciesEntry memory_policies = 5;

        pub fn memory_policies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.memory_policies
        }

        pub fn clear_memory_policies(&mut self) {
            self.memory_policies.clear();
        }

        // Param is passed by value, moved
        pub fn set_memory_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.memory_policies = v;
        }

        // Mutable pointer to the field.
        pub fn mut_memory_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.memory_policies
        }

        // Take field
        pub fn take_memory_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.memory_policies, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cross_language_memory::MemoryStrategy>(
                "memory_strategy",
                |m: &CrossLanguageMemory| { &m.memory_strategy },
                |m: &mut CrossLanguageMemory| { &mut m.memory_strategy },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "alignment_requirement",
                |m: &CrossLanguageMemory| { &m.alignment_requirement },
                |m: &mut CrossLanguageMemory| { &mut m.alignment_requirement },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "protected_regions",
                |m: &CrossLanguageMemory| { &m.protected_regions },
                |m: &mut CrossLanguageMemory| { &mut m.protected_regions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "leak_detection",
                |m: &CrossLanguageMemory| { &m.leak_detection },
                |m: &mut CrossLanguageMemory| { &mut m.leak_detection },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "memory_policies",
                |m: &CrossLanguageMemory| { &m.memory_policies },
                |m: &mut CrossLanguageMemory| { &mut m.memory_policies },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CrossLanguageMemory>(
                "FFISystem.CrossLanguageMemory",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CrossLanguageMemory {
        const NAME: &'static str = "CrossLanguageMemory";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.memory_strategy)?;
                    },
                    16 => {
                        self.alignment_requirement = is.read_uint32()?;
                    },
                    26 => {
                        self.protected_regions.push(is.read_string()?);
                    },
                    32 => {
                        self.leak_detection = is.read_bool()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.memory_policies.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.memory_strategy.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.alignment_requirement != 0 {
                my_size += ::protobuf::rt::uint32_size(2, self.alignment_requirement);
            }
            for value in &self.protected_regions {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if self.leak_detection != false {
                my_size += 1 + 1;
            }
            for (k, v) in &self.memory_policies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.memory_strategy.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if self.alignment_requirement != 0 {
                os.write_uint32(2, self.alignment_requirement)?;
            }
            for v in &self.protected_regions {
                os.write_string(3, &v)?;
            };
            if self.leak_detection != false {
                os.write_bool(4, self.leak_detection)?;
            }
            for (k, v) in &self.memory_policies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CrossLanguageMemory {
            CrossLanguageMemory::new()
        }

        fn clear(&mut self) {
            self.memory_strategy.clear();
            self.alignment_requirement = 0;
            self.protected_regions.clear();
            self.leak_detection = false;
            self.memory_policies.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CrossLanguageMemory {
            static instance: ::protobuf::rt::Lazy<CrossLanguageMemory> = ::protobuf::rt::Lazy::new();
            instance.get(CrossLanguageMemory::new)
        }
    }

    impl ::protobuf::MessageFull for CrossLanguageMemory {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FFISystem.CrossLanguageMemory").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CrossLanguageMemory {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CrossLanguageMemory {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CrossLanguageMemory`
    pub mod cross_language_memory {
        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MemoryStrategy {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.strategy)
            pub strategy: ::protobuf::EnumOrUnknown<memory_strategy::Strategy>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.bounds_checking)
            pub bounds_checking: bool,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.ownership_rules)
            pub ownership_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.cleanup_hooks)
            pub cleanup_hooks: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MemoryStrategy {
            fn default() -> &'a MemoryStrategy {
                <MemoryStrategy as ::protobuf::Message>::default_instance()
            }
        }

        impl MemoryStrategy {
            pub fn new() -> MemoryStrategy {
                ::std::default::Default::default()
            }

            // .kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy strategy = 1;

            pub fn strategy(&self) -> memory_strategy::Strategy {
                self.strategy.enum_value_or_default()
            }

            pub fn clear_strategy(&mut self) {
                self.strategy = ::protobuf::EnumOrUnknown::new(memory_strategy::Strategy::UNKNOWN);
            }

            // Param is passed by value, moved
            pub fn set_strategy(&mut self, v: memory_strategy::Strategy) {
                self.strategy = ::protobuf::EnumOrUnknown::new(v);
            }

            // bool bounds_checking = 2;

            pub fn bounds_checking(&self) -> bool {
                self.bounds_checking
            }

            pub fn clear_bounds_checking(&mut self) {
                self.bounds_checking = false;
            }

            // Param is passed by value, moved
            pub fn set_bounds_checking(&mut self, v: bool) {
                self.bounds_checking = v;
            }

            // repeated string ownership_rules = 3;

            pub fn ownership_rules(&self) -> &[::std::string::String] {
                &self.ownership_rules
            }

            pub fn clear_ownership_rules(&mut self) {
                self.ownership_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_ownership_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.ownership_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_ownership_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.ownership_rules
            }

            // Take field
            pub fn take_ownership_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.ownership_rules, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.CleanupHooksEntry cleanup_hooks = 4;

            pub fn cleanup_hooks(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.cleanup_hooks
            }

            pub fn clear_cleanup_hooks(&mut self) {
                self.cleanup_hooks.clear();
            }

            // Param is passed by value, moved
            pub fn set_cleanup_hooks(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.cleanup_hooks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cleanup_hooks(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.cleanup_hooks
            }

            // Take field
            pub fn take_cleanup_hooks(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.cleanup_hooks, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "strategy",
                    |m: &MemoryStrategy| { &m.strategy },
                    |m: &mut MemoryStrategy| { &mut m.strategy },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "bounds_checking",
                    |m: &MemoryStrategy| { &m.bounds_checking },
                    |m: &mut MemoryStrategy| { &mut m.bounds_checking },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "ownership_rules",
                    |m: &MemoryStrategy| { &m.ownership_rules },
                    |m: &mut MemoryStrategy| { &mut m.ownership_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "cleanup_hooks",
                    |m: &MemoryStrategy| { &m.cleanup_hooks },
                    |m: &mut MemoryStrategy| { &mut m.cleanup_hooks },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryStrategy>(
                    "FFISystem.CrossLanguageMemory.MemoryStrategy",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MemoryStrategy {
            const NAME: &'static str = "MemoryStrategy";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.strategy = is.read_enum_or_unknown()?;
                        },
                        16 => {
                            self.bounds_checking = is.read_bool()?;
                        },
                        26 => {
                            self.ownership_rules.push(is.read_string()?);
                        },
                        34 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.cleanup_hooks.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.strategy != ::protobuf::EnumOrUnknown::new(memory_strategy::Strategy::UNKNOWN) {
                    my_size += ::protobuf::rt::int32_size(1, self.strategy.value());
                }
                if self.bounds_checking != false {
                    my_size += 1 + 1;
                }
                for value in &self.ownership_rules {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for (k, v) in &self.cleanup_hooks {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.strategy != ::protobuf::EnumOrUnknown::new(memory_strategy::Strategy::UNKNOWN) {
                    os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.strategy))?;
                }
                if self.bounds_checking != false {
                    os.write_bool(2, self.bounds_checking)?;
                }
                for v in &self.ownership_rules {
                    os.write_string(3, &v)?;
                };
                for (k, v) in &self.cleanup_hooks {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(34)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MemoryStrategy {
                MemoryStrategy::new()
            }

            fn clear(&mut self) {
                self.strategy = ::protobuf::EnumOrUnknown::new(memory_strategy::Strategy::UNKNOWN);
                self.bounds_checking = false;
                self.ownership_rules.clear();
                self.cleanup_hooks.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MemoryStrategy {
                static instance: ::protobuf::rt::Lazy<MemoryStrategy> = ::protobuf::rt::Lazy::new();
                instance.get(MemoryStrategy::new)
            }
        }

        impl ::protobuf::MessageFull for MemoryStrategy {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.CrossLanguageMemory.MemoryStrategy").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MemoryStrategy {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MemoryStrategy {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        /// Nested message and enums of message `MemoryStrategy`
        pub mod memory_strategy {
            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy)
            pub enum Strategy {
                // @@protoc_insertion_point(enum_value:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy.UNKNOWN)
                UNKNOWN = 0,
                // @@protoc_insertion_point(enum_value:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy.COPY)
                COPY = 1,
                // @@protoc_insertion_point(enum_value:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy.ZERO_COPY)
                ZERO_COPY = 2,
                // @@protoc_insertion_point(enum_value:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy.SHARED_MEMORY)
                SHARED_MEMORY = 3,
                // @@protoc_insertion_point(enum_value:kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy.SMART_PTR)
                SMART_PTR = 4,
            }

            impl ::protobuf::Enum for Strategy {
                const NAME: &'static str = "Strategy";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<Strategy> {
                    match value {
                        0 => ::std::option::Option::Some(Strategy::UNKNOWN),
                        1 => ::std::option::Option::Some(Strategy::COPY),
                        2 => ::std::option::Option::Some(Strategy::ZERO_COPY),
                        3 => ::std::option::Option::Some(Strategy::SHARED_MEMORY),
                        4 => ::std::option::Option::Some(Strategy::SMART_PTR),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<Strategy> {
                    match str {
                        "UNKNOWN" => ::std::option::Option::Some(Strategy::UNKNOWN),
                        "COPY" => ::std::option::Option::Some(Strategy::COPY),
                        "ZERO_COPY" => ::std::option::Option::Some(Strategy::ZERO_COPY),
                        "SHARED_MEMORY" => ::std::option::Option::Some(Strategy::SHARED_MEMORY),
                        "SMART_PTR" => ::std::option::Option::Some(Strategy::SMART_PTR),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [Strategy] = &[
                    Strategy::UNKNOWN,
                    Strategy::COPY,
                    Strategy::ZERO_COPY,
                    Strategy::SHARED_MEMORY,
                    Strategy::SMART_PTR,
                ];
            }

            impl ::protobuf::EnumFull for Strategy {
                fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                    static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                    descriptor.get(|| super::super::super::file_descriptor().enum_by_package_relative_name("FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy").unwrap()).clone()
                }

                fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                    let index = *self as usize;
                    Self::enum_descriptor().value_by_index(index)
                }
            }

            impl ::std::default::Default for Strategy {
                fn default() -> Self {
                    Strategy::UNKNOWN
                }
            }

            impl Strategy {
                pub(in super::super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                    ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Strategy>("FFISystem.CrossLanguageMemory.MemoryStrategy.Strategy")
                }
            }
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.FFISystem.TypeBridge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TypeBridge {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.type_mappings)
        pub type_mappings: ::std::vec::Vec<type_bridge::TypeMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.strict_typing)
        pub strict_typing: bool,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.coercion_rules)
        pub coercion_rules: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.type_registry)
        pub type_registry: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.TypeBridge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TypeBridge {
        fn default() -> &'a TypeBridge {
            <TypeBridge as ::protobuf::Message>::default_instance()
        }
    }

    impl TypeBridge {
        pub fn new() -> TypeBridge {
            ::std::default::Default::default()
        }

        // repeated .kymera_mappings.FFISystem.TypeBridge.TypeMapping type_mappings = 1;

        pub fn type_mappings(&self) -> &[type_bridge::TypeMapping] {
            &self.type_mappings
        }

        pub fn clear_type_mappings(&mut self) {
            self.type_mappings.clear();
        }

        // Param is passed by value, moved
        pub fn set_type_mappings(&mut self, v: ::std::vec::Vec<type_bridge::TypeMapping>) {
            self.type_mappings = v;
        }

        // Mutable pointer to the field.
        pub fn mut_type_mappings(&mut self) -> &mut ::std::vec::Vec<type_bridge::TypeMapping> {
            &mut self.type_mappings
        }

        // Take field
        pub fn take_type_mappings(&mut self) -> ::std::vec::Vec<type_bridge::TypeMapping> {
            ::std::mem::replace(&mut self.type_mappings, ::std::vec::Vec::new())
        }

        // bool strict_typing = 2;

        pub fn strict_typing(&self) -> bool {
            self.strict_typing
        }

        pub fn clear_strict_typing(&mut self) {
            self.strict_typing = false;
        }

        // Param is passed by value, moved
        pub fn set_strict_typing(&mut self, v: bool) {
            self.strict_typing = v;
        }

        // repeated string coercion_rules = 3;

        pub fn coercion_rules(&self) -> &[::std::string::String] {
            &self.coercion_rules
        }

        pub fn clear_coercion_rules(&mut self) {
            self.coercion_rules.clear();
        }

        // Param is passed by value, moved
        pub fn set_coercion_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.coercion_rules = v;
        }

        // Mutable pointer to the field.
        pub fn mut_coercion_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.coercion_rules
        }

        // Take field
        pub fn take_coercion_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.coercion_rules, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.FFISystem.TypeBridge.TypeRegistryEntry type_registry = 4;

        pub fn type_registry(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.type_registry
        }

        pub fn clear_type_registry(&mut self) {
            self.type_registry.clear();
        }

        // Param is passed by value, moved
        pub fn set_type_registry(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.type_registry = v;
        }

        // Mutable pointer to the field.
        pub fn mut_type_registry(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.type_registry
        }

        // Take field
        pub fn take_type_registry(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.type_registry, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type_mappings",
                |m: &TypeBridge| { &m.type_mappings },
                |m: &mut TypeBridge| { &mut m.type_mappings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "strict_typing",
                |m: &TypeBridge| { &m.strict_typing },
                |m: &mut TypeBridge| { &mut m.strict_typing },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "coercion_rules",
                |m: &TypeBridge| { &m.coercion_rules },
                |m: &mut TypeBridge| { &mut m.coercion_rules },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "type_registry",
                |m: &TypeBridge| { &m.type_registry },
                |m: &mut TypeBridge| { &mut m.type_registry },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeBridge>(
                "FFISystem.TypeBridge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TypeBridge {
        const NAME: &'static str = "TypeBridge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_mappings.push(is.read_message()?);
                    },
                    16 => {
                        self.strict_typing = is.read_bool()?;
                    },
                    26 => {
                        self.coercion_rules.push(is.read_string()?);
                    },
                    34 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.type_registry.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.type_mappings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.strict_typing != false {
                my_size += 1 + 1;
            }
            for value in &self.coercion_rules {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for (k, v) in &self.type_registry {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.type_mappings {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if self.strict_typing != false {
                os.write_bool(2, self.strict_typing)?;
            }
            for v in &self.coercion_rules {
                os.write_string(3, &v)?;
            };
            for (k, v) in &self.type_registry {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(34)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TypeBridge {
            TypeBridge::new()
        }

        fn clear(&mut self) {
            self.type_mappings.clear();
            self.strict_typing = false;
            self.coercion_rules.clear();
            self.type_registry.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TypeBridge {
            static instance: ::protobuf::rt::Lazy<TypeBridge> = ::protobuf::rt::Lazy::new();
            instance.get(TypeBridge::new)
        }
    }

    impl ::protobuf::MessageFull for TypeBridge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FFISystem.TypeBridge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TypeBridge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TypeBridge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TypeBridge`
    pub mod type_bridge {
        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.TypeBridge.TypeMapping)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TypeMapping {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.TypeMapping.kymera_type)
            pub kymera_type: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.TypeMapping.foreign_type)
            pub foreign_type: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.TypeMapping.requires_conversion)
            pub requires_conversion: bool,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.TypeMapping.constraints)
            pub constraints: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.TypeBridge.TypeMapping.conversion_rules)
            pub conversion_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.TypeBridge.TypeMapping.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TypeMapping {
            fn default() -> &'a TypeMapping {
                <TypeMapping as ::protobuf::Message>::default_instance()
            }
        }

        impl TypeMapping {
            pub fn new() -> TypeMapping {
                ::std::default::Default::default()
            }

            // string kymera_type = 1;

            pub fn kymera_type(&self) -> &str {
                &self.kymera_type
            }

            pub fn clear_kymera_type(&mut self) {
                self.kymera_type.clear();
            }

            // Param is passed by value, moved
            pub fn set_kymera_type(&mut self, v: ::std::string::String) {
                self.kymera_type = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_kymera_type(&mut self) -> &mut ::std::string::String {
                &mut self.kymera_type
            }

            // Take field
            pub fn take_kymera_type(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.kymera_type, ::std::string::String::new())
            }

            // string foreign_type = 2;

            pub fn foreign_type(&self) -> &str {
                &self.foreign_type
            }

            pub fn clear_foreign_type(&mut self) {
                self.foreign_type.clear();
            }

            // Param is passed by value, moved
            pub fn set_foreign_type(&mut self, v: ::std::string::String) {
                self.foreign_type = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_foreign_type(&mut self) -> &mut ::std::string::String {
                &mut self.foreign_type
            }

            // Take field
            pub fn take_foreign_type(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.foreign_type, ::std::string::String::new())
            }

            // bool requires_conversion = 3;

            pub fn requires_conversion(&self) -> bool {
                self.requires_conversion
            }

            pub fn clear_requires_conversion(&mut self) {
                self.requires_conversion = false;
            }

            // Param is passed by value, moved
            pub fn set_requires_conversion(&mut self, v: bool) {
                self.requires_conversion = v;
            }

            // repeated string constraints = 4;

            pub fn constraints(&self) -> &[::std::string::String] {
                &self.constraints
            }

            pub fn clear_constraints(&mut self) {
                self.constraints.clear();
            }

            // Param is passed by value, moved
            pub fn set_constraints(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.constraints = v;
            }

            // Mutable pointer to the field.
            pub fn mut_constraints(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.constraints
            }

            // Take field
            pub fn take_constraints(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.constraints, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.TypeBridge.TypeMapping.ConversionRulesEntry conversion_rules = 5;

            pub fn conversion_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.conversion_rules
            }

            pub fn clear_conversion_rules(&mut self) {
                self.conversion_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_conversion_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.conversion_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_conversion_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.conversion_rules
            }

            // Take field
            pub fn take_conversion_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.conversion_rules, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "kymera_type",
                    |m: &TypeMapping| { &m.kymera_type },
                    |m: &mut TypeMapping| { &mut m.kymera_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "foreign_type",
                    |m: &TypeMapping| { &m.foreign_type },
                    |m: &mut TypeMapping| { &mut m.foreign_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "requires_conversion",
                    |m: &TypeMapping| { &m.requires_conversion },
                    |m: &mut TypeMapping| { &mut m.requires_conversion },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "constraints",
                    |m: &TypeMapping| { &m.constraints },
                    |m: &mut TypeMapping| { &mut m.constraints },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "conversion_rules",
                    |m: &TypeMapping| { &m.conversion_rules },
                    |m: &mut TypeMapping| { &mut m.conversion_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeMapping>(
                    "FFISystem.TypeBridge.TypeMapping",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TypeMapping {
            const NAME: &'static str = "TypeMapping";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.kymera_type = is.read_string()?;
                        },
                        18 => {
                            self.foreign_type = is.read_string()?;
                        },
                        24 => {
                            self.requires_conversion = is.read_bool()?;
                        },
                        34 => {
                            self.constraints.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.conversion_rules.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.kymera_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.kymera_type);
                }
                if !self.foreign_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.foreign_type);
                }
                if self.requires_conversion != false {
                    my_size += 1 + 1;
                }
                for value in &self.constraints {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.conversion_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.kymera_type.is_empty() {
                    os.write_string(1, &self.kymera_type)?;
                }
                if !self.foreign_type.is_empty() {
                    os.write_string(2, &self.foreign_type)?;
                }
                if self.requires_conversion != false {
                    os.write_bool(3, self.requires_conversion)?;
                }
                for v in &self.constraints {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.conversion_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TypeMapping {
                TypeMapping::new()
            }

            fn clear(&mut self) {
                self.kymera_type.clear();
                self.foreign_type.clear();
                self.requires_conversion = false;
                self.constraints.clear();
                self.conversion_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TypeMapping {
                static instance: ::protobuf::rt::Lazy<TypeMapping> = ::protobuf::rt::Lazy::new();
                instance.get(TypeMapping::new)
            }
        }

        impl ::protobuf::MessageFull for TypeMapping {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.TypeBridge.TypeMapping").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TypeMapping {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TypeMapping {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.FFISystem.ErrorBridge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ErrorBridge {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.error_mappings)
        pub error_mappings: ::std::vec::Vec<error_bridge::ErrorMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.catch_all_foreign)
        pub catch_all_foreign: bool,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.error_handlers)
        pub error_handlers: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.error_context)
        pub error_context: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.ErrorBridge.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ErrorBridge {
        fn default() -> &'a ErrorBridge {
            <ErrorBridge as ::protobuf::Message>::default_instance()
        }
    }

    impl ErrorBridge {
        pub fn new() -> ErrorBridge {
            ::std::default::Default::default()
        }

        // repeated .kymera_mappings.FFISystem.ErrorBridge.ErrorMapping error_mappings = 1;

        pub fn error_mappings(&self) -> &[error_bridge::ErrorMapping] {
            &self.error_mappings
        }

        pub fn clear_error_mappings(&mut self) {
            self.error_mappings.clear();
        }

        // Param is passed by value, moved
        pub fn set_error_mappings(&mut self, v: ::std::vec::Vec<error_bridge::ErrorMapping>) {
            self.error_mappings = v;
        }

        // Mutable pointer to the field.
        pub fn mut_error_mappings(&mut self) -> &mut ::std::vec::Vec<error_bridge::ErrorMapping> {
            &mut self.error_mappings
        }

        // Take field
        pub fn take_error_mappings(&mut self) -> ::std::vec::Vec<error_bridge::ErrorMapping> {
            ::std::mem::replace(&mut self.error_mappings, ::std::vec::Vec::new())
        }

        // bool catch_all_foreign = 2;

        pub fn catch_all_foreign(&self) -> bool {
            self.catch_all_foreign
        }

        pub fn clear_catch_all_foreign(&mut self) {
            self.catch_all_foreign = false;
        }

        // Param is passed by value, moved
        pub fn set_catch_all_foreign(&mut self, v: bool) {
            self.catch_all_foreign = v;
        }

        // repeated string error_handlers = 3;

        pub fn error_handlers(&self) -> &[::std::string::String] {
            &self.error_handlers
        }

        pub fn clear_error_handlers(&mut self) {
            self.error_handlers.clear();
        }

        // Param is passed by value, moved
        pub fn set_error_handlers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.error_handlers = v;
        }

        // Mutable pointer to the field.
        pub fn mut_error_handlers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.error_handlers
        }

        // Take field
        pub fn take_error_handlers(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.error_handlers, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.FFISystem.ErrorBridge.ErrorContextEntry error_context = 4;

        pub fn error_context(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.error_context
        }

        pub fn clear_error_context(&mut self) {
            self.error_context.clear();
        }

        // Param is passed by value, moved
        pub fn set_error_context(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.error_context = v;
        }

        // Mutable pointer to the field.
        pub fn mut_error_context(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.error_context
        }

        // Take field
        pub fn take_error_context(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.error_context, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "error_mappings",
                |m: &ErrorBridge| { &m.error_mappings },
                |m: &mut ErrorBridge| { &mut m.error_mappings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "catch_all_foreign",
                |m: &ErrorBridge| { &m.catch_all_foreign },
                |m: &mut ErrorBridge| { &mut m.catch_all_foreign },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "error_handlers",
                |m: &ErrorBridge| { &m.error_handlers },
                |m: &mut ErrorBridge| { &mut m.error_handlers },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "error_context",
                |m: &ErrorBridge| { &m.error_context },
                |m: &mut ErrorBridge| { &mut m.error_context },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorBridge>(
                "FFISystem.ErrorBridge",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ErrorBridge {
        const NAME: &'static str = "ErrorBridge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.error_mappings.push(is.read_message()?);
                    },
                    16 => {
                        self.catch_all_foreign = is.read_bool()?;
                    },
                    26 => {
                        self.error_handlers.push(is.read_string()?);
                    },
                    34 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.error_context.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.error_mappings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if self.catch_all_foreign != false {
                my_size += 1 + 1;
            }
            for value in &self.error_handlers {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for (k, v) in &self.error_context {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.error_mappings {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if self.catch_all_foreign != false {
                os.write_bool(2, self.catch_all_foreign)?;
            }
            for v in &self.error_handlers {
                os.write_string(3, &v)?;
            };
            for (k, v) in &self.error_context {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(34)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ErrorBridge {
            ErrorBridge::new()
        }

        fn clear(&mut self) {
            self.error_mappings.clear();
            self.catch_all_foreign = false;
            self.error_handlers.clear();
            self.error_context.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ErrorBridge {
            static instance: ::protobuf::rt::Lazy<ErrorBridge> = ::protobuf::rt::Lazy::new();
            instance.get(ErrorBridge::new)
        }
    }

    impl ::protobuf::MessageFull for ErrorBridge {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FFISystem.ErrorBridge").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ErrorBridge {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorBridge {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ErrorBridge`
    pub mod error_bridge {
        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.ErrorBridge.ErrorMapping)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorMapping {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.ErrorMapping.kymera_error)
            pub kymera_error: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.ErrorMapping.foreign_error)
            pub foreign_error: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.ErrorMapping.conversion_rules)
            pub conversion_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.ErrorBridge.ErrorMapping.propagate)
            pub propagate: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.ErrorBridge.ErrorMapping.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorMapping {
            fn default() -> &'a ErrorMapping {
                <ErrorMapping as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorMapping {
            pub fn new() -> ErrorMapping {
                ::std::default::Default::default()
            }

            // string kymera_error = 1;

            pub fn kymera_error(&self) -> &str {
                &self.kymera_error
            }

            pub fn clear_kymera_error(&mut self) {
                self.kymera_error.clear();
            }

            // Param is passed by value, moved
            pub fn set_kymera_error(&mut self, v: ::std::string::String) {
                self.kymera_error = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_kymera_error(&mut self) -> &mut ::std::string::String {
                &mut self.kymera_error
            }

            // Take field
            pub fn take_kymera_error(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.kymera_error, ::std::string::String::new())
            }

            // string foreign_error = 2;

            pub fn foreign_error(&self) -> &str {
                &self.foreign_error
            }

            pub fn clear_foreign_error(&mut self) {
                self.foreign_error.clear();
            }

            // Param is passed by value, moved
            pub fn set_foreign_error(&mut self, v: ::std::string::String) {
                self.foreign_error = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_foreign_error(&mut self) -> &mut ::std::string::String {
                &mut self.foreign_error
            }

            // Take field
            pub fn take_foreign_error(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.foreign_error, ::std::string::String::new())
            }

            // repeated string conversion_rules = 3;

            pub fn conversion_rules(&self) -> &[::std::string::String] {
                &self.conversion_rules
            }

            pub fn clear_conversion_rules(&mut self) {
                self.conversion_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_conversion_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.conversion_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_conversion_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.conversion_rules
            }

            // Take field
            pub fn take_conversion_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.conversion_rules, ::std::vec::Vec::new())
            }

            // bool propagate = 4;

            pub fn propagate(&self) -> bool {
                self.propagate
            }

            pub fn clear_propagate(&mut self) {
                self.propagate = false;
            }

            // Param is passed by value, moved
            pub fn set_propagate(&mut self, v: bool) {
                self.propagate = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "kymera_error",
                    |m: &ErrorMapping| { &m.kymera_error },
                    |m: &mut ErrorMapping| { &mut m.kymera_error },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "foreign_error",
                    |m: &ErrorMapping| { &m.foreign_error },
                    |m: &mut ErrorMapping| { &mut m.foreign_error },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "conversion_rules",
                    |m: &ErrorMapping| { &m.conversion_rules },
                    |m: &mut ErrorMapping| { &mut m.conversion_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "propagate",
                    |m: &ErrorMapping| { &m.propagate },
                    |m: &mut ErrorMapping| { &mut m.propagate },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorMapping>(
                    "FFISystem.ErrorBridge.ErrorMapping",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorMapping {
            const NAME: &'static str = "ErrorMapping";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.kymera_error = is.read_string()?;
                        },
                        18 => {
                            self.foreign_error = is.read_string()?;
                        },
                        26 => {
                            self.conversion_rules.push(is.read_string()?);
                        },
                        32 => {
                            self.propagate = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.kymera_error.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.kymera_error);
                }
                if !self.foreign_error.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.foreign_error);
                }
                for value in &self.conversion_rules {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                if self.propagate != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.kymera_error.is_empty() {
                    os.write_string(1, &self.kymera_error)?;
                }
                if !self.foreign_error.is_empty() {
                    os.write_string(2, &self.foreign_error)?;
                }
                for v in &self.conversion_rules {
                    os.write_string(3, &v)?;
                };
                if self.propagate != false {
                    os.write_bool(4, self.propagate)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorMapping {
                ErrorMapping::new()
            }

            fn clear(&mut self) {
                self.kymera_error.clear();
                self.foreign_error.clear();
                self.conversion_rules.clear();
                self.propagate = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorMapping {
                static instance: ErrorMapping = ErrorMapping {
                    kymera_error: ::std::string::String::new(),
                    foreign_error: ::std::string::String::new(),
                    conversion_rules: ::std::vec::Vec::new(),
                    propagate: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorMapping {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.ErrorBridge.ErrorMapping").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorMapping {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorMapping {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.FFISystem.BuildIntegration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BuildIntegration {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.dependencies)
        pub dependencies: ::protobuf::MessageField<build_integration::DependencyManager>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.build_config)
        pub build_config: ::protobuf::MessageField<build_integration::BuildConfig>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.build_steps)
        pub build_steps: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.build_cache)
        pub build_cache: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.incremental_build)
        pub incremental_build: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.BuildIntegration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BuildIntegration {
        fn default() -> &'a BuildIntegration {
            <BuildIntegration as ::protobuf::Message>::default_instance()
        }
    }

    impl BuildIntegration {
        pub fn new() -> BuildIntegration {
            ::std::default::Default::default()
        }

        // .kymera_mappings.FFISystem.BuildIntegration.DependencyManager dependencies = 1;

        pub fn dependencies(&self) -> &build_integration::DependencyManager {
            self.dependencies.as_ref().unwrap_or_else(|| <build_integration::DependencyManager as ::protobuf::Message>::default_instance())
        }

        pub fn clear_dependencies(&mut self) {
            self.dependencies.clear();
        }

        pub fn has_dependencies(&self) -> bool {
            self.dependencies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dependencies(&mut self, v: build_integration::DependencyManager) {
            self.dependencies = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dependencies(&mut self) -> &mut build_integration::DependencyManager {
            self.dependencies.mut_or_insert_default()
        }

        // Take field
        pub fn take_dependencies(&mut self) -> build_integration::DependencyManager {
            self.dependencies.take().unwrap_or_else(|| build_integration::DependencyManager::new())
        }

        // .kymera_mappings.FFISystem.BuildIntegration.BuildConfig build_config = 2;

        pub fn build_config(&self) -> &build_integration::BuildConfig {
            self.build_config.as_ref().unwrap_or_else(|| <build_integration::BuildConfig as ::protobuf::Message>::default_instance())
        }

        pub fn clear_build_config(&mut self) {
            self.build_config.clear();
        }

        pub fn has_build_config(&self) -> bool {
            self.build_config.is_some()
        }

        // Param is passed by value, moved
        pub fn set_build_config(&mut self, v: build_integration::BuildConfig) {
            self.build_config = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_build_config(&mut self) -> &mut build_integration::BuildConfig {
            self.build_config.mut_or_insert_default()
        }

        // Take field
        pub fn take_build_config(&mut self) -> build_integration::BuildConfig {
            self.build_config.take().unwrap_or_else(|| build_integration::BuildConfig::new())
        }

        // repeated string build_steps = 3;

        pub fn build_steps(&self) -> &[::std::string::String] {
            &self.build_steps
        }

        pub fn clear_build_steps(&mut self) {
            self.build_steps.clear();
        }

        // Param is passed by value, moved
        pub fn set_build_steps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.build_steps = v;
        }

        // Mutable pointer to the field.
        pub fn mut_build_steps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.build_steps
        }

        // Take field
        pub fn take_build_steps(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.build_steps, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.FFISystem.BuildIntegration.BuildCacheEntry build_cache = 4;

        pub fn build_cache(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.build_cache
        }

        pub fn clear_build_cache(&mut self) {
            self.build_cache.clear();
        }

        // Param is passed by value, moved
        pub fn set_build_cache(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.build_cache = v;
        }

        // Mutable pointer to the field.
        pub fn mut_build_cache(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.build_cache
        }

        // Take field
        pub fn take_build_cache(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.build_cache, ::std::collections::HashMap::new())
        }

        // bool incremental_build = 5;

        pub fn incremental_build(&self) -> bool {
            self.incremental_build
        }

        pub fn clear_incremental_build(&mut self) {
            self.incremental_build = false;
        }

        // Param is passed by value, moved
        pub fn set_incremental_build(&mut self, v: bool) {
            self.incremental_build = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, build_integration::DependencyManager>(
                "dependencies",
                |m: &BuildIntegration| { &m.dependencies },
                |m: &mut BuildIntegration| { &mut m.dependencies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, build_integration::BuildConfig>(
                "build_config",
                |m: &BuildIntegration| { &m.build_config },
                |m: &mut BuildIntegration| { &mut m.build_config },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "build_steps",
                |m: &BuildIntegration| { &m.build_steps },
                |m: &mut BuildIntegration| { &mut m.build_steps },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "build_cache",
                |m: &BuildIntegration| { &m.build_cache },
                |m: &mut BuildIntegration| { &mut m.build_cache },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "incremental_build",
                |m: &BuildIntegration| { &m.incremental_build },
                |m: &mut BuildIntegration| { &mut m.incremental_build },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildIntegration>(
                "FFISystem.BuildIntegration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BuildIntegration {
        const NAME: &'static str = "BuildIntegration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.dependencies)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.build_config)?;
                    },
                    26 => {
                        self.build_steps.push(is.read_string()?);
                    },
                    34 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.build_cache.insert(key, value);
                    },
                    40 => {
                        self.incremental_build = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.dependencies.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.build_config.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.build_steps {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for (k, v) in &self.build_cache {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.incremental_build != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.dependencies.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.build_config.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.build_steps {
                os.write_string(3, &v)?;
            };
            for (k, v) in &self.build_cache {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(34)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.incremental_build != false {
                os.write_bool(5, self.incremental_build)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BuildIntegration {
            BuildIntegration::new()
        }

        fn clear(&mut self) {
            self.dependencies.clear();
            self.build_config.clear();
            self.build_steps.clear();
            self.build_cache.clear();
            self.incremental_build = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BuildIntegration {
            static instance: ::protobuf::rt::Lazy<BuildIntegration> = ::protobuf::rt::Lazy::new();
            instance.get(BuildIntegration::new)
        }
    }

    impl ::protobuf::MessageFull for BuildIntegration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FFISystem.BuildIntegration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BuildIntegration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BuildIntegration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `BuildIntegration`
    pub mod build_integration {
        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.BuildIntegration.DependencyManager)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DependencyManager {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.DependencyManager.rust_crates)
            pub rust_crates: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.DependencyManager.python_packages)
            pub python_packages: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.DependencyManager.version_constraints)
            pub version_constraints: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.DependencyManager.auto_fetch)
            pub auto_fetch: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.BuildIntegration.DependencyManager.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DependencyManager {
            fn default() -> &'a DependencyManager {
                <DependencyManager as ::protobuf::Message>::default_instance()
            }
        }

        impl DependencyManager {
            pub fn new() -> DependencyManager {
                ::std::default::Default::default()
            }

            // repeated string rust_crates = 1;

            pub fn rust_crates(&self) -> &[::std::string::String] {
                &self.rust_crates
            }

            pub fn clear_rust_crates(&mut self) {
                self.rust_crates.clear();
            }

            // Param is passed by value, moved
            pub fn set_rust_crates(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.rust_crates = v;
            }

            // Mutable pointer to the field.
            pub fn mut_rust_crates(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.rust_crates
            }

            // Take field
            pub fn take_rust_crates(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.rust_crates, ::std::vec::Vec::new())
            }

            // repeated string python_packages = 2;

            pub fn python_packages(&self) -> &[::std::string::String] {
                &self.python_packages
            }

            pub fn clear_python_packages(&mut self) {
                self.python_packages.clear();
            }

            // Param is passed by value, moved
            pub fn set_python_packages(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.python_packages = v;
            }

            // Mutable pointer to the field.
            pub fn mut_python_packages(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.python_packages
            }

            // Take field
            pub fn take_python_packages(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.python_packages, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.BuildIntegration.DependencyManager.VersionConstraintsEntry version_constraints = 3;

            pub fn version_constraints(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.version_constraints
            }

            pub fn clear_version_constraints(&mut self) {
                self.version_constraints.clear();
            }

            // Param is passed by value, moved
            pub fn set_version_constraints(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.version_constraints = v;
            }

            // Mutable pointer to the field.
            pub fn mut_version_constraints(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.version_constraints
            }

            // Take field
            pub fn take_version_constraints(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.version_constraints, ::std::collections::HashMap::new())
            }

            // bool auto_fetch = 4;

            pub fn auto_fetch(&self) -> bool {
                self.auto_fetch
            }

            pub fn clear_auto_fetch(&mut self) {
                self.auto_fetch = false;
            }

            // Param is passed by value, moved
            pub fn set_auto_fetch(&mut self, v: bool) {
                self.auto_fetch = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "rust_crates",
                    |m: &DependencyManager| { &m.rust_crates },
                    |m: &mut DependencyManager| { &mut m.rust_crates },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "python_packages",
                    |m: &DependencyManager| { &m.python_packages },
                    |m: &mut DependencyManager| { &mut m.python_packages },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "version_constraints",
                    |m: &DependencyManager| { &m.version_constraints },
                    |m: &mut DependencyManager| { &mut m.version_constraints },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "auto_fetch",
                    |m: &DependencyManager| { &m.auto_fetch },
                    |m: &mut DependencyManager| { &mut m.auto_fetch },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DependencyManager>(
                    "FFISystem.BuildIntegration.DependencyManager",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DependencyManager {
            const NAME: &'static str = "DependencyManager";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.rust_crates.push(is.read_string()?);
                        },
                        18 => {
                            self.python_packages.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.version_constraints.insert(key, value);
                        },
                        32 => {
                            self.auto_fetch = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.rust_crates {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for value in &self.python_packages {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.version_constraints {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.auto_fetch != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.rust_crates {
                    os.write_string(1, &v)?;
                };
                for v in &self.python_packages {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.version_constraints {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.auto_fetch != false {
                    os.write_bool(4, self.auto_fetch)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DependencyManager {
                DependencyManager::new()
            }

            fn clear(&mut self) {
                self.rust_crates.clear();
                self.python_packages.clear();
                self.version_constraints.clear();
                self.auto_fetch = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DependencyManager {
                static instance: ::protobuf::rt::Lazy<DependencyManager> = ::protobuf::rt::Lazy::new();
                instance.get(DependencyManager::new)
            }
        }

        impl ::protobuf::MessageFull for DependencyManager {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.BuildIntegration.DependencyManager").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DependencyManager {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DependencyManager {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.BuildIntegration.BuildConfig)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct BuildConfig {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.BuildConfig.target_triple)
            pub target_triple: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.BuildConfig.build_flags)
            pub build_flags: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.BuildConfig.env_vars)
            pub env_vars: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.BuildIntegration.BuildConfig.debug_symbols)
            pub debug_symbols: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.BuildIntegration.BuildConfig.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a BuildConfig {
            fn default() -> &'a BuildConfig {
                <BuildConfig as ::protobuf::Message>::default_instance()
            }
        }

        impl BuildConfig {
            pub fn new() -> BuildConfig {
                ::std::default::Default::default()
            }

            // string target_triple = 1;

            pub fn target_triple(&self) -> &str {
                &self.target_triple
            }

            pub fn clear_target_triple(&mut self) {
                self.target_triple.clear();
            }

            // Param is passed by value, moved
            pub fn set_target_triple(&mut self, v: ::std::string::String) {
                self.target_triple = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_target_triple(&mut self) -> &mut ::std::string::String {
                &mut self.target_triple
            }

            // Take field
            pub fn take_target_triple(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.target_triple, ::std::string::String::new())
            }

            // repeated string build_flags = 2;

            pub fn build_flags(&self) -> &[::std::string::String] {
                &self.build_flags
            }

            pub fn clear_build_flags(&mut self) {
                self.build_flags.clear();
            }

            // Param is passed by value, moved
            pub fn set_build_flags(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.build_flags = v;
            }

            // Mutable pointer to the field.
            pub fn mut_build_flags(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.build_flags
            }

            // Take field
            pub fn take_build_flags(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.build_flags, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.BuildIntegration.BuildConfig.EnvVarsEntry env_vars = 3;

            pub fn env_vars(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.env_vars
            }

            pub fn clear_env_vars(&mut self) {
                self.env_vars.clear();
            }

            // Param is passed by value, moved
            pub fn set_env_vars(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.env_vars = v;
            }

            // Mutable pointer to the field.
            pub fn mut_env_vars(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.env_vars
            }

            // Take field
            pub fn take_env_vars(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.env_vars, ::std::collections::HashMap::new())
            }

            // bool debug_symbols = 4;

            pub fn debug_symbols(&self) -> bool {
                self.debug_symbols
            }

            pub fn clear_debug_symbols(&mut self) {
                self.debug_symbols = false;
            }

            // Param is passed by value, moved
            pub fn set_debug_symbols(&mut self, v: bool) {
                self.debug_symbols = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "target_triple",
                    |m: &BuildConfig| { &m.target_triple },
                    |m: &mut BuildConfig| { &mut m.target_triple },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "build_flags",
                    |m: &BuildConfig| { &m.build_flags },
                    |m: &mut BuildConfig| { &mut m.build_flags },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "env_vars",
                    |m: &BuildConfig| { &m.env_vars },
                    |m: &mut BuildConfig| { &mut m.env_vars },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "debug_symbols",
                    |m: &BuildConfig| { &m.debug_symbols },
                    |m: &mut BuildConfig| { &mut m.debug_symbols },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuildConfig>(
                    "FFISystem.BuildIntegration.BuildConfig",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for BuildConfig {
            const NAME: &'static str = "BuildConfig";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.target_triple = is.read_string()?;
                        },
                        18 => {
                            self.build_flags.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.env_vars.insert(key, value);
                        },
                        32 => {
                            self.debug_symbols = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.target_triple.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.target_triple);
                }
                for value in &self.build_flags {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.env_vars {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.debug_symbols != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.target_triple.is_empty() {
                    os.write_string(1, &self.target_triple)?;
                }
                for v in &self.build_flags {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.env_vars {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.debug_symbols != false {
                    os.write_bool(4, self.debug_symbols)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> BuildConfig {
                BuildConfig::new()
            }

            fn clear(&mut self) {
                self.target_triple.clear();
                self.build_flags.clear();
                self.env_vars.clear();
                self.debug_symbols = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static BuildConfig {
                static instance: ::protobuf::rt::Lazy<BuildConfig> = ::protobuf::rt::Lazy::new();
                instance.get(BuildConfig::new)
            }
        }

        impl ::protobuf::MessageFull for BuildConfig {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.BuildIntegration.BuildConfig").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for BuildConfig {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for BuildConfig {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.FFISystem.RuntimeVerification)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RuntimeVerification {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.safety)
        pub safety: ::protobuf::MessageField<runtime_verification::SafetyCheck>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.metrics)
        pub metrics: ::protobuf::MessageField<runtime_verification::PerformanceMetrics>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.verification_hooks)
        pub verification_hooks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.runtime_checks)
        pub runtime_checks: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.strict_mode)
        pub strict_mode: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.RuntimeVerification.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RuntimeVerification {
        fn default() -> &'a RuntimeVerification {
            <RuntimeVerification as ::protobuf::Message>::default_instance()
        }
    }

    impl RuntimeVerification {
        pub fn new() -> RuntimeVerification {
            ::std::default::Default::default()
        }

        // .kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck safety = 1;

        pub fn safety(&self) -> &runtime_verification::SafetyCheck {
            self.safety.as_ref().unwrap_or_else(|| <runtime_verification::SafetyCheck as ::protobuf::Message>::default_instance())
        }

        pub fn clear_safety(&mut self) {
            self.safety.clear();
        }

        pub fn has_safety(&self) -> bool {
            self.safety.is_some()
        }

        // Param is passed by value, moved
        pub fn set_safety(&mut self, v: runtime_verification::SafetyCheck) {
            self.safety = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_safety(&mut self) -> &mut runtime_verification::SafetyCheck {
            self.safety.mut_or_insert_default()
        }

        // Take field
        pub fn take_safety(&mut self) -> runtime_verification::SafetyCheck {
            self.safety.take().unwrap_or_else(|| runtime_verification::SafetyCheck::new())
        }

        // .kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics metrics = 2;

        pub fn metrics(&self) -> &runtime_verification::PerformanceMetrics {
            self.metrics.as_ref().unwrap_or_else(|| <runtime_verification::PerformanceMetrics as ::protobuf::Message>::default_instance())
        }

        pub fn clear_metrics(&mut self) {
            self.metrics.clear();
        }

        pub fn has_metrics(&self) -> bool {
            self.metrics.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metrics(&mut self, v: runtime_verification::PerformanceMetrics) {
            self.metrics = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metrics(&mut self) -> &mut runtime_verification::PerformanceMetrics {
            self.metrics.mut_or_insert_default()
        }

        // Take field
        pub fn take_metrics(&mut self) -> runtime_verification::PerformanceMetrics {
            self.metrics.take().unwrap_or_else(|| runtime_verification::PerformanceMetrics::new())
        }

        // repeated string verification_hooks = 3;

        pub fn verification_hooks(&self) -> &[::std::string::String] {
            &self.verification_hooks
        }

        pub fn clear_verification_hooks(&mut self) {
            self.verification_hooks.clear();
        }

        // Param is passed by value, moved
        pub fn set_verification_hooks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.verification_hooks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_verification_hooks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.verification_hooks
        }

        // Take field
        pub fn take_verification_hooks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.verification_hooks, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.FFISystem.RuntimeVerification.RuntimeChecksEntry runtime_checks = 4;

        pub fn runtime_checks(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.runtime_checks
        }

        pub fn clear_runtime_checks(&mut self) {
            self.runtime_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_runtime_checks(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.runtime_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_runtime_checks(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.runtime_checks
        }

        // Take field
        pub fn take_runtime_checks(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.runtime_checks, ::std::collections::HashMap::new())
        }

        // bool strict_mode = 5;

        pub fn strict_mode(&self) -> bool {
            self.strict_mode
        }

        pub fn clear_strict_mode(&mut self) {
            self.strict_mode = false;
        }

        // Param is passed by value, moved
        pub fn set_strict_mode(&mut self, v: bool) {
            self.strict_mode = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, runtime_verification::SafetyCheck>(
                "safety",
                |m: &RuntimeVerification| { &m.safety },
                |m: &mut RuntimeVerification| { &mut m.safety },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, runtime_verification::PerformanceMetrics>(
                "metrics",
                |m: &RuntimeVerification| { &m.metrics },
                |m: &mut RuntimeVerification| { &mut m.metrics },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "verification_hooks",
                |m: &RuntimeVerification| { &m.verification_hooks },
                |m: &mut RuntimeVerification| { &mut m.verification_hooks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "runtime_checks",
                |m: &RuntimeVerification| { &m.runtime_checks },
                |m: &mut RuntimeVerification| { &mut m.runtime_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "strict_mode",
                |m: &RuntimeVerification| { &m.strict_mode },
                |m: &mut RuntimeVerification| { &mut m.strict_mode },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeVerification>(
                "FFISystem.RuntimeVerification",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RuntimeVerification {
        const NAME: &'static str = "RuntimeVerification";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.safety)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                    },
                    26 => {
                        self.verification_hooks.push(is.read_string()?);
                    },
                    34 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.runtime_checks.insert(key, value);
                    },
                    40 => {
                        self.strict_mode = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.safety.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.metrics.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.verification_hooks {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            for (k, v) in &self.runtime_checks {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.strict_mode != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.safety.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.metrics.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.verification_hooks {
                os.write_string(3, &v)?;
            };
            for (k, v) in &self.runtime_checks {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(34)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.strict_mode != false {
                os.write_bool(5, self.strict_mode)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RuntimeVerification {
            RuntimeVerification::new()
        }

        fn clear(&mut self) {
            self.safety.clear();
            self.metrics.clear();
            self.verification_hooks.clear();
            self.runtime_checks.clear();
            self.strict_mode = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RuntimeVerification {
            static instance: ::protobuf::rt::Lazy<RuntimeVerification> = ::protobuf::rt::Lazy::new();
            instance.get(RuntimeVerification::new)
        }
    }

    impl ::protobuf::MessageFull for RuntimeVerification {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FFISystem.RuntimeVerification").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RuntimeVerification {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RuntimeVerification {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `RuntimeVerification`
    pub mod runtime_verification {
        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SafetyCheck {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck.boundary_checks)
            pub boundary_checks: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck.invariants)
            pub invariants: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck.null_checking)
            pub null_checking: bool,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck.sanitizers)
            pub sanitizers: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SafetyCheck {
            fn default() -> &'a SafetyCheck {
                <SafetyCheck as ::protobuf::Message>::default_instance()
            }
        }

        impl SafetyCheck {
            pub fn new() -> SafetyCheck {
                ::std::default::Default::default()
            }

            // repeated string boundary_checks = 1;

            pub fn boundary_checks(&self) -> &[::std::string::String] {
                &self.boundary_checks
            }

            pub fn clear_boundary_checks(&mut self) {
                self.boundary_checks.clear();
            }

            // Param is passed by value, moved
            pub fn set_boundary_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.boundary_checks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_boundary_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.boundary_checks
            }

            // Take field
            pub fn take_boundary_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.boundary_checks, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck.InvariantsEntry invariants = 2;

            pub fn invariants(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.invariants
            }

            pub fn clear_invariants(&mut self) {
                self.invariants.clear();
            }

            // Param is passed by value, moved
            pub fn set_invariants(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.invariants = v;
            }

            // Mutable pointer to the field.
            pub fn mut_invariants(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.invariants
            }

            // Take field
            pub fn take_invariants(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.invariants, ::std::collections::HashMap::new())
            }

            // bool null_checking = 3;

            pub fn null_checking(&self) -> bool {
                self.null_checking
            }

            pub fn clear_null_checking(&mut self) {
                self.null_checking = false;
            }

            // Param is passed by value, moved
            pub fn set_null_checking(&mut self, v: bool) {
                self.null_checking = v;
            }

            // repeated string sanitizers = 4;

            pub fn sanitizers(&self) -> &[::std::string::String] {
                &self.sanitizers
            }

            pub fn clear_sanitizers(&mut self) {
                self.sanitizers.clear();
            }

            // Param is passed by value, moved
            pub fn set_sanitizers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.sanitizers = v;
            }

            // Mutable pointer to the field.
            pub fn mut_sanitizers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.sanitizers
            }

            // Take field
            pub fn take_sanitizers(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.sanitizers, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "boundary_checks",
                    |m: &SafetyCheck| { &m.boundary_checks },
                    |m: &mut SafetyCheck| { &mut m.boundary_checks },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "invariants",
                    |m: &SafetyCheck| { &m.invariants },
                    |m: &mut SafetyCheck| { &mut m.invariants },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "null_checking",
                    |m: &SafetyCheck| { &m.null_checking },
                    |m: &mut SafetyCheck| { &mut m.null_checking },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "sanitizers",
                    |m: &SafetyCheck| { &m.sanitizers },
                    |m: &mut SafetyCheck| { &mut m.sanitizers },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SafetyCheck>(
                    "FFISystem.RuntimeVerification.SafetyCheck",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SafetyCheck {
            const NAME: &'static str = "SafetyCheck";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.boundary_checks.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.invariants.insert(key, value);
                        },
                        24 => {
                            self.null_checking = is.read_bool()?;
                        },
                        34 => {
                            self.sanitizers.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.boundary_checks {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.invariants {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.null_checking != false {
                    my_size += 1 + 1;
                }
                for value in &self.sanitizers {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.boundary_checks {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.invariants {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.null_checking != false {
                    os.write_bool(3, self.null_checking)?;
                }
                for v in &self.sanitizers {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SafetyCheck {
                SafetyCheck::new()
            }

            fn clear(&mut self) {
                self.boundary_checks.clear();
                self.invariants.clear();
                self.null_checking = false;
                self.sanitizers.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SafetyCheck {
                static instance: ::protobuf::rt::Lazy<SafetyCheck> = ::protobuf::rt::Lazy::new();
                instance.get(SafetyCheck::new)
            }
        }

        impl ::protobuf::MessageFull for SafetyCheck {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.RuntimeVerification.SafetyCheck").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SafetyCheck {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SafetyCheck {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PerformanceMetrics {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics.hot_paths)
            pub hot_paths: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics.thresholds)
            pub thresholds: ::std::collections::HashMap<::std::string::String, f64>,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics.profile_ffi)
            pub profile_ffi: bool,
            // @@protoc_insertion_point(field:kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics.optimizations)
            pub optimizations: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PerformanceMetrics {
            fn default() -> &'a PerformanceMetrics {
                <PerformanceMetrics as ::protobuf::Message>::default_instance()
            }
        }

        impl PerformanceMetrics {
            pub fn new() -> PerformanceMetrics {
                ::std::default::Default::default()
            }

            // repeated string hot_paths = 1;

            pub fn hot_paths(&self) -> &[::std::string::String] {
                &self.hot_paths
            }

            pub fn clear_hot_paths(&mut self) {
                self.hot_paths.clear();
            }

            // Param is passed by value, moved
            pub fn set_hot_paths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.hot_paths = v;
            }

            // Mutable pointer to the field.
            pub fn mut_hot_paths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.hot_paths
            }

            // Take field
            pub fn take_hot_paths(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.hot_paths, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.FFISystem.RuntimeVerification.PerformanceMetrics.ThresholdsEntry thresholds = 2;

            pub fn thresholds(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
                &self.thresholds
            }

            pub fn clear_thresholds(&mut self) {
                self.thresholds.clear();
            }

            // Param is passed by value, moved
            pub fn set_thresholds(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
                self.thresholds = v;
            }

            // Mutable pointer to the field.
            pub fn mut_thresholds(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
                &mut self.thresholds
            }

            // Take field
            pub fn take_thresholds(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
                ::std::mem::replace(&mut self.thresholds, ::std::collections::HashMap::new())
            }

            // bool profile_ffi = 3;

            pub fn profile_ffi(&self) -> bool {
                self.profile_ffi
            }

            pub fn clear_profile_ffi(&mut self) {
                self.profile_ffi = false;
            }

            // Param is passed by value, moved
            pub fn set_profile_ffi(&mut self, v: bool) {
                self.profile_ffi = v;
            }

            // repeated string optimizations = 4;

            pub fn optimizations(&self) -> &[::std::string::String] {
                &self.optimizations
            }

            pub fn clear_optimizations(&mut self) {
                self.optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimizations
            }

            // Take field
            pub fn take_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimizations, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hot_paths",
                    |m: &PerformanceMetrics| { &m.hot_paths },
                    |m: &mut PerformanceMetrics| { &mut m.hot_paths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "thresholds",
                    |m: &PerformanceMetrics| { &m.thresholds },
                    |m: &mut PerformanceMetrics| { &mut m.thresholds },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "profile_ffi",
                    |m: &PerformanceMetrics| { &m.profile_ffi },
                    |m: &mut PerformanceMetrics| { &mut m.profile_ffi },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimizations",
                    |m: &PerformanceMetrics| { &m.optimizations },
                    |m: &mut PerformanceMetrics| { &mut m.optimizations },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceMetrics>(
                    "FFISystem.RuntimeVerification.PerformanceMetrics",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PerformanceMetrics {
            const NAME: &'static str = "PerformanceMetrics";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.hot_paths.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    17 => value = is.read_double()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.thresholds.insert(key, value);
                        },
                        24 => {
                            self.profile_ffi = is.read_bool()?;
                        },
                        34 => {
                            self.optimizations.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.hot_paths {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.thresholds {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 8;
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.profile_ffi != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimizations {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.hot_paths {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.thresholds {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 8;
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_double(2, *v)?;
                };
                if self.profile_ffi != false {
                    os.write_bool(3, self.profile_ffi)?;
                }
                for v in &self.optimizations {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PerformanceMetrics {
                PerformanceMetrics::new()
            }

            fn clear(&mut self) {
                self.hot_paths.clear();
                self.thresholds.clear();
                self.profile_ffi = false;
                self.optimizations.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PerformanceMetrics {
                static instance: ::protobuf::rt::Lazy<PerformanceMetrics> = ::protobuf::rt::Lazy::new();
                instance.get(PerformanceMetrics::new)
            }
        }

        impl ::protobuf::MessageFull for PerformanceMetrics {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("FFISystem.RuntimeVerification.PerformanceMetrics").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PerformanceMetrics {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PerformanceMetrics {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IntelligentHardwareSystem {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.quality_integration)
    pub quality_integration: ::protobuf::MessageField<intelligent_hardware_system::QualityIntegration>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IntelligentHardwareSystem {
    fn default() -> &'a IntelligentHardwareSystem {
        <IntelligentHardwareSystem as ::protobuf::Message>::default_instance()
    }
}

impl IntelligentHardwareSystem {
    pub fn new() -> IntelligentHardwareSystem {
        ::std::default::Default::default()
    }

    // .kymera_mappings.IntelligentHardwareSystem.QualityIntegration quality_integration = 8;

    pub fn quality_integration(&self) -> &intelligent_hardware_system::QualityIntegration {
        self.quality_integration.as_ref().unwrap_or_else(|| <intelligent_hardware_system::QualityIntegration as ::protobuf::Message>::default_instance())
    }

    pub fn clear_quality_integration(&mut self) {
        self.quality_integration.clear();
    }

    pub fn has_quality_integration(&self) -> bool {
        self.quality_integration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_integration(&mut self, v: intelligent_hardware_system::QualityIntegration) {
        self.quality_integration = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_integration(&mut self) -> &mut intelligent_hardware_system::QualityIntegration {
        self.quality_integration.mut_or_insert_default()
    }

    // Take field
    pub fn take_quality_integration(&mut self) -> intelligent_hardware_system::QualityIntegration {
        self.quality_integration.take().unwrap_or_else(|| intelligent_hardware_system::QualityIntegration::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, intelligent_hardware_system::QualityIntegration>(
            "quality_integration",
            |m: &IntelligentHardwareSystem| { &m.quality_integration },
            |m: &mut IntelligentHardwareSystem| { &mut m.quality_integration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IntelligentHardwareSystem>(
            "IntelligentHardwareSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IntelligentHardwareSystem {
    const NAME: &'static str = "IntelligentHardwareSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_integration)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality_integration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality_integration.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IntelligentHardwareSystem {
        IntelligentHardwareSystem::new()
    }

    fn clear(&mut self) {
        self.quality_integration.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IntelligentHardwareSystem {
        static instance: IntelligentHardwareSystem = IntelligentHardwareSystem {
            quality_integration: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IntelligentHardwareSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IntelligentHardwareSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntelligentHardwareSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `IntelligentHardwareSystem`
pub mod intelligent_hardware_system {
    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.QualityIntegration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QualityIntegration {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.QualityIntegration.quality_system)
        pub quality_system: ::protobuf::MessageField<super::QualityRatingSystem>,
        // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.QualityIntegration.hardware_scores)
        pub hardware_scores: ::std::collections::HashMap<::std::string::String, f64>,
        // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.QualityIntegration.optimization_targets)
        pub optimization_targets: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.QualityIntegration.meets_hardware_standards)
        pub meets_hardware_standards: bool,
        // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.QualityIntegration.quality_metrics)
        pub quality_metrics: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.QualityIntegration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QualityIntegration {
        fn default() -> &'a QualityIntegration {
            <QualityIntegration as ::protobuf::Message>::default_instance()
        }
    }

    impl QualityIntegration {
        pub fn new() -> QualityIntegration {
            ::std::default::Default::default()
        }

        // .kymera_mappings.QualityRatingSystem quality_system = 1;

        pub fn quality_system(&self) -> &super::QualityRatingSystem {
            self.quality_system.as_ref().unwrap_or_else(|| <super::QualityRatingSystem as ::protobuf::Message>::default_instance())
        }

        pub fn clear_quality_system(&mut self) {
            self.quality_system.clear();
        }

        pub fn has_quality_system(&self) -> bool {
            self.quality_system.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality_system(&mut self, v: super::QualityRatingSystem) {
            self.quality_system = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_quality_system(&mut self) -> &mut super::QualityRatingSystem {
            self.quality_system.mut_or_insert_default()
        }

        // Take field
        pub fn take_quality_system(&mut self) -> super::QualityRatingSystem {
            self.quality_system.take().unwrap_or_else(|| super::QualityRatingSystem::new())
        }

        // repeated .kymera_mappings.IntelligentHardwareSystem.QualityIntegration.HardwareScoresEntry hardware_scores = 2;

        pub fn hardware_scores(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
            &self.hardware_scores
        }

        pub fn clear_hardware_scores(&mut self) {
            self.hardware_scores.clear();
        }

        // Param is passed by value, moved
        pub fn set_hardware_scores(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
            self.hardware_scores = v;
        }

        // Mutable pointer to the field.
        pub fn mut_hardware_scores(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
            &mut self.hardware_scores
        }

        // Take field
        pub fn take_hardware_scores(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
            ::std::mem::replace(&mut self.hardware_scores, ::std::collections::HashMap::new())
        }

        // repeated string optimization_targets = 3;

        pub fn optimization_targets(&self) -> &[::std::string::String] {
            &self.optimization_targets
        }

        pub fn clear_optimization_targets(&mut self) {
            self.optimization_targets.clear();
        }

        // Param is passed by value, moved
        pub fn set_optimization_targets(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.optimization_targets = v;
        }

        // Mutable pointer to the field.
        pub fn mut_optimization_targets(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.optimization_targets
        }

        // Take field
        pub fn take_optimization_targets(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.optimization_targets, ::std::vec::Vec::new())
        }

        // bool meets_hardware_standards = 4;

        pub fn meets_hardware_standards(&self) -> bool {
            self.meets_hardware_standards
        }

        pub fn clear_meets_hardware_standards(&mut self) {
            self.meets_hardware_standards = false;
        }

        // Param is passed by value, moved
        pub fn set_meets_hardware_standards(&mut self, v: bool) {
            self.meets_hardware_standards = v;
        }

        // repeated .kymera_mappings.IntelligentHardwareSystem.QualityIntegration.QualityMetricsEntry quality_metrics = 5;

        pub fn quality_metrics(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.quality_metrics
        }

        pub fn clear_quality_metrics(&mut self) {
            self.quality_metrics.clear();
        }

        // Param is passed by value, moved
        pub fn set_quality_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.quality_metrics = v;
        }

        // Mutable pointer to the field.
        pub fn mut_quality_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.quality_metrics
        }

        // Take field
        pub fn take_quality_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.quality_metrics, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::QualityRatingSystem>(
                "quality_system",
                |m: &QualityIntegration| { &m.quality_system },
                |m: &mut QualityIntegration| { &mut m.quality_system },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "hardware_scores",
                |m: &QualityIntegration| { &m.hardware_scores },
                |m: &mut QualityIntegration| { &mut m.hardware_scores },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "optimization_targets",
                |m: &QualityIntegration| { &m.optimization_targets },
                |m: &mut QualityIntegration| { &mut m.optimization_targets },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "meets_hardware_standards",
                |m: &QualityIntegration| { &m.meets_hardware_standards },
                |m: &mut QualityIntegration| { &mut m.meets_hardware_standards },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "quality_metrics",
                |m: &QualityIntegration| { &m.quality_metrics },
                |m: &mut QualityIntegration| { &mut m.quality_metrics },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QualityIntegration>(
                "IntelligentHardwareSystem.QualityIntegration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QualityIntegration {
        const NAME: &'static str = "QualityIntegration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.quality_system)?;
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                17 => value = is.read_double()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.hardware_scores.insert(key, value);
                    },
                    26 => {
                        self.optimization_targets.push(is.read_string()?);
                    },
                    32 => {
                        self.meets_hardware_standards = is.read_bool()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.quality_metrics.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.quality_system.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for (k, v) in &self.hardware_scores {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.optimization_targets {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if self.meets_hardware_standards != false {
                my_size += 1 + 1;
            }
            for (k, v) in &self.quality_metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.quality_system.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for (k, v) in &self.hardware_scores {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_double(2, *v)?;
            };
            for v in &self.optimization_targets {
                os.write_string(3, &v)?;
            };
            if self.meets_hardware_standards != false {
                os.write_bool(4, self.meets_hardware_standards)?;
            }
            for (k, v) in &self.quality_metrics {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QualityIntegration {
            QualityIntegration::new()
        }

        fn clear(&mut self) {
            self.quality_system.clear();
            self.hardware_scores.clear();
            self.optimization_targets.clear();
            self.meets_hardware_standards = false;
            self.quality_metrics.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QualityIntegration {
            static instance: ::protobuf::rt::Lazy<QualityIntegration> = ::protobuf::rt::Lazy::new();
            instance.get(QualityIntegration::new)
        }
    }

    impl ::protobuf::MessageFull for QualityIntegration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.QualityIntegration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QualityIntegration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QualityIntegration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HardwareAwareness {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HardwareAwareness {
        fn default() -> &'a HardwareAwareness {
            <HardwareAwareness as ::protobuf::Message>::default_instance()
        }
    }

    impl HardwareAwareness {
        pub fn new() -> HardwareAwareness {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HardwareAwareness>(
                "IntelligentHardwareSystem.HardwareAwareness",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for HardwareAwareness {
        const NAME: &'static str = "HardwareAwareness";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HardwareAwareness {
            HardwareAwareness::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HardwareAwareness {
            static instance: HardwareAwareness = HardwareAwareness {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for HardwareAwareness {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.HardwareAwareness").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for HardwareAwareness {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for HardwareAwareness {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `HardwareAwareness`
    pub mod hardware_awareness {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SystemDetection {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection.cpu_architecture)
            pub cpu_architecture: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection.cpu_features)
            pub cpu_features: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection.cpu_topology)
            pub cpu_topology: ::std::collections::HashMap<::std::string::String, u32>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection.heterogeneous_cores)
            pub heterogeneous_cores: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection.instruction_sets)
            pub instruction_sets: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SystemDetection {
            fn default() -> &'a SystemDetection {
                <SystemDetection as ::protobuf::Message>::default_instance()
            }
        }

        impl SystemDetection {
            pub fn new() -> SystemDetection {
                ::std::default::Default::default()
            }

            // string cpu_architecture = 1;

            pub fn cpu_architecture(&self) -> &str {
                &self.cpu_architecture
            }

            pub fn clear_cpu_architecture(&mut self) {
                self.cpu_architecture.clear();
            }

            // Param is passed by value, moved
            pub fn set_cpu_architecture(&mut self, v: ::std::string::String) {
                self.cpu_architecture = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_cpu_architecture(&mut self) -> &mut ::std::string::String {
                &mut self.cpu_architecture
            }

            // Take field
            pub fn take_cpu_architecture(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.cpu_architecture, ::std::string::String::new())
            }

            // repeated string cpu_features = 2;

            pub fn cpu_features(&self) -> &[::std::string::String] {
                &self.cpu_features
            }

            pub fn clear_cpu_features(&mut self) {
                self.cpu_features.clear();
            }

            // Param is passed by value, moved
            pub fn set_cpu_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.cpu_features = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cpu_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.cpu_features
            }

            // Take field
            pub fn take_cpu_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.cpu_features, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection.CpuTopologyEntry cpu_topology = 3;

            pub fn cpu_topology(&self) -> &::std::collections::HashMap<::std::string::String, u32> {
                &self.cpu_topology
            }

            pub fn clear_cpu_topology(&mut self) {
                self.cpu_topology.clear();
            }

            // Param is passed by value, moved
            pub fn set_cpu_topology(&mut self, v: ::std::collections::HashMap<::std::string::String, u32>) {
                self.cpu_topology = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cpu_topology(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u32> {
                &mut self.cpu_topology
            }

            // Take field
            pub fn take_cpu_topology(&mut self) -> ::std::collections::HashMap<::std::string::String, u32> {
                ::std::mem::replace(&mut self.cpu_topology, ::std::collections::HashMap::new())
            }

            // bool heterogeneous_cores = 4;

            pub fn heterogeneous_cores(&self) -> bool {
                self.heterogeneous_cores
            }

            pub fn clear_heterogeneous_cores(&mut self) {
                self.heterogeneous_cores = false;
            }

            // Param is passed by value, moved
            pub fn set_heterogeneous_cores(&mut self, v: bool) {
                self.heterogeneous_cores = v;
            }

            // repeated string instruction_sets = 5;

            pub fn instruction_sets(&self) -> &[::std::string::String] {
                &self.instruction_sets
            }

            pub fn clear_instruction_sets(&mut self) {
                self.instruction_sets.clear();
            }

            // Param is passed by value, moved
            pub fn set_instruction_sets(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.instruction_sets = v;
            }

            // Mutable pointer to the field.
            pub fn mut_instruction_sets(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.instruction_sets
            }

            // Take field
            pub fn take_instruction_sets(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.instruction_sets, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "cpu_architecture",
                    |m: &SystemDetection| { &m.cpu_architecture },
                    |m: &mut SystemDetection| { &mut m.cpu_architecture },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "cpu_features",
                    |m: &SystemDetection| { &m.cpu_features },
                    |m: &mut SystemDetection| { &mut m.cpu_features },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "cpu_topology",
                    |m: &SystemDetection| { &m.cpu_topology },
                    |m: &mut SystemDetection| { &mut m.cpu_topology },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "heterogeneous_cores",
                    |m: &SystemDetection| { &m.heterogeneous_cores },
                    |m: &mut SystemDetection| { &mut m.heterogeneous_cores },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "instruction_sets",
                    |m: &SystemDetection| { &m.instruction_sets },
                    |m: &mut SystemDetection| { &mut m.instruction_sets },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SystemDetection>(
                    "IntelligentHardwareSystem.HardwareAwareness.SystemDetection",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SystemDetection {
            const NAME: &'static str = "SystemDetection";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.cpu_architecture = is.read_string()?;
                        },
                        18 => {
                            self.cpu_features.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    16 => value = is.read_uint32()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.cpu_topology.insert(key, value);
                        },
                        32 => {
                            self.heterogeneous_cores = is.read_bool()?;
                        },
                        42 => {
                            self.instruction_sets.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.cpu_architecture.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.cpu_architecture);
                }
                for value in &self.cpu_features {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.cpu_topology {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.heterogeneous_cores != false {
                    my_size += 1 + 1;
                }
                for value in &self.instruction_sets {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.cpu_architecture.is_empty() {
                    os.write_string(1, &self.cpu_architecture)?;
                }
                for v in &self.cpu_features {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.cpu_topology {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_uint32(2, *v)?;
                };
                if self.heterogeneous_cores != false {
                    os.write_bool(4, self.heterogeneous_cores)?;
                }
                for v in &self.instruction_sets {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SystemDetection {
                SystemDetection::new()
            }

            fn clear(&mut self) {
                self.cpu_architecture.clear();
                self.cpu_features.clear();
                self.cpu_topology.clear();
                self.heterogeneous_cores = false;
                self.instruction_sets.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SystemDetection {
                static instance: ::protobuf::rt::Lazy<SystemDetection> = ::protobuf::rt::Lazy::new();
                instance.get(SystemDetection::new)
            }
        }

        impl ::protobuf::MessageFull for SystemDetection {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.HardwareAwareness.SystemDetection").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SystemDetection {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SystemDetection {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct GPUCapabilities {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.gpu_devices)
            pub gpu_devices: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.compute_capabilities)
            pub compute_capabilities: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.unified_memory)
            pub unified_memory: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.gpu_features)
            pub gpu_features: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.memory_hierarchy)
            pub memory_hierarchy: ::std::collections::HashMap<::std::string::String, u64>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a GPUCapabilities {
            fn default() -> &'a GPUCapabilities {
                <GPUCapabilities as ::protobuf::Message>::default_instance()
            }
        }

        impl GPUCapabilities {
            pub fn new() -> GPUCapabilities {
                ::std::default::Default::default()
            }

            // repeated string gpu_devices = 1;

            pub fn gpu_devices(&self) -> &[::std::string::String] {
                &self.gpu_devices
            }

            pub fn clear_gpu_devices(&mut self) {
                self.gpu_devices.clear();
            }

            // Param is passed by value, moved
            pub fn set_gpu_devices(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.gpu_devices = v;
            }

            // Mutable pointer to the field.
            pub fn mut_gpu_devices(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.gpu_devices
            }

            // Take field
            pub fn take_gpu_devices(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.gpu_devices, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.ComputeCapabilitiesEntry compute_capabilities = 2;

            pub fn compute_capabilities(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.compute_capabilities
            }

            pub fn clear_compute_capabilities(&mut self) {
                self.compute_capabilities.clear();
            }

            // Param is passed by value, moved
            pub fn set_compute_capabilities(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.compute_capabilities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compute_capabilities(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.compute_capabilities
            }

            // Take field
            pub fn take_compute_capabilities(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.compute_capabilities, ::std::collections::HashMap::new())
            }

            // bool unified_memory = 3;

            pub fn unified_memory(&self) -> bool {
                self.unified_memory
            }

            pub fn clear_unified_memory(&mut self) {
                self.unified_memory = false;
            }

            // Param is passed by value, moved
            pub fn set_unified_memory(&mut self, v: bool) {
                self.unified_memory = v;
            }

            // repeated string gpu_features = 4;

            pub fn gpu_features(&self) -> &[::std::string::String] {
                &self.gpu_features
            }

            pub fn clear_gpu_features(&mut self) {
                self.gpu_features.clear();
            }

            // Param is passed by value, moved
            pub fn set_gpu_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.gpu_features = v;
            }

            // Mutable pointer to the field.
            pub fn mut_gpu_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.gpu_features
            }

            // Take field
            pub fn take_gpu_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.gpu_features, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities.MemoryHierarchyEntry memory_hierarchy = 5;

            pub fn memory_hierarchy(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
                &self.memory_hierarchy
            }

            pub fn clear_memory_hierarchy(&mut self) {
                self.memory_hierarchy.clear();
            }

            // Param is passed by value, moved
            pub fn set_memory_hierarchy(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
                self.memory_hierarchy = v;
            }

            // Mutable pointer to the field.
            pub fn mut_memory_hierarchy(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
                &mut self.memory_hierarchy
            }

            // Take field
            pub fn take_memory_hierarchy(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
                ::std::mem::replace(&mut self.memory_hierarchy, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "gpu_devices",
                    |m: &GPUCapabilities| { &m.gpu_devices },
                    |m: &mut GPUCapabilities| { &mut m.gpu_devices },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "compute_capabilities",
                    |m: &GPUCapabilities| { &m.compute_capabilities },
                    |m: &mut GPUCapabilities| { &mut m.compute_capabilities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "unified_memory",
                    |m: &GPUCapabilities| { &m.unified_memory },
                    |m: &mut GPUCapabilities| { &mut m.unified_memory },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "gpu_features",
                    |m: &GPUCapabilities| { &m.gpu_features },
                    |m: &mut GPUCapabilities| { &mut m.gpu_features },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "memory_hierarchy",
                    |m: &GPUCapabilities| { &m.memory_hierarchy },
                    |m: &mut GPUCapabilities| { &mut m.memory_hierarchy },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GPUCapabilities>(
                    "IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for GPUCapabilities {
            const NAME: &'static str = "GPUCapabilities";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.gpu_devices.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.compute_capabilities.insert(key, value);
                        },
                        24 => {
                            self.unified_memory = is.read_bool()?;
                        },
                        34 => {
                            self.gpu_features.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    16 => value = is.read_uint64()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.memory_hierarchy.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.gpu_devices {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.compute_capabilities {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.unified_memory != false {
                    my_size += 1 + 1;
                }
                for value in &self.gpu_features {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.memory_hierarchy {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint64_size(2, *v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.gpu_devices {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.compute_capabilities {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.unified_memory != false {
                    os.write_bool(3, self.unified_memory)?;
                }
                for v in &self.gpu_features {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.memory_hierarchy {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint64_size(2, *v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_uint64(2, *v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> GPUCapabilities {
                GPUCapabilities::new()
            }

            fn clear(&mut self) {
                self.gpu_devices.clear();
                self.compute_capabilities.clear();
                self.unified_memory = false;
                self.gpu_features.clear();
                self.memory_hierarchy.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static GPUCapabilities {
                static instance: ::protobuf::rt::Lazy<GPUCapabilities> = ::protobuf::rt::Lazy::new();
                instance.get(GPUCapabilities::new)
            }
        }

        impl ::protobuf::MessageFull for GPUCapabilities {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.HardwareAwareness.GPUCapabilities").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for GPUCapabilities {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for GPUCapabilities {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AcceleratorSupport {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.accelerator_types)
            pub accelerator_types: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.accelerator_caps)
            pub accelerator_caps: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.neural_engine)
            pub neural_engine: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.custom_asics)
            pub custom_asics: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.fpga_configs)
            pub fpga_configs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AcceleratorSupport {
            fn default() -> &'a AcceleratorSupport {
                <AcceleratorSupport as ::protobuf::Message>::default_instance()
            }
        }

        impl AcceleratorSupport {
            pub fn new() -> AcceleratorSupport {
                ::std::default::Default::default()
            }

            // repeated string accelerator_types = 1;

            pub fn accelerator_types(&self) -> &[::std::string::String] {
                &self.accelerator_types
            }

            pub fn clear_accelerator_types(&mut self) {
                self.accelerator_types.clear();
            }

            // Param is passed by value, moved
            pub fn set_accelerator_types(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.accelerator_types = v;
            }

            // Mutable pointer to the field.
            pub fn mut_accelerator_types(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.accelerator_types
            }

            // Take field
            pub fn take_accelerator_types(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.accelerator_types, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.AcceleratorCapsEntry accelerator_caps = 2;

            pub fn accelerator_caps(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.accelerator_caps
            }

            pub fn clear_accelerator_caps(&mut self) {
                self.accelerator_caps.clear();
            }

            // Param is passed by value, moved
            pub fn set_accelerator_caps(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.accelerator_caps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_accelerator_caps(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.accelerator_caps
            }

            // Take field
            pub fn take_accelerator_caps(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.accelerator_caps, ::std::collections::HashMap::new())
            }

            // bool neural_engine = 3;

            pub fn neural_engine(&self) -> bool {
                self.neural_engine
            }

            pub fn clear_neural_engine(&mut self) {
                self.neural_engine = false;
            }

            // Param is passed by value, moved
            pub fn set_neural_engine(&mut self, v: bool) {
                self.neural_engine = v;
            }

            // repeated string custom_asics = 4;

            pub fn custom_asics(&self) -> &[::std::string::String] {
                &self.custom_asics
            }

            pub fn clear_custom_asics(&mut self) {
                self.custom_asics.clear();
            }

            // Param is passed by value, moved
            pub fn set_custom_asics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.custom_asics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_custom_asics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.custom_asics
            }

            // Take field
            pub fn take_custom_asics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.custom_asics, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport.FpgaConfigsEntry fpga_configs = 5;

            pub fn fpga_configs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.fpga_configs
            }

            pub fn clear_fpga_configs(&mut self) {
                self.fpga_configs.clear();
            }

            // Param is passed by value, moved
            pub fn set_fpga_configs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.fpga_configs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_fpga_configs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.fpga_configs
            }

            // Take field
            pub fn take_fpga_configs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.fpga_configs, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "accelerator_types",
                    |m: &AcceleratorSupport| { &m.accelerator_types },
                    |m: &mut AcceleratorSupport| { &mut m.accelerator_types },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "accelerator_caps",
                    |m: &AcceleratorSupport| { &m.accelerator_caps },
                    |m: &mut AcceleratorSupport| { &mut m.accelerator_caps },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "neural_engine",
                    |m: &AcceleratorSupport| { &m.neural_engine },
                    |m: &mut AcceleratorSupport| { &mut m.neural_engine },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "custom_asics",
                    |m: &AcceleratorSupport| { &m.custom_asics },
                    |m: &mut AcceleratorSupport| { &mut m.custom_asics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "fpga_configs",
                    |m: &AcceleratorSupport| { &m.fpga_configs },
                    |m: &mut AcceleratorSupport| { &mut m.fpga_configs },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AcceleratorSupport>(
                    "IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AcceleratorSupport {
            const NAME: &'static str = "AcceleratorSupport";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.accelerator_types.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.accelerator_caps.insert(key, value);
                        },
                        24 => {
                            self.neural_engine = is.read_bool()?;
                        },
                        34 => {
                            self.custom_asics.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.fpga_configs.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.accelerator_types {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.accelerator_caps {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.neural_engine != false {
                    my_size += 1 + 1;
                }
                for value in &self.custom_asics {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.fpga_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.accelerator_types {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.accelerator_caps {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.neural_engine != false {
                    os.write_bool(3, self.neural_engine)?;
                }
                for v in &self.custom_asics {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.fpga_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AcceleratorSupport {
                AcceleratorSupport::new()
            }

            fn clear(&mut self) {
                self.accelerator_types.clear();
                self.accelerator_caps.clear();
                self.neural_engine = false;
                self.custom_asics.clear();
                self.fpga_configs.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AcceleratorSupport {
                static instance: ::protobuf::rt::Lazy<AcceleratorSupport> = ::protobuf::rt::Lazy::new();
                instance.get(AcceleratorSupport::new)
            }
        }

        impl ::protobuf::MessageFull for AcceleratorSupport {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.HardwareAwareness.AcceleratorSupport").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AcceleratorSupport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AcceleratorSupport {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ComputeFramework)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ComputeFramework {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ComputeFramework {
        fn default() -> &'a ComputeFramework {
            <ComputeFramework as ::protobuf::Message>::default_instance()
        }
    }

    impl ComputeFramework {
        pub fn new() -> ComputeFramework {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ComputeFramework>(
                "IntelligentHardwareSystem.ComputeFramework",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ComputeFramework {
        const NAME: &'static str = "ComputeFramework";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ComputeFramework {
            ComputeFramework::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ComputeFramework {
            static instance: ComputeFramework = ComputeFramework {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ComputeFramework {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ComputeFramework").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ComputeFramework {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ComputeFramework {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ComputeFramework`
    pub mod compute_framework {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CUDAIntegration {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration.cuda_version)
            pub cuda_version: u32,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration.cuda_capabilities)
            pub cuda_capabilities: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration.cuda_libraries)
            pub cuda_libraries: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration.tensor_cores)
            pub tensor_cores: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration.cuda_optimizations)
            pub cuda_optimizations: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CUDAIntegration {
            fn default() -> &'a CUDAIntegration {
                <CUDAIntegration as ::protobuf::Message>::default_instance()
            }
        }

        impl CUDAIntegration {
            pub fn new() -> CUDAIntegration {
                ::std::default::Default::default()
            }

            // uint32 cuda_version = 1;

            pub fn cuda_version(&self) -> u32 {
                self.cuda_version
            }

            pub fn clear_cuda_version(&mut self) {
                self.cuda_version = 0;
            }

            // Param is passed by value, moved
            pub fn set_cuda_version(&mut self, v: u32) {
                self.cuda_version = v;
            }

            // repeated string cuda_capabilities = 2;

            pub fn cuda_capabilities(&self) -> &[::std::string::String] {
                &self.cuda_capabilities
            }

            pub fn clear_cuda_capabilities(&mut self) {
                self.cuda_capabilities.clear();
            }

            // Param is passed by value, moved
            pub fn set_cuda_capabilities(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.cuda_capabilities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cuda_capabilities(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.cuda_capabilities
            }

            // Take field
            pub fn take_cuda_capabilities(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.cuda_capabilities, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIntegration.CudaLibrariesEntry cuda_libraries = 3;

            pub fn cuda_libraries(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.cuda_libraries
            }

            pub fn clear_cuda_libraries(&mut self) {
                self.cuda_libraries.clear();
            }

            // Param is passed by value, moved
            pub fn set_cuda_libraries(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.cuda_libraries = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cuda_libraries(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.cuda_libraries
            }

            // Take field
            pub fn take_cuda_libraries(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.cuda_libraries, ::std::collections::HashMap::new())
            }

            // bool tensor_cores = 4;

            pub fn tensor_cores(&self) -> bool {
                self.tensor_cores
            }

            pub fn clear_tensor_cores(&mut self) {
                self.tensor_cores = false;
            }

            // Param is passed by value, moved
            pub fn set_tensor_cores(&mut self, v: bool) {
                self.tensor_cores = v;
            }

            // repeated string cuda_optimizations = 5;

            pub fn cuda_optimizations(&self) -> &[::std::string::String] {
                &self.cuda_optimizations
            }

            pub fn clear_cuda_optimizations(&mut self) {
                self.cuda_optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_cuda_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.cuda_optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cuda_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.cuda_optimizations
            }

            // Take field
            pub fn take_cuda_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.cuda_optimizations, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "cuda_version",
                    |m: &CUDAIntegration| { &m.cuda_version },
                    |m: &mut CUDAIntegration| { &mut m.cuda_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "cuda_capabilities",
                    |m: &CUDAIntegration| { &m.cuda_capabilities },
                    |m: &mut CUDAIntegration| { &mut m.cuda_capabilities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "cuda_libraries",
                    |m: &CUDAIntegration| { &m.cuda_libraries },
                    |m: &mut CUDAIntegration| { &mut m.cuda_libraries },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "tensor_cores",
                    |m: &CUDAIntegration| { &m.tensor_cores },
                    |m: &mut CUDAIntegration| { &mut m.tensor_cores },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "cuda_optimizations",
                    |m: &CUDAIntegration| { &m.cuda_optimizations },
                    |m: &mut CUDAIntegration| { &mut m.cuda_optimizations },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUDAIntegration>(
                    "IntelligentHardwareSystem.ComputeFramework.CUDAIntegration",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CUDAIntegration {
            const NAME: &'static str = "CUDAIntegration";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.cuda_version = is.read_uint32()?;
                        },
                        18 => {
                            self.cuda_capabilities.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.cuda_libraries.insert(key, value);
                        },
                        32 => {
                            self.tensor_cores = is.read_bool()?;
                        },
                        42 => {
                            self.cuda_optimizations.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.cuda_version != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.cuda_version);
                }
                for value in &self.cuda_capabilities {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.cuda_libraries {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.tensor_cores != false {
                    my_size += 1 + 1;
                }
                for value in &self.cuda_optimizations {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.cuda_version != 0 {
                    os.write_uint32(1, self.cuda_version)?;
                }
                for v in &self.cuda_capabilities {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.cuda_libraries {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.tensor_cores != false {
                    os.write_bool(4, self.tensor_cores)?;
                }
                for v in &self.cuda_optimizations {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CUDAIntegration {
                CUDAIntegration::new()
            }

            fn clear(&mut self) {
                self.cuda_version = 0;
                self.cuda_capabilities.clear();
                self.cuda_libraries.clear();
                self.tensor_cores = false;
                self.cuda_optimizations.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CUDAIntegration {
                static instance: ::protobuf::rt::Lazy<CUDAIntegration> = ::protobuf::rt::Lazy::new();
                instance.get(CUDAIntegration::new)
            }
        }

        impl ::protobuf::MessageFull for CUDAIntegration {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ComputeFramework.CUDAIntegration").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CUDAIntegration {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CUDAIntegration {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ROCmIntegration {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration.rocm_version)
            pub rocm_version: u32,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration.hip_features)
            pub hip_features: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration.rocm_libraries)
            pub rocm_libraries: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration.infinity_fabric)
            pub infinity_fabric: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration.rocm_optimizations)
            pub rocm_optimizations: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ROCmIntegration {
            fn default() -> &'a ROCmIntegration {
                <ROCmIntegration as ::protobuf::Message>::default_instance()
            }
        }

        impl ROCmIntegration {
            pub fn new() -> ROCmIntegration {
                ::std::default::Default::default()
            }

            // uint32 rocm_version = 1;

            pub fn rocm_version(&self) -> u32 {
                self.rocm_version
            }

            pub fn clear_rocm_version(&mut self) {
                self.rocm_version = 0;
            }

            // Param is passed by value, moved
            pub fn set_rocm_version(&mut self, v: u32) {
                self.rocm_version = v;
            }

            // repeated string hip_features = 2;

            pub fn hip_features(&self) -> &[::std::string::String] {
                &self.hip_features
            }

            pub fn clear_hip_features(&mut self) {
                self.hip_features.clear();
            }

            // Param is passed by value, moved
            pub fn set_hip_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.hip_features = v;
            }

            // Mutable pointer to the field.
            pub fn mut_hip_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.hip_features
            }

            // Take field
            pub fn take_hip_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.hip_features, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ComputeFramework.ROCmIntegration.RocmLibrariesEntry rocm_libraries = 3;

            pub fn rocm_libraries(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.rocm_libraries
            }

            pub fn clear_rocm_libraries(&mut self) {
                self.rocm_libraries.clear();
            }

            // Param is passed by value, moved
            pub fn set_rocm_libraries(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.rocm_libraries = v;
            }

            // Mutable pointer to the field.
            pub fn mut_rocm_libraries(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.rocm_libraries
            }

            // Take field
            pub fn take_rocm_libraries(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.rocm_libraries, ::std::collections::HashMap::new())
            }

            // bool infinity_fabric = 4;

            pub fn infinity_fabric(&self) -> bool {
                self.infinity_fabric
            }

            pub fn clear_infinity_fabric(&mut self) {
                self.infinity_fabric = false;
            }

            // Param is passed by value, moved
            pub fn set_infinity_fabric(&mut self, v: bool) {
                self.infinity_fabric = v;
            }

            // repeated string rocm_optimizations = 5;

            pub fn rocm_optimizations(&self) -> &[::std::string::String] {
                &self.rocm_optimizations
            }

            pub fn clear_rocm_optimizations(&mut self) {
                self.rocm_optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_rocm_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.rocm_optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_rocm_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.rocm_optimizations
            }

            // Take field
            pub fn take_rocm_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.rocm_optimizations, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "rocm_version",
                    |m: &ROCmIntegration| { &m.rocm_version },
                    |m: &mut ROCmIntegration| { &mut m.rocm_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hip_features",
                    |m: &ROCmIntegration| { &m.hip_features },
                    |m: &mut ROCmIntegration| { &mut m.hip_features },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "rocm_libraries",
                    |m: &ROCmIntegration| { &m.rocm_libraries },
                    |m: &mut ROCmIntegration| { &mut m.rocm_libraries },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "infinity_fabric",
                    |m: &ROCmIntegration| { &m.infinity_fabric },
                    |m: &mut ROCmIntegration| { &mut m.infinity_fabric },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "rocm_optimizations",
                    |m: &ROCmIntegration| { &m.rocm_optimizations },
                    |m: &mut ROCmIntegration| { &mut m.rocm_optimizations },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ROCmIntegration>(
                    "IntelligentHardwareSystem.ComputeFramework.ROCmIntegration",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ROCmIntegration {
            const NAME: &'static str = "ROCmIntegration";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.rocm_version = is.read_uint32()?;
                        },
                        18 => {
                            self.hip_features.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.rocm_libraries.insert(key, value);
                        },
                        32 => {
                            self.infinity_fabric = is.read_bool()?;
                        },
                        42 => {
                            self.rocm_optimizations.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.rocm_version != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.rocm_version);
                }
                for value in &self.hip_features {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.rocm_libraries {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.infinity_fabric != false {
                    my_size += 1 + 1;
                }
                for value in &self.rocm_optimizations {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.rocm_version != 0 {
                    os.write_uint32(1, self.rocm_version)?;
                }
                for v in &self.hip_features {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.rocm_libraries {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.infinity_fabric != false {
                    os.write_bool(4, self.infinity_fabric)?;
                }
                for v in &self.rocm_optimizations {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ROCmIntegration {
                ROCmIntegration::new()
            }

            fn clear(&mut self) {
                self.rocm_version = 0;
                self.hip_features.clear();
                self.rocm_libraries.clear();
                self.infinity_fabric = false;
                self.rocm_optimizations.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ROCmIntegration {
                static instance: ::protobuf::rt::Lazy<ROCmIntegration> = ::protobuf::rt::Lazy::new();
                instance.get(ROCmIntegration::new)
            }
        }

        impl ::protobuf::MessageFull for ROCmIntegration {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ComputeFramework.ROCmIntegration").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ROCmIntegration {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ROCmIntegration {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VulkanCompute {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute.vulkan_version)
            pub vulkan_version: u32,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute.compute_features)
            pub compute_features: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute.shader_capabilities)
            pub shader_capabilities: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute.raytracing)
            pub raytracing: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute.vulkan_extensions)
            pub vulkan_extensions: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VulkanCompute {
            fn default() -> &'a VulkanCompute {
                <VulkanCompute as ::protobuf::Message>::default_instance()
            }
        }

        impl VulkanCompute {
            pub fn new() -> VulkanCompute {
                ::std::default::Default::default()
            }

            // uint32 vulkan_version = 1;

            pub fn vulkan_version(&self) -> u32 {
                self.vulkan_version
            }

            pub fn clear_vulkan_version(&mut self) {
                self.vulkan_version = 0;
            }

            // Param is passed by value, moved
            pub fn set_vulkan_version(&mut self, v: u32) {
                self.vulkan_version = v;
            }

            // repeated string compute_features = 2;

            pub fn compute_features(&self) -> &[::std::string::String] {
                &self.compute_features
            }

            pub fn clear_compute_features(&mut self) {
                self.compute_features.clear();
            }

            // Param is passed by value, moved
            pub fn set_compute_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.compute_features = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compute_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.compute_features
            }

            // Take field
            pub fn take_compute_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.compute_features, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ComputeFramework.VulkanCompute.ShaderCapabilitiesEntry shader_capabilities = 3;

            pub fn shader_capabilities(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.shader_capabilities
            }

            pub fn clear_shader_capabilities(&mut self) {
                self.shader_capabilities.clear();
            }

            // Param is passed by value, moved
            pub fn set_shader_capabilities(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.shader_capabilities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_shader_capabilities(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.shader_capabilities
            }

            // Take field
            pub fn take_shader_capabilities(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.shader_capabilities, ::std::collections::HashMap::new())
            }

            // bool raytracing = 4;

            pub fn raytracing(&self) -> bool {
                self.raytracing
            }

            pub fn clear_raytracing(&mut self) {
                self.raytracing = false;
            }

            // Param is passed by value, moved
            pub fn set_raytracing(&mut self, v: bool) {
                self.raytracing = v;
            }

            // repeated string vulkan_extensions = 5;

            pub fn vulkan_extensions(&self) -> &[::std::string::String] {
                &self.vulkan_extensions
            }

            pub fn clear_vulkan_extensions(&mut self) {
                self.vulkan_extensions.clear();
            }

            // Param is passed by value, moved
            pub fn set_vulkan_extensions(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.vulkan_extensions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_vulkan_extensions(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.vulkan_extensions
            }

            // Take field
            pub fn take_vulkan_extensions(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.vulkan_extensions, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "vulkan_version",
                    |m: &VulkanCompute| { &m.vulkan_version },
                    |m: &mut VulkanCompute| { &mut m.vulkan_version },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "compute_features",
                    |m: &VulkanCompute| { &m.compute_features },
                    |m: &mut VulkanCompute| { &mut m.compute_features },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "shader_capabilities",
                    |m: &VulkanCompute| { &m.shader_capabilities },
                    |m: &mut VulkanCompute| { &mut m.shader_capabilities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "raytracing",
                    |m: &VulkanCompute| { &m.raytracing },
                    |m: &mut VulkanCompute| { &mut m.raytracing },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "vulkan_extensions",
                    |m: &VulkanCompute| { &m.vulkan_extensions },
                    |m: &mut VulkanCompute| { &mut m.vulkan_extensions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VulkanCompute>(
                    "IntelligentHardwareSystem.ComputeFramework.VulkanCompute",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for VulkanCompute {
            const NAME: &'static str = "VulkanCompute";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.vulkan_version = is.read_uint32()?;
                        },
                        18 => {
                            self.compute_features.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.shader_capabilities.insert(key, value);
                        },
                        32 => {
                            self.raytracing = is.read_bool()?;
                        },
                        42 => {
                            self.vulkan_extensions.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.vulkan_version != 0 {
                    my_size += ::protobuf::rt::uint32_size(1, self.vulkan_version);
                }
                for value in &self.compute_features {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.shader_capabilities {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.raytracing != false {
                    my_size += 1 + 1;
                }
                for value in &self.vulkan_extensions {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.vulkan_version != 0 {
                    os.write_uint32(1, self.vulkan_version)?;
                }
                for v in &self.compute_features {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.shader_capabilities {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.raytracing != false {
                    os.write_bool(4, self.raytracing)?;
                }
                for v in &self.vulkan_extensions {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VulkanCompute {
                VulkanCompute::new()
            }

            fn clear(&mut self) {
                self.vulkan_version = 0;
                self.compute_features.clear();
                self.shader_capabilities.clear();
                self.raytracing = false;
                self.vulkan_extensions.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VulkanCompute {
                static instance: ::protobuf::rt::Lazy<VulkanCompute> = ::protobuf::rt::Lazy::new();
                instance.get(VulkanCompute::new)
            }
        }

        impl ::protobuf::MessageFull for VulkanCompute {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ComputeFramework.VulkanCompute").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for VulkanCompute {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for VulkanCompute {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LowLatencySystem {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LowLatencySystem {
        fn default() -> &'a LowLatencySystem {
            <LowLatencySystem as ::protobuf::Message>::default_instance()
        }
    }

    impl LowLatencySystem {
        pub fn new() -> LowLatencySystem {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LowLatencySystem>(
                "IntelligentHardwareSystem.LowLatencySystem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LowLatencySystem {
        const NAME: &'static str = "LowLatencySystem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LowLatencySystem {
            LowLatencySystem::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LowLatencySystem {
            static instance: LowLatencySystem = LowLatencySystem {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LowLatencySystem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.LowLatencySystem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LowLatencySystem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LowLatencySystem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `LowLatencySystem`
    pub mod low_latency_system {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct LatencyOptimization {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.zero_copy_paths)
            pub zero_copy_paths: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.latency_targets)
            pub latency_targets: ::std::collections::HashMap<::std::string::String, u32>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.kernel_bypass)
            pub kernel_bypass: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.dma_channels)
            pub dma_channels: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.memory_policies)
            pub memory_policies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a LatencyOptimization {
            fn default() -> &'a LatencyOptimization {
                <LatencyOptimization as ::protobuf::Message>::default_instance()
            }
        }

        impl LatencyOptimization {
            pub fn new() -> LatencyOptimization {
                ::std::default::Default::default()
            }

            // repeated string zero_copy_paths = 1;

            pub fn zero_copy_paths(&self) -> &[::std::string::String] {
                &self.zero_copy_paths
            }

            pub fn clear_zero_copy_paths(&mut self) {
                self.zero_copy_paths.clear();
            }

            // Param is passed by value, moved
            pub fn set_zero_copy_paths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.zero_copy_paths = v;
            }

            // Mutable pointer to the field.
            pub fn mut_zero_copy_paths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.zero_copy_paths
            }

            // Take field
            pub fn take_zero_copy_paths(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.zero_copy_paths, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.LatencyTargetsEntry latency_targets = 2;

            pub fn latency_targets(&self) -> &::std::collections::HashMap<::std::string::String, u32> {
                &self.latency_targets
            }

            pub fn clear_latency_targets(&mut self) {
                self.latency_targets.clear();
            }

            // Param is passed by value, moved
            pub fn set_latency_targets(&mut self, v: ::std::collections::HashMap<::std::string::String, u32>) {
                self.latency_targets = v;
            }

            // Mutable pointer to the field.
            pub fn mut_latency_targets(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u32> {
                &mut self.latency_targets
            }

            // Take field
            pub fn take_latency_targets(&mut self) -> ::std::collections::HashMap<::std::string::String, u32> {
                ::std::mem::replace(&mut self.latency_targets, ::std::collections::HashMap::new())
            }

            // bool kernel_bypass = 3;

            pub fn kernel_bypass(&self) -> bool {
                self.kernel_bypass
            }

            pub fn clear_kernel_bypass(&mut self) {
                self.kernel_bypass = false;
            }

            // Param is passed by value, moved
            pub fn set_kernel_bypass(&mut self, v: bool) {
                self.kernel_bypass = v;
            }

            // repeated string dma_channels = 4;

            pub fn dma_channels(&self) -> &[::std::string::String] {
                &self.dma_channels
            }

            pub fn clear_dma_channels(&mut self) {
                self.dma_channels.clear();
            }

            // Param is passed by value, moved
            pub fn set_dma_channels(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.dma_channels = v;
            }

            // Mutable pointer to the field.
            pub fn mut_dma_channels(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.dma_channels
            }

            // Take field
            pub fn take_dma_channels(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.dma_channels, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization.MemoryPoliciesEntry memory_policies = 5;

            pub fn memory_policies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.memory_policies
            }

            pub fn clear_memory_policies(&mut self) {
                self.memory_policies.clear();
            }

            // Param is passed by value, moved
            pub fn set_memory_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.memory_policies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_memory_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.memory_policies
            }

            // Take field
            pub fn take_memory_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.memory_policies, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "zero_copy_paths",
                    |m: &LatencyOptimization| { &m.zero_copy_paths },
                    |m: &mut LatencyOptimization| { &mut m.zero_copy_paths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "latency_targets",
                    |m: &LatencyOptimization| { &m.latency_targets },
                    |m: &mut LatencyOptimization| { &mut m.latency_targets },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "kernel_bypass",
                    |m: &LatencyOptimization| { &m.kernel_bypass },
                    |m: &mut LatencyOptimization| { &mut m.kernel_bypass },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "dma_channels",
                    |m: &LatencyOptimization| { &m.dma_channels },
                    |m: &mut LatencyOptimization| { &mut m.dma_channels },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "memory_policies",
                    |m: &LatencyOptimization| { &m.memory_policies },
                    |m: &mut LatencyOptimization| { &mut m.memory_policies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LatencyOptimization>(
                    "IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for LatencyOptimization {
            const NAME: &'static str = "LatencyOptimization";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.zero_copy_paths.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    16 => value = is.read_uint32()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.latency_targets.insert(key, value);
                        },
                        24 => {
                            self.kernel_bypass = is.read_bool()?;
                        },
                        34 => {
                            self.dma_channels.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.memory_policies.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.zero_copy_paths {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.latency_targets {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.kernel_bypass != false {
                    my_size += 1 + 1;
                }
                for value in &self.dma_channels {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.memory_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.zero_copy_paths {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.latency_targets {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_uint32(2, *v)?;
                };
                if self.kernel_bypass != false {
                    os.write_bool(3, self.kernel_bypass)?;
                }
                for v in &self.dma_channels {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.memory_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> LatencyOptimization {
                LatencyOptimization::new()
            }

            fn clear(&mut self) {
                self.zero_copy_paths.clear();
                self.latency_targets.clear();
                self.kernel_bypass = false;
                self.dma_channels.clear();
                self.memory_policies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static LatencyOptimization {
                static instance: ::protobuf::rt::Lazy<LatencyOptimization> = ::protobuf::rt::Lazy::new();
                instance.get(LatencyOptimization::new)
            }
        }

        impl ::protobuf::MessageFull for LatencyOptimization {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.LowLatencySystem.LatencyOptimization").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for LatencyOptimization {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for LatencyOptimization {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RealTimeScheduling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.rt_priorities)
            pub rt_priorities: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.scheduling_classes)
            pub scheduling_classes: ::std::collections::HashMap<::std::string::String, u32>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.preemption_control)
            pub preemption_control: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.affinity_masks)
            pub affinity_masks: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.rt_constraints)
            pub rt_constraints: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RealTimeScheduling {
            fn default() -> &'a RealTimeScheduling {
                <RealTimeScheduling as ::protobuf::Message>::default_instance()
            }
        }

        impl RealTimeScheduling {
            pub fn new() -> RealTimeScheduling {
                ::std::default::Default::default()
            }

            // repeated string rt_priorities = 1;

            pub fn rt_priorities(&self) -> &[::std::string::String] {
                &self.rt_priorities
            }

            pub fn clear_rt_priorities(&mut self) {
                self.rt_priorities.clear();
            }

            // Param is passed by value, moved
            pub fn set_rt_priorities(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.rt_priorities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_rt_priorities(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.rt_priorities
            }

            // Take field
            pub fn take_rt_priorities(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.rt_priorities, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.SchedulingClassesEntry scheduling_classes = 2;

            pub fn scheduling_classes(&self) -> &::std::collections::HashMap<::std::string::String, u32> {
                &self.scheduling_classes
            }

            pub fn clear_scheduling_classes(&mut self) {
                self.scheduling_classes.clear();
            }

            // Param is passed by value, moved
            pub fn set_scheduling_classes(&mut self, v: ::std::collections::HashMap<::std::string::String, u32>) {
                self.scheduling_classes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_scheduling_classes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u32> {
                &mut self.scheduling_classes
            }

            // Take field
            pub fn take_scheduling_classes(&mut self) -> ::std::collections::HashMap<::std::string::String, u32> {
                ::std::mem::replace(&mut self.scheduling_classes, ::std::collections::HashMap::new())
            }

            // bool preemption_control = 3;

            pub fn preemption_control(&self) -> bool {
                self.preemption_control
            }

            pub fn clear_preemption_control(&mut self) {
                self.preemption_control = false;
            }

            // Param is passed by value, moved
            pub fn set_preemption_control(&mut self, v: bool) {
                self.preemption_control = v;
            }

            // repeated string affinity_masks = 4;

            pub fn affinity_masks(&self) -> &[::std::string::String] {
                &self.affinity_masks
            }

            pub fn clear_affinity_masks(&mut self) {
                self.affinity_masks.clear();
            }

            // Param is passed by value, moved
            pub fn set_affinity_masks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.affinity_masks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_affinity_masks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.affinity_masks
            }

            // Take field
            pub fn take_affinity_masks(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.affinity_masks, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.RtConstraintsEntry rt_constraints = 5;

            pub fn rt_constraints(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.rt_constraints
            }

            pub fn clear_rt_constraints(&mut self) {
                self.rt_constraints.clear();
            }

            // Param is passed by value, moved
            pub fn set_rt_constraints(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.rt_constraints = v;
            }

            // Mutable pointer to the field.
            pub fn mut_rt_constraints(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.rt_constraints
            }

            // Take field
            pub fn take_rt_constraints(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.rt_constraints, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "rt_priorities",
                    |m: &RealTimeScheduling| { &m.rt_priorities },
                    |m: &mut RealTimeScheduling| { &mut m.rt_priorities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "scheduling_classes",
                    |m: &RealTimeScheduling| { &m.scheduling_classes },
                    |m: &mut RealTimeScheduling| { &mut m.scheduling_classes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "preemption_control",
                    |m: &RealTimeScheduling| { &m.preemption_control },
                    |m: &mut RealTimeScheduling| { &mut m.preemption_control },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "affinity_masks",
                    |m: &RealTimeScheduling| { &m.affinity_masks },
                    |m: &mut RealTimeScheduling| { &mut m.affinity_masks },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "rt_constraints",
                    |m: &RealTimeScheduling| { &m.rt_constraints },
                    |m: &mut RealTimeScheduling| { &mut m.rt_constraints },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RealTimeScheduling>(
                    "IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RealTimeScheduling {
            const NAME: &'static str = "RealTimeScheduling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.rt_priorities.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    16 => value = is.read_uint32()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.scheduling_classes.insert(key, value);
                        },
                        24 => {
                            self.preemption_control = is.read_bool()?;
                        },
                        34 => {
                            self.affinity_masks.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.rt_constraints.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.rt_priorities {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.scheduling_classes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.preemption_control != false {
                    my_size += 1 + 1;
                }
                for value in &self.affinity_masks {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.rt_constraints {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.rt_priorities {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.scheduling_classes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_uint32(2, *v)?;
                };
                if self.preemption_control != false {
                    os.write_bool(3, self.preemption_control)?;
                }
                for v in &self.affinity_masks {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.rt_constraints {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RealTimeScheduling {
                RealTimeScheduling::new()
            }

            fn clear(&mut self) {
                self.rt_priorities.clear();
                self.scheduling_classes.clear();
                self.preemption_control = false;
                self.affinity_masks.clear();
                self.rt_constraints.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RealTimeScheduling {
                static instance: ::protobuf::rt::Lazy<RealTimeScheduling> = ::protobuf::rt::Lazy::new();
                instance.get(RealTimeScheduling::new)
            }
        }

        impl ::protobuf::MessageFull for RealTimeScheduling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RealTimeScheduling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RealTimeScheduling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AsyncProcessing {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.async_queues)
            pub async_queues: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.queue_policies)
            pub queue_policies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.zero_latency_mode)
            pub zero_latency_mode: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.async_callbacks)
            pub async_callbacks: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.completion_tokens)
            pub completion_tokens: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AsyncProcessing {
            fn default() -> &'a AsyncProcessing {
                <AsyncProcessing as ::protobuf::Message>::default_instance()
            }
        }

        impl AsyncProcessing {
            pub fn new() -> AsyncProcessing {
                ::std::default::Default::default()
            }

            // repeated string async_queues = 1;

            pub fn async_queues(&self) -> &[::std::string::String] {
                &self.async_queues
            }

            pub fn clear_async_queues(&mut self) {
                self.async_queues.clear();
            }

            // Param is passed by value, moved
            pub fn set_async_queues(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.async_queues = v;
            }

            // Mutable pointer to the field.
            pub fn mut_async_queues(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.async_queues
            }

            // Take field
            pub fn take_async_queues(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.async_queues, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.QueuePoliciesEntry queue_policies = 2;

            pub fn queue_policies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.queue_policies
            }

            pub fn clear_queue_policies(&mut self) {
                self.queue_policies.clear();
            }

            // Param is passed by value, moved
            pub fn set_queue_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.queue_policies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_queue_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.queue_policies
            }

            // Take field
            pub fn take_queue_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.queue_policies, ::std::collections::HashMap::new())
            }

            // bool zero_latency_mode = 3;

            pub fn zero_latency_mode(&self) -> bool {
                self.zero_latency_mode
            }

            pub fn clear_zero_latency_mode(&mut self) {
                self.zero_latency_mode = false;
            }

            // Param is passed by value, moved
            pub fn set_zero_latency_mode(&mut self, v: bool) {
                self.zero_latency_mode = v;
            }

            // repeated string async_callbacks = 4;

            pub fn async_callbacks(&self) -> &[::std::string::String] {
                &self.async_callbacks
            }

            pub fn clear_async_callbacks(&mut self) {
                self.async_callbacks.clear();
            }

            // Param is passed by value, moved
            pub fn set_async_callbacks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.async_callbacks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_async_callbacks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.async_callbacks
            }

            // Take field
            pub fn take_async_callbacks(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.async_callbacks, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing.CompletionTokensEntry completion_tokens = 5;

            pub fn completion_tokens(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.completion_tokens
            }

            pub fn clear_completion_tokens(&mut self) {
                self.completion_tokens.clear();
            }

            // Param is passed by value, moved
            pub fn set_completion_tokens(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.completion_tokens = v;
            }

            // Mutable pointer to the field.
            pub fn mut_completion_tokens(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.completion_tokens
            }

            // Take field
            pub fn take_completion_tokens(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.completion_tokens, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "async_queues",
                    |m: &AsyncProcessing| { &m.async_queues },
                    |m: &mut AsyncProcessing| { &mut m.async_queues },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "queue_policies",
                    |m: &AsyncProcessing| { &m.queue_policies },
                    |m: &mut AsyncProcessing| { &mut m.queue_policies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "zero_latency_mode",
                    |m: &AsyncProcessing| { &m.zero_latency_mode },
                    |m: &mut AsyncProcessing| { &mut m.zero_latency_mode },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "async_callbacks",
                    |m: &AsyncProcessing| { &m.async_callbacks },
                    |m: &mut AsyncProcessing| { &mut m.async_callbacks },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "completion_tokens",
                    |m: &AsyncProcessing| { &m.completion_tokens },
                    |m: &mut AsyncProcessing| { &mut m.completion_tokens },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AsyncProcessing>(
                    "IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AsyncProcessing {
            const NAME: &'static str = "AsyncProcessing";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.async_queues.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.queue_policies.insert(key, value);
                        },
                        24 => {
                            self.zero_latency_mode = is.read_bool()?;
                        },
                        34 => {
                            self.async_callbacks.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.completion_tokens.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.async_queues {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.queue_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.zero_latency_mode != false {
                    my_size += 1 + 1;
                }
                for value in &self.async_callbacks {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.completion_tokens {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.async_queues {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.queue_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.zero_latency_mode != false {
                    os.write_bool(3, self.zero_latency_mode)?;
                }
                for v in &self.async_callbacks {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.completion_tokens {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AsyncProcessing {
                AsyncProcessing::new()
            }

            fn clear(&mut self) {
                self.async_queues.clear();
                self.queue_policies.clear();
                self.zero_latency_mode = false;
                self.async_callbacks.clear();
                self.completion_tokens.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AsyncProcessing {
                static instance: ::protobuf::rt::Lazy<AsyncProcessing> = ::protobuf::rt::Lazy::new();
                instance.get(AsyncProcessing::new)
            }
        }

        impl ::protobuf::MessageFull for AsyncProcessing {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.LowLatencySystem.AsyncProcessing").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AsyncProcessing {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AsyncProcessing {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ConcurrencyEngine {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConcurrencyEngine {
        fn default() -> &'a ConcurrencyEngine {
            <ConcurrencyEngine as ::protobuf::Message>::default_instance()
        }
    }

    impl ConcurrencyEngine {
        pub fn new() -> ConcurrencyEngine {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConcurrencyEngine>(
                "IntelligentHardwareSystem.ConcurrencyEngine",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ConcurrencyEngine {
        const NAME: &'static str = "ConcurrencyEngine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConcurrencyEngine {
            ConcurrencyEngine::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConcurrencyEngine {
            static instance: ConcurrencyEngine = ConcurrencyEngine {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ConcurrencyEngine {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ConcurrencyEngine").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ConcurrencyEngine {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ConcurrencyEngine {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ConcurrencyEngine`
    pub mod concurrency_engine {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct WorkloadDistribution {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.work_groups)
            pub work_groups: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.load_balancing)
            pub load_balancing: ::std::collections::HashMap<::std::string::String, u32>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.dynamic_scaling)
            pub dynamic_scaling: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.distribution_rules)
            pub distribution_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.workload_metrics)
            pub workload_metrics: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a WorkloadDistribution {
            fn default() -> &'a WorkloadDistribution {
                <WorkloadDistribution as ::protobuf::Message>::default_instance()
            }
        }

        impl WorkloadDistribution {
            pub fn new() -> WorkloadDistribution {
                ::std::default::Default::default()
            }

            // repeated string work_groups = 1;

            pub fn work_groups(&self) -> &[::std::string::String] {
                &self.work_groups
            }

            pub fn clear_work_groups(&mut self) {
                self.work_groups.clear();
            }

            // Param is passed by value, moved
            pub fn set_work_groups(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.work_groups = v;
            }

            // Mutable pointer to the field.
            pub fn mut_work_groups(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.work_groups
            }

            // Take field
            pub fn take_work_groups(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.work_groups, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.LoadBalancingEntry load_balancing = 2;

            pub fn load_balancing(&self) -> &::std::collections::HashMap<::std::string::String, u32> {
                &self.load_balancing
            }

            pub fn clear_load_balancing(&mut self) {
                self.load_balancing.clear();
            }

            // Param is passed by value, moved
            pub fn set_load_balancing(&mut self, v: ::std::collections::HashMap<::std::string::String, u32>) {
                self.load_balancing = v;
            }

            // Mutable pointer to the field.
            pub fn mut_load_balancing(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u32> {
                &mut self.load_balancing
            }

            // Take field
            pub fn take_load_balancing(&mut self) -> ::std::collections::HashMap<::std::string::String, u32> {
                ::std::mem::replace(&mut self.load_balancing, ::std::collections::HashMap::new())
            }

            // bool dynamic_scaling = 3;

            pub fn dynamic_scaling(&self) -> bool {
                self.dynamic_scaling
            }

            pub fn clear_dynamic_scaling(&mut self) {
                self.dynamic_scaling = false;
            }

            // Param is passed by value, moved
            pub fn set_dynamic_scaling(&mut self, v: bool) {
                self.dynamic_scaling = v;
            }

            // repeated string distribution_rules = 4;

            pub fn distribution_rules(&self) -> &[::std::string::String] {
                &self.distribution_rules
            }

            pub fn clear_distribution_rules(&mut self) {
                self.distribution_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_distribution_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.distribution_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_distribution_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.distribution_rules
            }

            // Take field
            pub fn take_distribution_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.distribution_rules, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution.WorkloadMetricsEntry workload_metrics = 5;

            pub fn workload_metrics(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.workload_metrics
            }

            pub fn clear_workload_metrics(&mut self) {
                self.workload_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_workload_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.workload_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_workload_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.workload_metrics
            }

            // Take field
            pub fn take_workload_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.workload_metrics, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "work_groups",
                    |m: &WorkloadDistribution| { &m.work_groups },
                    |m: &mut WorkloadDistribution| { &mut m.work_groups },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "load_balancing",
                    |m: &WorkloadDistribution| { &m.load_balancing },
                    |m: &mut WorkloadDistribution| { &mut m.load_balancing },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "dynamic_scaling",
                    |m: &WorkloadDistribution| { &m.dynamic_scaling },
                    |m: &mut WorkloadDistribution| { &mut m.dynamic_scaling },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "distribution_rules",
                    |m: &WorkloadDistribution| { &m.distribution_rules },
                    |m: &mut WorkloadDistribution| { &mut m.distribution_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "workload_metrics",
                    |m: &WorkloadDistribution| { &m.workload_metrics },
                    |m: &mut WorkloadDistribution| { &mut m.workload_metrics },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkloadDistribution>(
                    "IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for WorkloadDistribution {
            const NAME: &'static str = "WorkloadDistribution";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.work_groups.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    16 => value = is.read_uint32()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.load_balancing.insert(key, value);
                        },
                        24 => {
                            self.dynamic_scaling = is.read_bool()?;
                        },
                        34 => {
                            self.distribution_rules.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.workload_metrics.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.work_groups {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.load_balancing {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.dynamic_scaling != false {
                    my_size += 1 + 1;
                }
                for value in &self.distribution_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.workload_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.work_groups {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.load_balancing {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint32_size(2, *v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_uint32(2, *v)?;
                };
                if self.dynamic_scaling != false {
                    os.write_bool(3, self.dynamic_scaling)?;
                }
                for v in &self.distribution_rules {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.workload_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> WorkloadDistribution {
                WorkloadDistribution::new()
            }

            fn clear(&mut self) {
                self.work_groups.clear();
                self.load_balancing.clear();
                self.dynamic_scaling = false;
                self.distribution_rules.clear();
                self.workload_metrics.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static WorkloadDistribution {
                static instance: ::protobuf::rt::Lazy<WorkloadDistribution> = ::protobuf::rt::Lazy::new();
                instance.get(WorkloadDistribution::new)
            }
        }

        impl ::protobuf::MessageFull for WorkloadDistribution {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistribution").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for WorkloadDistribution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for WorkloadDistribution {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ParallelExecution {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.execution_units)
            pub execution_units: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.parallel_patterns)
            pub parallel_patterns: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.vectorization)
            pub vectorization: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.simd_operations)
            pub simd_operations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.threading_model)
            pub threading_model: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ParallelExecution {
            fn default() -> &'a ParallelExecution {
                <ParallelExecution as ::protobuf::Message>::default_instance()
            }
        }

        impl ParallelExecution {
            pub fn new() -> ParallelExecution {
                ::std::default::Default::default()
            }

            // repeated string execution_units = 1;

            pub fn execution_units(&self) -> &[::std::string::String] {
                &self.execution_units
            }

            pub fn clear_execution_units(&mut self) {
                self.execution_units.clear();
            }

            // Param is passed by value, moved
            pub fn set_execution_units(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.execution_units = v;
            }

            // Mutable pointer to the field.
            pub fn mut_execution_units(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.execution_units
            }

            // Take field
            pub fn take_execution_units(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.execution_units, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.ParallelPatternsEntry parallel_patterns = 2;

            pub fn parallel_patterns(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.parallel_patterns
            }

            pub fn clear_parallel_patterns(&mut self) {
                self.parallel_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_parallel_patterns(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.parallel_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_parallel_patterns(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.parallel_patterns
            }

            // Take field
            pub fn take_parallel_patterns(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.parallel_patterns, ::std::collections::HashMap::new())
            }

            // bool vectorization = 3;

            pub fn vectorization(&self) -> bool {
                self.vectorization
            }

            pub fn clear_vectorization(&mut self) {
                self.vectorization = false;
            }

            // Param is passed by value, moved
            pub fn set_vectorization(&mut self, v: bool) {
                self.vectorization = v;
            }

            // repeated string simd_operations = 4;

            pub fn simd_operations(&self) -> &[::std::string::String] {
                &self.simd_operations
            }

            pub fn clear_simd_operations(&mut self) {
                self.simd_operations.clear();
            }

            // Param is passed by value, moved
            pub fn set_simd_operations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.simd_operations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_simd_operations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.simd_operations
            }

            // Take field
            pub fn take_simd_operations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.simd_operations, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.ThreadingModelEntry threading_model = 5;

            pub fn threading_model(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.threading_model
            }

            pub fn clear_threading_model(&mut self) {
                self.threading_model.clear();
            }

            // Param is passed by value, moved
            pub fn set_threading_model(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.threading_model = v;
            }

            // Mutable pointer to the field.
            pub fn mut_threading_model(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.threading_model
            }

            // Take field
            pub fn take_threading_model(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.threading_model, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "execution_units",
                    |m: &ParallelExecution| { &m.execution_units },
                    |m: &mut ParallelExecution| { &mut m.execution_units },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "parallel_patterns",
                    |m: &ParallelExecution| { &m.parallel_patterns },
                    |m: &mut ParallelExecution| { &mut m.parallel_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "vectorization",
                    |m: &ParallelExecution| { &m.vectorization },
                    |m: &mut ParallelExecution| { &mut m.vectorization },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "simd_operations",
                    |m: &ParallelExecution| { &m.simd_operations },
                    |m: &mut ParallelExecution| { &mut m.simd_operations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "threading_model",
                    |m: &ParallelExecution| { &m.threading_model },
                    |m: &mut ParallelExecution| { &mut m.threading_model },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParallelExecution>(
                    "IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ParallelExecution {
            const NAME: &'static str = "ParallelExecution";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.execution_units.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.parallel_patterns.insert(key, value);
                        },
                        24 => {
                            self.vectorization = is.read_bool()?;
                        },
                        34 => {
                            self.simd_operations.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.threading_model.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.execution_units {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.parallel_patterns {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.vectorization != false {
                    my_size += 1 + 1;
                }
                for value in &self.simd_operations {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.threading_model {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.execution_units {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.parallel_patterns {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.vectorization != false {
                    os.write_bool(3, self.vectorization)?;
                }
                for v in &self.simd_operations {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.threading_model {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ParallelExecution {
                ParallelExecution::new()
            }

            fn clear(&mut self) {
                self.execution_units.clear();
                self.parallel_patterns.clear();
                self.vectorization = false;
                self.simd_operations.clear();
                self.threading_model.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ParallelExecution {
                static instance: ::protobuf::rt::Lazy<ParallelExecution> = ::protobuf::rt::Lazy::new();
                instance.get(ParallelExecution::new)
            }
        }

        impl ::protobuf::MessageFull for ParallelExecution {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ParallelExecution {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ParallelExecution {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SynchronizationPrimitives {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.sync_mechanisms)
            pub sync_mechanisms: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.barrier_types)
            pub barrier_types: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.lock_free)
            pub lock_free: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.atomic_operations)
            pub atomic_operations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.memory_ordering)
            pub memory_ordering: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SynchronizationPrimitives {
            fn default() -> &'a SynchronizationPrimitives {
                <SynchronizationPrimitives as ::protobuf::Message>::default_instance()
            }
        }

        impl SynchronizationPrimitives {
            pub fn new() -> SynchronizationPrimitives {
                ::std::default::Default::default()
            }

            // repeated string sync_mechanisms = 1;

            pub fn sync_mechanisms(&self) -> &[::std::string::String] {
                &self.sync_mechanisms
            }

            pub fn clear_sync_mechanisms(&mut self) {
                self.sync_mechanisms.clear();
            }

            // Param is passed by value, moved
            pub fn set_sync_mechanisms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.sync_mechanisms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_sync_mechanisms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.sync_mechanisms
            }

            // Take field
            pub fn take_sync_mechanisms(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.sync_mechanisms, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.BarrierTypesEntry barrier_types = 2;

            pub fn barrier_types(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.barrier_types
            }

            pub fn clear_barrier_types(&mut self) {
                self.barrier_types.clear();
            }

            // Param is passed by value, moved
            pub fn set_barrier_types(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.barrier_types = v;
            }

            // Mutable pointer to the field.
            pub fn mut_barrier_types(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.barrier_types
            }

            // Take field
            pub fn take_barrier_types(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.barrier_types, ::std::collections::HashMap::new())
            }

            // bool lock_free = 3;

            pub fn lock_free(&self) -> bool {
                self.lock_free
            }

            pub fn clear_lock_free(&mut self) {
                self.lock_free = false;
            }

            // Param is passed by value, moved
            pub fn set_lock_free(&mut self, v: bool) {
                self.lock_free = v;
            }

            // repeated string atomic_operations = 4;

            pub fn atomic_operations(&self) -> &[::std::string::String] {
                &self.atomic_operations
            }

            pub fn clear_atomic_operations(&mut self) {
                self.atomic_operations.clear();
            }

            // Param is passed by value, moved
            pub fn set_atomic_operations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.atomic_operations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_atomic_operations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.atomic_operations
            }

            // Take field
            pub fn take_atomic_operations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.atomic_operations, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives.MemoryOrderingEntry memory_ordering = 5;

            pub fn memory_ordering(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.memory_ordering
            }

            pub fn clear_memory_ordering(&mut self) {
                self.memory_ordering.clear();
            }

            // Param is passed by value, moved
            pub fn set_memory_ordering(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.memory_ordering = v;
            }

            // Mutable pointer to the field.
            pub fn mut_memory_ordering(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.memory_ordering
            }

            // Take field
            pub fn take_memory_ordering(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.memory_ordering, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "sync_mechanisms",
                    |m: &SynchronizationPrimitives| { &m.sync_mechanisms },
                    |m: &mut SynchronizationPrimitives| { &mut m.sync_mechanisms },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "barrier_types",
                    |m: &SynchronizationPrimitives| { &m.barrier_types },
                    |m: &mut SynchronizationPrimitives| { &mut m.barrier_types },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "lock_free",
                    |m: &SynchronizationPrimitives| { &m.lock_free },
                    |m: &mut SynchronizationPrimitives| { &mut m.lock_free },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "atomic_operations",
                    |m: &SynchronizationPrimitives| { &m.atomic_operations },
                    |m: &mut SynchronizationPrimitives| { &mut m.atomic_operations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "memory_ordering",
                    |m: &SynchronizationPrimitives| { &m.memory_ordering },
                    |m: &mut SynchronizationPrimitives| { &mut m.memory_ordering },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SynchronizationPrimitives>(
                    "IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SynchronizationPrimitives {
            const NAME: &'static str = "SynchronizationPrimitives";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.sync_mechanisms.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.barrier_types.insert(key, value);
                        },
                        24 => {
                            self.lock_free = is.read_bool()?;
                        },
                        34 => {
                            self.atomic_operations.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.memory_ordering.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.sync_mechanisms {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.barrier_types {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.lock_free != false {
                    my_size += 1 + 1;
                }
                for value in &self.atomic_operations {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.memory_ordering {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.sync_mechanisms {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.barrier_types {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.lock_free != false {
                    os.write_bool(3, self.lock_free)?;
                }
                for v in &self.atomic_operations {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.memory_ordering {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SynchronizationPrimitives {
                SynchronizationPrimitives::new()
            }

            fn clear(&mut self) {
                self.sync_mechanisms.clear();
                self.barrier_types.clear();
                self.lock_free = false;
                self.atomic_operations.clear();
                self.memory_ordering.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SynchronizationPrimitives {
                static instance: ::protobuf::rt::Lazy<SynchronizationPrimitives> = ::protobuf::rt::Lazy::new();
                instance.get(SynchronizationPrimitives::new)
            }
        }

        impl ::protobuf::MessageFull for SynchronizationPrimitives {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.ConcurrencyEngine.SynchronizationPrimitives").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SynchronizationPrimitives {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SynchronizationPrimitives {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.MemorySystem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MemorySystem {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MemorySystem {
        fn default() -> &'a MemorySystem {
            <MemorySystem as ::protobuf::Message>::default_instance()
        }
    }

    impl MemorySystem {
        pub fn new() -> MemorySystem {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemorySystem>(
                "IntelligentHardwareSystem.MemorySystem",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MemorySystem {
        const NAME: &'static str = "MemorySystem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MemorySystem {
            MemorySystem::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MemorySystem {
            static instance: MemorySystem = MemorySystem {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MemorySystem {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.MemorySystem").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MemorySystem {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MemorySystem {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `MemorySystem`
    pub mod memory_system {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MemoryHierarchy {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.cache_levels)
            pub cache_levels: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.memory_sizes)
            pub memory_sizes: ::std::collections::HashMap<::std::string::String, u64>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.numa_aware)
            pub numa_aware: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.memory_types)
            pub memory_types: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.memory_zones)
            pub memory_zones: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MemoryHierarchy {
            fn default() -> &'a MemoryHierarchy {
                <MemoryHierarchy as ::protobuf::Message>::default_instance()
            }
        }

        impl MemoryHierarchy {
            pub fn new() -> MemoryHierarchy {
                ::std::default::Default::default()
            }

            // repeated string cache_levels = 1;

            pub fn cache_levels(&self) -> &[::std::string::String] {
                &self.cache_levels
            }

            pub fn clear_cache_levels(&mut self) {
                self.cache_levels.clear();
            }

            // Param is passed by value, moved
            pub fn set_cache_levels(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.cache_levels = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cache_levels(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.cache_levels
            }

            // Take field
            pub fn take_cache_levels(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.cache_levels, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.MemorySizesEntry memory_sizes = 2;

            pub fn memory_sizes(&self) -> &::std::collections::HashMap<::std::string::String, u64> {
                &self.memory_sizes
            }

            pub fn clear_memory_sizes(&mut self) {
                self.memory_sizes.clear();
            }

            // Param is passed by value, moved
            pub fn set_memory_sizes(&mut self, v: ::std::collections::HashMap<::std::string::String, u64>) {
                self.memory_sizes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_memory_sizes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, u64> {
                &mut self.memory_sizes
            }

            // Take field
            pub fn take_memory_sizes(&mut self) -> ::std::collections::HashMap<::std::string::String, u64> {
                ::std::mem::replace(&mut self.memory_sizes, ::std::collections::HashMap::new())
            }

            // bool numa_aware = 3;

            pub fn numa_aware(&self) -> bool {
                self.numa_aware
            }

            pub fn clear_numa_aware(&mut self) {
                self.numa_aware = false;
            }

            // Param is passed by value, moved
            pub fn set_numa_aware(&mut self, v: bool) {
                self.numa_aware = v;
            }

            // repeated string memory_types = 4;

            pub fn memory_types(&self) -> &[::std::string::String] {
                &self.memory_types
            }

            pub fn clear_memory_types(&mut self) {
                self.memory_types.clear();
            }

            // Param is passed by value, moved
            pub fn set_memory_types(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.memory_types = v;
            }

            // Mutable pointer to the field.
            pub fn mut_memory_types(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.memory_types
            }

            // Take field
            pub fn take_memory_types(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.memory_types, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.MemoryZonesEntry memory_zones = 5;

            pub fn memory_zones(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.memory_zones
            }

            pub fn clear_memory_zones(&mut self) {
                self.memory_zones.clear();
            }

            // Param is passed by value, moved
            pub fn set_memory_zones(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.memory_zones = v;
            }

            // Mutable pointer to the field.
            pub fn mut_memory_zones(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.memory_zones
            }

            // Take field
            pub fn take_memory_zones(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.memory_zones, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "cache_levels",
                    |m: &MemoryHierarchy| { &m.cache_levels },
                    |m: &mut MemoryHierarchy| { &mut m.cache_levels },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "memory_sizes",
                    |m: &MemoryHierarchy| { &m.memory_sizes },
                    |m: &mut MemoryHierarchy| { &mut m.memory_sizes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "numa_aware",
                    |m: &MemoryHierarchy| { &m.numa_aware },
                    |m: &mut MemoryHierarchy| { &mut m.numa_aware },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "memory_types",
                    |m: &MemoryHierarchy| { &m.memory_types },
                    |m: &mut MemoryHierarchy| { &mut m.memory_types },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "memory_zones",
                    |m: &MemoryHierarchy| { &m.memory_zones },
                    |m: &mut MemoryHierarchy| { &mut m.memory_zones },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryHierarchy>(
                    "IntelligentHardwareSystem.MemorySystem.MemoryHierarchy",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MemoryHierarchy {
            const NAME: &'static str = "MemoryHierarchy";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.cache_levels.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    16 => value = is.read_uint64()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.memory_sizes.insert(key, value);
                        },
                        24 => {
                            self.numa_aware = is.read_bool()?;
                        },
                        34 => {
                            self.memory_types.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.memory_zones.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.cache_levels {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.memory_sizes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint64_size(2, *v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.numa_aware != false {
                    my_size += 1 + 1;
                }
                for value in &self.memory_types {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.memory_zones {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.cache_levels {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.memory_sizes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::uint64_size(2, *v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_uint64(2, *v)?;
                };
                if self.numa_aware != false {
                    os.write_bool(3, self.numa_aware)?;
                }
                for v in &self.memory_types {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.memory_zones {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MemoryHierarchy {
                MemoryHierarchy::new()
            }

            fn clear(&mut self) {
                self.cache_levels.clear();
                self.memory_sizes.clear();
                self.numa_aware = false;
                self.memory_types.clear();
                self.memory_zones.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MemoryHierarchy {
                static instance: ::protobuf::rt::Lazy<MemoryHierarchy> = ::protobuf::rt::Lazy::new();
                instance.get(MemoryHierarchy::new)
            }
        }

        impl ::protobuf::MessageFull for MemoryHierarchy {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.MemorySystem.MemoryHierarchy").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MemoryHierarchy {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MemoryHierarchy {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MemoryOptimization {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.allocation_strategies)
            pub allocation_strategies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.pooling_configs)
            pub pooling_configs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.zero_allocation)
            pub zero_allocation: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.defrag_policies)
            pub defrag_policies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.compression)
            pub compression: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MemoryOptimization {
            fn default() -> &'a MemoryOptimization {
                <MemoryOptimization as ::protobuf::Message>::default_instance()
            }
        }

        impl MemoryOptimization {
            pub fn new() -> MemoryOptimization {
                ::std::default::Default::default()
            }

            // repeated string allocation_strategies = 1;

            pub fn allocation_strategies(&self) -> &[::std::string::String] {
                &self.allocation_strategies
            }

            pub fn clear_allocation_strategies(&mut self) {
                self.allocation_strategies.clear();
            }

            // Param is passed by value, moved
            pub fn set_allocation_strategies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.allocation_strategies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_allocation_strategies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.allocation_strategies
            }

            // Take field
            pub fn take_allocation_strategies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.allocation_strategies, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.PoolingConfigsEntry pooling_configs = 2;

            pub fn pooling_configs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.pooling_configs
            }

            pub fn clear_pooling_configs(&mut self) {
                self.pooling_configs.clear();
            }

            // Param is passed by value, moved
            pub fn set_pooling_configs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.pooling_configs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_pooling_configs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.pooling_configs
            }

            // Take field
            pub fn take_pooling_configs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.pooling_configs, ::std::collections::HashMap::new())
            }

            // bool zero_allocation = 3;

            pub fn zero_allocation(&self) -> bool {
                self.zero_allocation
            }

            pub fn clear_zero_allocation(&mut self) {
                self.zero_allocation = false;
            }

            // Param is passed by value, moved
            pub fn set_zero_allocation(&mut self, v: bool) {
                self.zero_allocation = v;
            }

            // repeated string defrag_policies = 4;

            pub fn defrag_policies(&self) -> &[::std::string::String] {
                &self.defrag_policies
            }

            pub fn clear_defrag_policies(&mut self) {
                self.defrag_policies.clear();
            }

            // Param is passed by value, moved
            pub fn set_defrag_policies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.defrag_policies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_defrag_policies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.defrag_policies
            }

            // Take field
            pub fn take_defrag_policies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.defrag_policies, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryOptimization.CompressionEntry compression = 5;

            pub fn compression(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.compression
            }

            pub fn clear_compression(&mut self) {
                self.compression.clear();
            }

            // Param is passed by value, moved
            pub fn set_compression(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.compression = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compression(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.compression
            }

            // Take field
            pub fn take_compression(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.compression, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "allocation_strategies",
                    |m: &MemoryOptimization| { &m.allocation_strategies },
                    |m: &mut MemoryOptimization| { &mut m.allocation_strategies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "pooling_configs",
                    |m: &MemoryOptimization| { &m.pooling_configs },
                    |m: &mut MemoryOptimization| { &mut m.pooling_configs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "zero_allocation",
                    |m: &MemoryOptimization| { &m.zero_allocation },
                    |m: &mut MemoryOptimization| { &mut m.zero_allocation },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "defrag_policies",
                    |m: &MemoryOptimization| { &m.defrag_policies },
                    |m: &mut MemoryOptimization| { &mut m.defrag_policies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "compression",
                    |m: &MemoryOptimization| { &m.compression },
                    |m: &mut MemoryOptimization| { &mut m.compression },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MemoryOptimization>(
                    "IntelligentHardwareSystem.MemorySystem.MemoryOptimization",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MemoryOptimization {
            const NAME: &'static str = "MemoryOptimization";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.allocation_strategies.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.pooling_configs.insert(key, value);
                        },
                        24 => {
                            self.zero_allocation = is.read_bool()?;
                        },
                        34 => {
                            self.defrag_policies.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.compression.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.allocation_strategies {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.pooling_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.zero_allocation != false {
                    my_size += 1 + 1;
                }
                for value in &self.defrag_policies {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.compression {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.allocation_strategies {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.pooling_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.zero_allocation != false {
                    os.write_bool(3, self.zero_allocation)?;
                }
                for v in &self.defrag_policies {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.compression {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MemoryOptimization {
                MemoryOptimization::new()
            }

            fn clear(&mut self) {
                self.allocation_strategies.clear();
                self.pooling_configs.clear();
                self.zero_allocation = false;
                self.defrag_policies.clear();
                self.compression.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MemoryOptimization {
                static instance: ::protobuf::rt::Lazy<MemoryOptimization> = ::protobuf::rt::Lazy::new();
                instance.get(MemoryOptimization::new)
            }
        }

        impl ::protobuf::MessageFull for MemoryOptimization {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.MemorySystem.MemoryOptimization").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MemoryOptimization {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MemoryOptimization {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DataTransfer {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.transfer_modes)
            pub transfer_modes: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.dma_configs)
            pub dma_configs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.peer_access)
            pub peer_access: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.transfer_queues)
            pub transfer_queues: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.bandwidth_control)
            pub bandwidth_control: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DataTransfer {
            fn default() -> &'a DataTransfer {
                <DataTransfer as ::protobuf::Message>::default_instance()
            }
        }

        impl DataTransfer {
            pub fn new() -> DataTransfer {
                ::std::default::Default::default()
            }

            // repeated string transfer_modes = 1;

            pub fn transfer_modes(&self) -> &[::std::string::String] {
                &self.transfer_modes
            }

            pub fn clear_transfer_modes(&mut self) {
                self.transfer_modes.clear();
            }

            // Param is passed by value, moved
            pub fn set_transfer_modes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.transfer_modes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_transfer_modes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.transfer_modes
            }

            // Take field
            pub fn take_transfer_modes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.transfer_modes, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.DmaConfigsEntry dma_configs = 2;

            pub fn dma_configs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.dma_configs
            }

            pub fn clear_dma_configs(&mut self) {
                self.dma_configs.clear();
            }

            // Param is passed by value, moved
            pub fn set_dma_configs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.dma_configs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_dma_configs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.dma_configs
            }

            // Take field
            pub fn take_dma_configs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.dma_configs, ::std::collections::HashMap::new())
            }

            // bool peer_access = 3;

            pub fn peer_access(&self) -> bool {
                self.peer_access
            }

            pub fn clear_peer_access(&mut self) {
                self.peer_access = false;
            }

            // Param is passed by value, moved
            pub fn set_peer_access(&mut self, v: bool) {
                self.peer_access = v;
            }

            // repeated string transfer_queues = 4;

            pub fn transfer_queues(&self) -> &[::std::string::String] {
                &self.transfer_queues
            }

            pub fn clear_transfer_queues(&mut self) {
                self.transfer_queues.clear();
            }

            // Param is passed by value, moved
            pub fn set_transfer_queues(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.transfer_queues = v;
            }

            // Mutable pointer to the field.
            pub fn mut_transfer_queues(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.transfer_queues
            }

            // Take field
            pub fn take_transfer_queues(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.transfer_queues, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.MemorySystem.DataTransfer.BandwidthControlEntry bandwidth_control = 5;

            pub fn bandwidth_control(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.bandwidth_control
            }

            pub fn clear_bandwidth_control(&mut self) {
                self.bandwidth_control.clear();
            }

            // Param is passed by value, moved
            pub fn set_bandwidth_control(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.bandwidth_control = v;
            }

            // Mutable pointer to the field.
            pub fn mut_bandwidth_control(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.bandwidth_control
            }

            // Take field
            pub fn take_bandwidth_control(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.bandwidth_control, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "transfer_modes",
                    |m: &DataTransfer| { &m.transfer_modes },
                    |m: &mut DataTransfer| { &mut m.transfer_modes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "dma_configs",
                    |m: &DataTransfer| { &m.dma_configs },
                    |m: &mut DataTransfer| { &mut m.dma_configs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "peer_access",
                    |m: &DataTransfer| { &m.peer_access },
                    |m: &mut DataTransfer| { &mut m.peer_access },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "transfer_queues",
                    |m: &DataTransfer| { &m.transfer_queues },
                    |m: &mut DataTransfer| { &mut m.transfer_queues },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "bandwidth_control",
                    |m: &DataTransfer| { &m.bandwidth_control },
                    |m: &mut DataTransfer| { &mut m.bandwidth_control },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataTransfer>(
                    "IntelligentHardwareSystem.MemorySystem.DataTransfer",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DataTransfer {
            const NAME: &'static str = "DataTransfer";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.transfer_modes.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.dma_configs.insert(key, value);
                        },
                        24 => {
                            self.peer_access = is.read_bool()?;
                        },
                        34 => {
                            self.transfer_queues.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.bandwidth_control.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.transfer_modes {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.dma_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.peer_access != false {
                    my_size += 1 + 1;
                }
                for value in &self.transfer_queues {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.bandwidth_control {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.transfer_modes {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.dma_configs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.peer_access != false {
                    os.write_bool(3, self.peer_access)?;
                }
                for v in &self.transfer_queues {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.bandwidth_control {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DataTransfer {
                DataTransfer::new()
            }

            fn clear(&mut self) {
                self.transfer_modes.clear();
                self.dma_configs.clear();
                self.peer_access = false;
                self.transfer_queues.clear();
                self.bandwidth_control.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DataTransfer {
                static instance: ::protobuf::rt::Lazy<DataTransfer> = ::protobuf::rt::Lazy::new();
                instance.get(DataTransfer::new)
            }
        }

        impl ::protobuf::MessageFull for DataTransfer {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.MemorySystem.DataTransfer").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DataTransfer {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DataTransfer {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.AutoIntegration)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AutoIntegration {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AutoIntegration {
        fn default() -> &'a AutoIntegration {
            <AutoIntegration as ::protobuf::Message>::default_instance()
        }
    }

    impl AutoIntegration {
        pub fn new() -> AutoIntegration {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutoIntegration>(
                "IntelligentHardwareSystem.AutoIntegration",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AutoIntegration {
        const NAME: &'static str = "AutoIntegration";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AutoIntegration {
            AutoIntegration::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AutoIntegration {
            static instance: AutoIntegration = AutoIntegration {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AutoIntegration {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.AutoIntegration").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AutoIntegration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AutoIntegration {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AutoIntegration`
    pub mod auto_integration {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PlatformAdaptation {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.platform_profiles)
            pub platform_profiles: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.adaptation_rules)
            pub adaptation_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.dynamic_reconfiguration)
            pub dynamic_reconfiguration: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.hardware_paths)
            pub hardware_paths: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.driver_mappings)
            pub driver_mappings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PlatformAdaptation {
            fn default() -> &'a PlatformAdaptation {
                <PlatformAdaptation as ::protobuf::Message>::default_instance()
            }
        }

        impl PlatformAdaptation {
            pub fn new() -> PlatformAdaptation {
                ::std::default::Default::default()
            }

            // repeated string platform_profiles = 1;

            pub fn platform_profiles(&self) -> &[::std::string::String] {
                &self.platform_profiles
            }

            pub fn clear_platform_profiles(&mut self) {
                self.platform_profiles.clear();
            }

            // Param is passed by value, moved
            pub fn set_platform_profiles(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.platform_profiles = v;
            }

            // Mutable pointer to the field.
            pub fn mut_platform_profiles(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.platform_profiles
            }

            // Take field
            pub fn take_platform_profiles(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.platform_profiles, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.AdaptationRulesEntry adaptation_rules = 2;

            pub fn adaptation_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.adaptation_rules
            }

            pub fn clear_adaptation_rules(&mut self) {
                self.adaptation_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_adaptation_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.adaptation_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_adaptation_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.adaptation_rules
            }

            // Take field
            pub fn take_adaptation_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.adaptation_rules, ::std::collections::HashMap::new())
            }

            // bool dynamic_reconfiguration = 3;

            pub fn dynamic_reconfiguration(&self) -> bool {
                self.dynamic_reconfiguration
            }

            pub fn clear_dynamic_reconfiguration(&mut self) {
                self.dynamic_reconfiguration = false;
            }

            // Param is passed by value, moved
            pub fn set_dynamic_reconfiguration(&mut self, v: bool) {
                self.dynamic_reconfiguration = v;
            }

            // repeated string hardware_paths = 4;

            pub fn hardware_paths(&self) -> &[::std::string::String] {
                &self.hardware_paths
            }

            pub fn clear_hardware_paths(&mut self) {
                self.hardware_paths.clear();
            }

            // Param is passed by value, moved
            pub fn set_hardware_paths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.hardware_paths = v;
            }

            // Mutable pointer to the field.
            pub fn mut_hardware_paths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.hardware_paths
            }

            // Take field
            pub fn take_hardware_paths(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.hardware_paths, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.DriverMappingsEntry driver_mappings = 5;

            pub fn driver_mappings(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.driver_mappings
            }

            pub fn clear_driver_mappings(&mut self) {
                self.driver_mappings.clear();
            }

            // Param is passed by value, moved
            pub fn set_driver_mappings(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.driver_mappings = v;
            }

            // Mutable pointer to the field.
            pub fn mut_driver_mappings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.driver_mappings
            }

            // Take field
            pub fn take_driver_mappings(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.driver_mappings, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "platform_profiles",
                    |m: &PlatformAdaptation| { &m.platform_profiles },
                    |m: &mut PlatformAdaptation| { &mut m.platform_profiles },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "adaptation_rules",
                    |m: &PlatformAdaptation| { &m.adaptation_rules },
                    |m: &mut PlatformAdaptation| { &mut m.adaptation_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "dynamic_reconfiguration",
                    |m: &PlatformAdaptation| { &m.dynamic_reconfiguration },
                    |m: &mut PlatformAdaptation| { &mut m.dynamic_reconfiguration },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "hardware_paths",
                    |m: &PlatformAdaptation| { &m.hardware_paths },
                    |m: &mut PlatformAdaptation| { &mut m.hardware_paths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "driver_mappings",
                    |m: &PlatformAdaptation| { &m.driver_mappings },
                    |m: &mut PlatformAdaptation| { &mut m.driver_mappings },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlatformAdaptation>(
                    "IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PlatformAdaptation {
            const NAME: &'static str = "PlatformAdaptation";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.platform_profiles.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.adaptation_rules.insert(key, value);
                        },
                        24 => {
                            self.dynamic_reconfiguration = is.read_bool()?;
                        },
                        34 => {
                            self.hardware_paths.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.driver_mappings.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.platform_profiles {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.adaptation_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.dynamic_reconfiguration != false {
                    my_size += 1 + 1;
                }
                for value in &self.hardware_paths {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.driver_mappings {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.platform_profiles {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.adaptation_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.dynamic_reconfiguration != false {
                    os.write_bool(3, self.dynamic_reconfiguration)?;
                }
                for v in &self.hardware_paths {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.driver_mappings {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PlatformAdaptation {
                PlatformAdaptation::new()
            }

            fn clear(&mut self) {
                self.platform_profiles.clear();
                self.adaptation_rules.clear();
                self.dynamic_reconfiguration = false;
                self.hardware_paths.clear();
                self.driver_mappings.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PlatformAdaptation {
                static instance: ::protobuf::rt::Lazy<PlatformAdaptation> = ::protobuf::rt::Lazy::new();
                instance.get(PlatformAdaptation::new)
            }
        }

        impl ::protobuf::MessageFull for PlatformAdaptation {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PlatformAdaptation {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PlatformAdaptation {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct OptimizationPipeline {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.optimization_passes)
            pub optimization_passes: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.compiler_flags)
            pub compiler_flags: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.profile_guided)
            pub profile_guided: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.target_specific)
            pub target_specific: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.tuning_params)
            pub tuning_params: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a OptimizationPipeline {
            fn default() -> &'a OptimizationPipeline {
                <OptimizationPipeline as ::protobuf::Message>::default_instance()
            }
        }

        impl OptimizationPipeline {
            pub fn new() -> OptimizationPipeline {
                ::std::default::Default::default()
            }

            // repeated string optimization_passes = 1;

            pub fn optimization_passes(&self) -> &[::std::string::String] {
                &self.optimization_passes
            }

            pub fn clear_optimization_passes(&mut self) {
                self.optimization_passes.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_passes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimization_passes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_passes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimization_passes
            }

            // Take field
            pub fn take_optimization_passes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimization_passes, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.CompilerFlagsEntry compiler_flags = 2;

            pub fn compiler_flags(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.compiler_flags
            }

            pub fn clear_compiler_flags(&mut self) {
                self.compiler_flags.clear();
            }

            // Param is passed by value, moved
            pub fn set_compiler_flags(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.compiler_flags = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compiler_flags(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.compiler_flags
            }

            // Take field
            pub fn take_compiler_flags(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.compiler_flags, ::std::collections::HashMap::new())
            }

            // bool profile_guided = 3;

            pub fn profile_guided(&self) -> bool {
                self.profile_guided
            }

            pub fn clear_profile_guided(&mut self) {
                self.profile_guided = false;
            }

            // Param is passed by value, moved
            pub fn set_profile_guided(&mut self, v: bool) {
                self.profile_guided = v;
            }

            // repeated string target_specific = 4;

            pub fn target_specific(&self) -> &[::std::string::String] {
                &self.target_specific
            }

            pub fn clear_target_specific(&mut self) {
                self.target_specific.clear();
            }

            // Param is passed by value, moved
            pub fn set_target_specific(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.target_specific = v;
            }

            // Mutable pointer to the field.
            pub fn mut_target_specific(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.target_specific
            }

            // Take field
            pub fn take_target_specific(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.target_specific, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline.TuningParamsEntry tuning_params = 5;

            pub fn tuning_params(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.tuning_params
            }

            pub fn clear_tuning_params(&mut self) {
                self.tuning_params.clear();
            }

            // Param is passed by value, moved
            pub fn set_tuning_params(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.tuning_params = v;
            }

            // Mutable pointer to the field.
            pub fn mut_tuning_params(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.tuning_params
            }

            // Take field
            pub fn take_tuning_params(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.tuning_params, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimization_passes",
                    |m: &OptimizationPipeline| { &m.optimization_passes },
                    |m: &mut OptimizationPipeline| { &mut m.optimization_passes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "compiler_flags",
                    |m: &OptimizationPipeline| { &m.compiler_flags },
                    |m: &mut OptimizationPipeline| { &mut m.compiler_flags },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "profile_guided",
                    |m: &OptimizationPipeline| { &m.profile_guided },
                    |m: &mut OptimizationPipeline| { &mut m.profile_guided },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "target_specific",
                    |m: &OptimizationPipeline| { &m.target_specific },
                    |m: &mut OptimizationPipeline| { &mut m.target_specific },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "tuning_params",
                    |m: &OptimizationPipeline| { &m.tuning_params },
                    |m: &mut OptimizationPipeline| { &mut m.tuning_params },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OptimizationPipeline>(
                    "IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for OptimizationPipeline {
            const NAME: &'static str = "OptimizationPipeline";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.optimization_passes.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.compiler_flags.insert(key, value);
                        },
                        24 => {
                            self.profile_guided = is.read_bool()?;
                        },
                        34 => {
                            self.target_specific.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.tuning_params.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.optimization_passes {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.compiler_flags {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.profile_guided != false {
                    my_size += 1 + 1;
                }
                for value in &self.target_specific {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.tuning_params {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.optimization_passes {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.compiler_flags {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.profile_guided != false {
                    os.write_bool(3, self.profile_guided)?;
                }
                for v in &self.target_specific {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.tuning_params {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> OptimizationPipeline {
                OptimizationPipeline::new()
            }

            fn clear(&mut self) {
                self.optimization_passes.clear();
                self.compiler_flags.clear();
                self.profile_guided = false;
                self.target_specific.clear();
                self.tuning_params.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static OptimizationPipeline {
                static instance: ::protobuf::rt::Lazy<OptimizationPipeline> = ::protobuf::rt::Lazy::new();
                instance.get(OptimizationPipeline::new)
            }
        }

        impl ::protobuf::MessageFull for OptimizationPipeline {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.AutoIntegration.OptimizationPipeline").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for OptimizationPipeline {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for OptimizationPipeline {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RuntimeAdaptation {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.runtime_hooks)
            pub runtime_hooks: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.feature_detection)
            pub feature_detection: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.hot_reload)
            pub hot_reload: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.fallback_paths)
            pub fallback_paths: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.runtime_config)
            pub runtime_config: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RuntimeAdaptation {
            fn default() -> &'a RuntimeAdaptation {
                <RuntimeAdaptation as ::protobuf::Message>::default_instance()
            }
        }

        impl RuntimeAdaptation {
            pub fn new() -> RuntimeAdaptation {
                ::std::default::Default::default()
            }

            // repeated string runtime_hooks = 1;

            pub fn runtime_hooks(&self) -> &[::std::string::String] {
                &self.runtime_hooks
            }

            pub fn clear_runtime_hooks(&mut self) {
                self.runtime_hooks.clear();
            }

            // Param is passed by value, moved
            pub fn set_runtime_hooks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.runtime_hooks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_runtime_hooks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.runtime_hooks
            }

            // Take field
            pub fn take_runtime_hooks(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.runtime_hooks, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.FeatureDetectionEntry feature_detection = 2;

            pub fn feature_detection(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.feature_detection
            }

            pub fn clear_feature_detection(&mut self) {
                self.feature_detection.clear();
            }

            // Param is passed by value, moved
            pub fn set_feature_detection(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.feature_detection = v;
            }

            // Mutable pointer to the field.
            pub fn mut_feature_detection(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.feature_detection
            }

            // Take field
            pub fn take_feature_detection(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.feature_detection, ::std::collections::HashMap::new())
            }

            // bool hot_reload = 3;

            pub fn hot_reload(&self) -> bool {
                self.hot_reload
            }

            pub fn clear_hot_reload(&mut self) {
                self.hot_reload = false;
            }

            // Param is passed by value, moved
            pub fn set_hot_reload(&mut self, v: bool) {
                self.hot_reload = v;
            }

            // repeated string fallback_paths = 4;

            pub fn fallback_paths(&self) -> &[::std::string::String] {
                &self.fallback_paths
            }

            pub fn clear_fallback_paths(&mut self) {
                self.fallback_paths.clear();
            }

            // Param is passed by value, moved
            pub fn set_fallback_paths(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.fallback_paths = v;
            }

            // Mutable pointer to the field.
            pub fn mut_fallback_paths(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.fallback_paths
            }

            // Take field
            pub fn take_fallback_paths(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.fallback_paths, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.RuntimeConfigEntry runtime_config = 5;

            pub fn runtime_config(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.runtime_config
            }

            pub fn clear_runtime_config(&mut self) {
                self.runtime_config.clear();
            }

            // Param is passed by value, moved
            pub fn set_runtime_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.runtime_config = v;
            }

            // Mutable pointer to the field.
            pub fn mut_runtime_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.runtime_config
            }

            // Take field
            pub fn take_runtime_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.runtime_config, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "runtime_hooks",
                    |m: &RuntimeAdaptation| { &m.runtime_hooks },
                    |m: &mut RuntimeAdaptation| { &mut m.runtime_hooks },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "feature_detection",
                    |m: &RuntimeAdaptation| { &m.feature_detection },
                    |m: &mut RuntimeAdaptation| { &mut m.feature_detection },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "hot_reload",
                    |m: &RuntimeAdaptation| { &m.hot_reload },
                    |m: &mut RuntimeAdaptation| { &mut m.hot_reload },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "fallback_paths",
                    |m: &RuntimeAdaptation| { &m.fallback_paths },
                    |m: &mut RuntimeAdaptation| { &mut m.fallback_paths },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "runtime_config",
                    |m: &RuntimeAdaptation| { &m.runtime_config },
                    |m: &mut RuntimeAdaptation| { &mut m.runtime_config },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RuntimeAdaptation>(
                    "IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RuntimeAdaptation {
            const NAME: &'static str = "RuntimeAdaptation";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.runtime_hooks.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.feature_detection.insert(key, value);
                        },
                        24 => {
                            self.hot_reload = is.read_bool()?;
                        },
                        34 => {
                            self.fallback_paths.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.runtime_config.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.runtime_hooks {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.feature_detection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.hot_reload != false {
                    my_size += 1 + 1;
                }
                for value in &self.fallback_paths {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.runtime_config {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.runtime_hooks {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.feature_detection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.hot_reload != false {
                    os.write_bool(3, self.hot_reload)?;
                }
                for v in &self.fallback_paths {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.runtime_config {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RuntimeAdaptation {
                RuntimeAdaptation::new()
            }

            fn clear(&mut self) {
                self.runtime_hooks.clear();
                self.feature_detection.clear();
                self.hot_reload = false;
                self.fallback_paths.clear();
                self.runtime_config.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RuntimeAdaptation {
                static instance: ::protobuf::rt::Lazy<RuntimeAdaptation> = ::protobuf::rt::Lazy::new();
                instance.get(RuntimeAdaptation::new)
            }
        }

        impl ::protobuf::MessageFull for RuntimeAdaptation {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RuntimeAdaptation {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RuntimeAdaptation {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PerformanceMonitor {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PerformanceMonitor {
        fn default() -> &'a PerformanceMonitor {
            <PerformanceMonitor as ::protobuf::Message>::default_instance()
        }
    }

    impl PerformanceMonitor {
        pub fn new() -> PerformanceMonitor {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceMonitor>(
                "IntelligentHardwareSystem.PerformanceMonitor",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PerformanceMonitor {
        const NAME: &'static str = "PerformanceMonitor";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PerformanceMonitor {
            PerformanceMonitor::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PerformanceMonitor {
            static instance: PerformanceMonitor = PerformanceMonitor {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PerformanceMonitor {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.PerformanceMonitor").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PerformanceMonitor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PerformanceMonitor {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `PerformanceMonitor`
    pub mod performance_monitor {
        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct HardwareMetrics {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.performance_counters)
            pub performance_counters: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.utilization_metrics)
            pub utilization_metrics: ::std::collections::HashMap<::std::string::String, f32>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.power_monitoring)
            pub power_monitoring: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.thermal_metrics)
            pub thermal_metrics: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.bottleneck_detection)
            pub bottleneck_detection: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a HardwareMetrics {
            fn default() -> &'a HardwareMetrics {
                <HardwareMetrics as ::protobuf::Message>::default_instance()
            }
        }

        impl HardwareMetrics {
            pub fn new() -> HardwareMetrics {
                ::std::default::Default::default()
            }

            // repeated string performance_counters = 1;

            pub fn performance_counters(&self) -> &[::std::string::String] {
                &self.performance_counters
            }

            pub fn clear_performance_counters(&mut self) {
                self.performance_counters.clear();
            }

            // Param is passed by value, moved
            pub fn set_performance_counters(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.performance_counters = v;
            }

            // Mutable pointer to the field.
            pub fn mut_performance_counters(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.performance_counters
            }

            // Take field
            pub fn take_performance_counters(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.performance_counters, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.UtilizationMetricsEntry utilization_metrics = 2;

            pub fn utilization_metrics(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
                &self.utilization_metrics
            }

            pub fn clear_utilization_metrics(&mut self) {
                self.utilization_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_utilization_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
                self.utilization_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_utilization_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
                &mut self.utilization_metrics
            }

            // Take field
            pub fn take_utilization_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
                ::std::mem::replace(&mut self.utilization_metrics, ::std::collections::HashMap::new())
            }

            // bool power_monitoring = 3;

            pub fn power_monitoring(&self) -> bool {
                self.power_monitoring
            }

            pub fn clear_power_monitoring(&mut self) {
                self.power_monitoring = false;
            }

            // Param is passed by value, moved
            pub fn set_power_monitoring(&mut self, v: bool) {
                self.power_monitoring = v;
            }

            // repeated string thermal_metrics = 4;

            pub fn thermal_metrics(&self) -> &[::std::string::String] {
                &self.thermal_metrics
            }

            pub fn clear_thermal_metrics(&mut self) {
                self.thermal_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_thermal_metrics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.thermal_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_thermal_metrics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.thermal_metrics
            }

            // Take field
            pub fn take_thermal_metrics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.thermal_metrics, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.BottleneckDetectionEntry bottleneck_detection = 5;

            pub fn bottleneck_detection(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.bottleneck_detection
            }

            pub fn clear_bottleneck_detection(&mut self) {
                self.bottleneck_detection.clear();
            }

            // Param is passed by value, moved
            pub fn set_bottleneck_detection(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.bottleneck_detection = v;
            }

            // Mutable pointer to the field.
            pub fn mut_bottleneck_detection(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.bottleneck_detection
            }

            // Take field
            pub fn take_bottleneck_detection(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.bottleneck_detection, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "performance_counters",
                    |m: &HardwareMetrics| { &m.performance_counters },
                    |m: &mut HardwareMetrics| { &mut m.performance_counters },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "utilization_metrics",
                    |m: &HardwareMetrics| { &m.utilization_metrics },
                    |m: &mut HardwareMetrics| { &mut m.utilization_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "power_monitoring",
                    |m: &HardwareMetrics| { &m.power_monitoring },
                    |m: &mut HardwareMetrics| { &mut m.power_monitoring },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "thermal_metrics",
                    |m: &HardwareMetrics| { &m.thermal_metrics },
                    |m: &mut HardwareMetrics| { &mut m.thermal_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "bottleneck_detection",
                    |m: &HardwareMetrics| { &m.bottleneck_detection },
                    |m: &mut HardwareMetrics| { &mut m.bottleneck_detection },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HardwareMetrics>(
                    "IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for HardwareMetrics {
            const NAME: &'static str = "HardwareMetrics";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.performance_counters.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    21 => value = is.read_float()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.utilization_metrics.insert(key, value);
                        },
                        24 => {
                            self.power_monitoring = is.read_bool()?;
                        },
                        34 => {
                            self.thermal_metrics.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.bottleneck_detection.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.performance_counters {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.utilization_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.power_monitoring != false {
                    my_size += 1 + 1;
                }
                for value in &self.thermal_metrics {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.bottleneck_detection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.performance_counters {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.utilization_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_float(2, *v)?;
                };
                if self.power_monitoring != false {
                    os.write_bool(3, self.power_monitoring)?;
                }
                for v in &self.thermal_metrics {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.bottleneck_detection {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> HardwareMetrics {
                HardwareMetrics::new()
            }

            fn clear(&mut self) {
                self.performance_counters.clear();
                self.utilization_metrics.clear();
                self.power_monitoring = false;
                self.thermal_metrics.clear();
                self.bottleneck_detection.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static HardwareMetrics {
                static instance: ::protobuf::rt::Lazy<HardwareMetrics> = ::protobuf::rt::Lazy::new();
                instance.get(HardwareMetrics::new)
            }
        }

        impl ::protobuf::MessageFull for HardwareMetrics {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for HardwareMetrics {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for HardwareMetrics {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct WorkloadAnalysis {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.workload_patterns)
            pub workload_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.resource_usage)
            pub resource_usage: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.predictive_analysis)
            pub predictive_analysis: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.optimization_hints)
            pub optimization_hints: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.performance_models)
            pub performance_models: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a WorkloadAnalysis {
            fn default() -> &'a WorkloadAnalysis {
                <WorkloadAnalysis as ::protobuf::Message>::default_instance()
            }
        }

        impl WorkloadAnalysis {
            pub fn new() -> WorkloadAnalysis {
                ::std::default::Default::default()
            }

            // repeated string workload_patterns = 1;

            pub fn workload_patterns(&self) -> &[::std::string::String] {
                &self.workload_patterns
            }

            pub fn clear_workload_patterns(&mut self) {
                self.workload_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_workload_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.workload_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_workload_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.workload_patterns
            }

            // Take field
            pub fn take_workload_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.workload_patterns, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.ResourceUsageEntry resource_usage = 2;

            pub fn resource_usage(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.resource_usage
            }

            pub fn clear_resource_usage(&mut self) {
                self.resource_usage.clear();
            }

            // Param is passed by value, moved
            pub fn set_resource_usage(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.resource_usage = v;
            }

            // Mutable pointer to the field.
            pub fn mut_resource_usage(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.resource_usage
            }

            // Take field
            pub fn take_resource_usage(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.resource_usage, ::std::collections::HashMap::new())
            }

            // bool predictive_analysis = 3;

            pub fn predictive_analysis(&self) -> bool {
                self.predictive_analysis
            }

            pub fn clear_predictive_analysis(&mut self) {
                self.predictive_analysis = false;
            }

            // Param is passed by value, moved
            pub fn set_predictive_analysis(&mut self, v: bool) {
                self.predictive_analysis = v;
            }

            // repeated string optimization_hints = 4;

            pub fn optimization_hints(&self) -> &[::std::string::String] {
                &self.optimization_hints
            }

            pub fn clear_optimization_hints(&mut self) {
                self.optimization_hints.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimization_hints(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimization_hints = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimization_hints(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimization_hints
            }

            // Take field
            pub fn take_optimization_hints(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimization_hints, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis.PerformanceModelsEntry performance_models = 5;

            pub fn performance_models(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.performance_models
            }

            pub fn clear_performance_models(&mut self) {
                self.performance_models.clear();
            }

            // Param is passed by value, moved
            pub fn set_performance_models(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.performance_models = v;
            }

            // Mutable pointer to the field.
            pub fn mut_performance_models(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.performance_models
            }

            // Take field
            pub fn take_performance_models(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.performance_models, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "workload_patterns",
                    |m: &WorkloadAnalysis| { &m.workload_patterns },
                    |m: &mut WorkloadAnalysis| { &mut m.workload_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "resource_usage",
                    |m: &WorkloadAnalysis| { &m.resource_usage },
                    |m: &mut WorkloadAnalysis| { &mut m.resource_usage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "predictive_analysis",
                    |m: &WorkloadAnalysis| { &m.predictive_analysis },
                    |m: &mut WorkloadAnalysis| { &mut m.predictive_analysis },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimization_hints",
                    |m: &WorkloadAnalysis| { &m.optimization_hints },
                    |m: &mut WorkloadAnalysis| { &mut m.optimization_hints },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "performance_models",
                    |m: &WorkloadAnalysis| { &m.performance_models },
                    |m: &mut WorkloadAnalysis| { &mut m.performance_models },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkloadAnalysis>(
                    "IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for WorkloadAnalysis {
            const NAME: &'static str = "WorkloadAnalysis";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.workload_patterns.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.resource_usage.insert(key, value);
                        },
                        24 => {
                            self.predictive_analysis = is.read_bool()?;
                        },
                        34 => {
                            self.optimization_hints.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.performance_models.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.workload_patterns {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.resource_usage {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.predictive_analysis != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimization_hints {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.performance_models {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.workload_patterns {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.resource_usage {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.predictive_analysis != false {
                    os.write_bool(3, self.predictive_analysis)?;
                }
                for v in &self.optimization_hints {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.performance_models {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> WorkloadAnalysis {
                WorkloadAnalysis::new()
            }

            fn clear(&mut self) {
                self.workload_patterns.clear();
                self.resource_usage.clear();
                self.predictive_analysis = false;
                self.optimization_hints.clear();
                self.performance_models.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static WorkloadAnalysis {
                static instance: ::protobuf::rt::Lazy<WorkloadAnalysis> = ::protobuf::rt::Lazy::new();
                instance.get(WorkloadAnalysis::new)
            }
        }

        impl ::protobuf::MessageFull for WorkloadAnalysis {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.PerformanceMonitor.WorkloadAnalysis").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for WorkloadAnalysis {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for WorkloadAnalysis {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AdaptiveTuning {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.tuning_parameters)
            pub tuning_parameters: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.feedback_metrics)
            pub feedback_metrics: ::std::collections::HashMap<::std::string::String, f32>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.auto_tuning)
            pub auto_tuning: bool,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.adaptation_rules)
            pub adaptation_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.tuning_policies)
            pub tuning_policies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AdaptiveTuning {
            fn default() -> &'a AdaptiveTuning {
                <AdaptiveTuning as ::protobuf::Message>::default_instance()
            }
        }

        impl AdaptiveTuning {
            pub fn new() -> AdaptiveTuning {
                ::std::default::Default::default()
            }

            // repeated string tuning_parameters = 1;

            pub fn tuning_parameters(&self) -> &[::std::string::String] {
                &self.tuning_parameters
            }

            pub fn clear_tuning_parameters(&mut self) {
                self.tuning_parameters.clear();
            }

            // Param is passed by value, moved
            pub fn set_tuning_parameters(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.tuning_parameters = v;
            }

            // Mutable pointer to the field.
            pub fn mut_tuning_parameters(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.tuning_parameters
            }

            // Take field
            pub fn take_tuning_parameters(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.tuning_parameters, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.FeedbackMetricsEntry feedback_metrics = 2;

            pub fn feedback_metrics(&self) -> &::std::collections::HashMap<::std::string::String, f32> {
                &self.feedback_metrics
            }

            pub fn clear_feedback_metrics(&mut self) {
                self.feedback_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_feedback_metrics(&mut self, v: ::std::collections::HashMap<::std::string::String, f32>) {
                self.feedback_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_feedback_metrics(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f32> {
                &mut self.feedback_metrics
            }

            // Take field
            pub fn take_feedback_metrics(&mut self) -> ::std::collections::HashMap<::std::string::String, f32> {
                ::std::mem::replace(&mut self.feedback_metrics, ::std::collections::HashMap::new())
            }

            // bool auto_tuning = 3;

            pub fn auto_tuning(&self) -> bool {
                self.auto_tuning
            }

            pub fn clear_auto_tuning(&mut self) {
                self.auto_tuning = false;
            }

            // Param is passed by value, moved
            pub fn set_auto_tuning(&mut self, v: bool) {
                self.auto_tuning = v;
            }

            // repeated string adaptation_rules = 4;

            pub fn adaptation_rules(&self) -> &[::std::string::String] {
                &self.adaptation_rules
            }

            pub fn clear_adaptation_rules(&mut self) {
                self.adaptation_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_adaptation_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.adaptation_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_adaptation_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.adaptation_rules
            }

            // Take field
            pub fn take_adaptation_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.adaptation_rules, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning.TuningPoliciesEntry tuning_policies = 5;

            pub fn tuning_policies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.tuning_policies
            }

            pub fn clear_tuning_policies(&mut self) {
                self.tuning_policies.clear();
            }

            // Param is passed by value, moved
            pub fn set_tuning_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.tuning_policies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_tuning_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.tuning_policies
            }

            // Take field
            pub fn take_tuning_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.tuning_policies, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "tuning_parameters",
                    |m: &AdaptiveTuning| { &m.tuning_parameters },
                    |m: &mut AdaptiveTuning| { &mut m.tuning_parameters },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "feedback_metrics",
                    |m: &AdaptiveTuning| { &m.feedback_metrics },
                    |m: &mut AdaptiveTuning| { &mut m.feedback_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "auto_tuning",
                    |m: &AdaptiveTuning| { &m.auto_tuning },
                    |m: &mut AdaptiveTuning| { &mut m.auto_tuning },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "adaptation_rules",
                    |m: &AdaptiveTuning| { &m.adaptation_rules },
                    |m: &mut AdaptiveTuning| { &mut m.adaptation_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "tuning_policies",
                    |m: &AdaptiveTuning| { &m.tuning_policies },
                    |m: &mut AdaptiveTuning| { &mut m.tuning_policies },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AdaptiveTuning>(
                    "IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AdaptiveTuning {
            const NAME: &'static str = "AdaptiveTuning";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.tuning_parameters.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    21 => value = is.read_float()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.feedback_metrics.insert(key, value);
                        },
                        24 => {
                            self.auto_tuning = is.read_bool()?;
                        },
                        34 => {
                            self.adaptation_rules.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.tuning_policies.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.tuning_parameters {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.feedback_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.auto_tuning != false {
                    my_size += 1 + 1;
                }
                for value in &self.adaptation_rules {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.tuning_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.tuning_parameters {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.feedback_metrics {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += 1 + 4;
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_float(2, *v)?;
                };
                if self.auto_tuning != false {
                    os.write_bool(3, self.auto_tuning)?;
                }
                for v in &self.adaptation_rules {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.tuning_policies {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AdaptiveTuning {
                AdaptiveTuning::new()
            }

            fn clear(&mut self) {
                self.tuning_parameters.clear();
                self.feedback_metrics.clear();
                self.auto_tuning = false;
                self.adaptation_rules.clear();
                self.tuning_policies.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AdaptiveTuning {
                static instance: ::protobuf::rt::Lazy<AdaptiveTuning> = ::protobuf::rt::Lazy::new();
                instance.get(AdaptiveTuning::new)
            }
        }

        impl ::protobuf::MessageFull for AdaptiveTuning {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("IntelligentHardwareSystem.PerformanceMonitor.AdaptiveTuning").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AdaptiveTuning {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AdaptiveTuning {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct QualityRatingSystem {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.language_prompts)
    pub language_prompts: ::protobuf::MessageField<LanguageQualityPrompts>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a QualityRatingSystem {
    fn default() -> &'a QualityRatingSystem {
        <QualityRatingSystem as ::protobuf::Message>::default_instance()
    }
}

impl QualityRatingSystem {
    pub fn new() -> QualityRatingSystem {
        ::std::default::Default::default()
    }

    // .kymera_mappings.LanguageQualityPrompts language_prompts = 8;

    pub fn language_prompts(&self) -> &LanguageQualityPrompts {
        self.language_prompts.as_ref().unwrap_or_else(|| <LanguageQualityPrompts as ::protobuf::Message>::default_instance())
    }

    pub fn clear_language_prompts(&mut self) {
        self.language_prompts.clear();
    }

    pub fn has_language_prompts(&self) -> bool {
        self.language_prompts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_prompts(&mut self, v: LanguageQualityPrompts) {
        self.language_prompts = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_prompts(&mut self) -> &mut LanguageQualityPrompts {
        self.language_prompts.mut_or_insert_default()
    }

    // Take field
    pub fn take_language_prompts(&mut self) -> LanguageQualityPrompts {
        self.language_prompts.take().unwrap_or_else(|| LanguageQualityPrompts::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LanguageQualityPrompts>(
            "language_prompts",
            |m: &QualityRatingSystem| { &m.language_prompts },
            |m: &mut QualityRatingSystem| { &mut m.language_prompts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QualityRatingSystem>(
            "QualityRatingSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for QualityRatingSystem {
    const NAME: &'static str = "QualityRatingSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.language_prompts)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language_prompts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.language_prompts.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> QualityRatingSystem {
        QualityRatingSystem::new()
    }

    fn clear(&mut self) {
        self.language_prompts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static QualityRatingSystem {
        static instance: QualityRatingSystem = QualityRatingSystem {
            language_prompts: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for QualityRatingSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("QualityRatingSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for QualityRatingSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QualityRatingSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `QualityRatingSystem`
pub mod quality_rating_system {
    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.QualityMetrics)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QualityMetrics {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityMetrics.quality_score)
        pub quality_score: f64,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityMetrics.component_scores)
        pub component_scores: ::std::collections::HashMap<::std::string::String, f64>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityMetrics.improvement_areas)
        pub improvement_areas: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityMetrics.meets_standards)
        pub meets_standards: bool,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityMetrics.quality_notes)
        pub quality_notes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.QualityMetrics.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QualityMetrics {
        fn default() -> &'a QualityMetrics {
            <QualityMetrics as ::protobuf::Message>::default_instance()
        }
    }

    impl QualityMetrics {
        pub fn new() -> QualityMetrics {
            ::std::default::Default::default()
        }

        // double quality_score = 1;

        pub fn quality_score(&self) -> f64 {
            self.quality_score
        }

        pub fn clear_quality_score(&mut self) {
            self.quality_score = 0.;
        }

        // Param is passed by value, moved
        pub fn set_quality_score(&mut self, v: f64) {
            self.quality_score = v;
        }

        // repeated .kymera_mappings.QualityRatingSystem.QualityMetrics.ComponentScoresEntry component_scores = 2;

        pub fn component_scores(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
            &self.component_scores
        }

        pub fn clear_component_scores(&mut self) {
            self.component_scores.clear();
        }

        // Param is passed by value, moved
        pub fn set_component_scores(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
            self.component_scores = v;
        }

        // Mutable pointer to the field.
        pub fn mut_component_scores(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
            &mut self.component_scores
        }

        // Take field
        pub fn take_component_scores(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
            ::std::mem::replace(&mut self.component_scores, ::std::collections::HashMap::new())
        }

        // repeated string improvement_areas = 3;

        pub fn improvement_areas(&self) -> &[::std::string::String] {
            &self.improvement_areas
        }

        pub fn clear_improvement_areas(&mut self) {
            self.improvement_areas.clear();
        }

        // Param is passed by value, moved
        pub fn set_improvement_areas(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.improvement_areas = v;
        }

        // Mutable pointer to the field.
        pub fn mut_improvement_areas(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.improvement_areas
        }

        // Take field
        pub fn take_improvement_areas(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.improvement_areas, ::std::vec::Vec::new())
        }

        // bool meets_standards = 4;

        pub fn meets_standards(&self) -> bool {
            self.meets_standards
        }

        pub fn clear_meets_standards(&mut self) {
            self.meets_standards = false;
        }

        // Param is passed by value, moved
        pub fn set_meets_standards(&mut self, v: bool) {
            self.meets_standards = v;
        }

        // repeated .kymera_mappings.QualityRatingSystem.QualityMetrics.QualityNotesEntry quality_notes = 5;

        pub fn quality_notes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.quality_notes
        }

        pub fn clear_quality_notes(&mut self) {
            self.quality_notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_quality_notes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.quality_notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_quality_notes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.quality_notes
        }

        // Take field
        pub fn take_quality_notes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.quality_notes, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "quality_score",
                |m: &QualityMetrics| { &m.quality_score },
                |m: &mut QualityMetrics| { &mut m.quality_score },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "component_scores",
                |m: &QualityMetrics| { &m.component_scores },
                |m: &mut QualityMetrics| { &mut m.component_scores },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "improvement_areas",
                |m: &QualityMetrics| { &m.improvement_areas },
                |m: &mut QualityMetrics| { &mut m.improvement_areas },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "meets_standards",
                |m: &QualityMetrics| { &m.meets_standards },
                |m: &mut QualityMetrics| { &mut m.meets_standards },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "quality_notes",
                |m: &QualityMetrics| { &m.quality_notes },
                |m: &mut QualityMetrics| { &mut m.quality_notes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QualityMetrics>(
                "QualityRatingSystem.QualityMetrics",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QualityMetrics {
        const NAME: &'static str = "QualityMetrics";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.quality_score = is.read_double()?;
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                17 => value = is.read_double()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.component_scores.insert(key, value);
                    },
                    26 => {
                        self.improvement_areas.push(is.read_string()?);
                    },
                    32 => {
                        self.meets_standards = is.read_bool()?;
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.quality_notes.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.quality_score != 0. {
                my_size += 1 + 8;
            }
            for (k, v) in &self.component_scores {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.improvement_areas {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            if self.meets_standards != false {
                my_size += 1 + 1;
            }
            for (k, v) in &self.quality_notes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.quality_score != 0. {
                os.write_double(1, self.quality_score)?;
            }
            for (k, v) in &self.component_scores {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_double(2, *v)?;
            };
            for v in &self.improvement_areas {
                os.write_string(3, &v)?;
            };
            if self.meets_standards != false {
                os.write_bool(4, self.meets_standards)?;
            }
            for (k, v) in &self.quality_notes {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QualityMetrics {
            QualityMetrics::new()
        }

        fn clear(&mut self) {
            self.quality_score = 0.;
            self.component_scores.clear();
            self.improvement_areas.clear();
            self.meets_standards = false;
            self.quality_notes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QualityMetrics {
            static instance: ::protobuf::rt::Lazy<QualityMetrics> = ::protobuf::rt::Lazy::new();
            instance.get(QualityMetrics::new)
        }
    }

    impl ::protobuf::MessageFull for QualityMetrics {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.QualityMetrics").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QualityMetrics {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QualityMetrics {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.ModularityChecks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ModularityChecks {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ModularityChecks.unused_imports_removed)
        pub unused_imports_removed: bool,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ModularityChecks.dependency_graph)
        pub dependency_graph: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ModularityChecks.interface_specs)
        pub interface_specs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ModularityChecks.circular_deps_resolved)
        pub circular_deps_resolved: bool,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ModularityChecks.modular_boundaries)
        pub modular_boundaries: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.ModularityChecks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ModularityChecks {
        fn default() -> &'a ModularityChecks {
            <ModularityChecks as ::protobuf::Message>::default_instance()
        }
    }

    impl ModularityChecks {
        pub fn new() -> ModularityChecks {
            ::std::default::Default::default()
        }

        // bool unused_imports_removed = 1;

        pub fn unused_imports_removed(&self) -> bool {
            self.unused_imports_removed
        }

        pub fn clear_unused_imports_removed(&mut self) {
            self.unused_imports_removed = false;
        }

        // Param is passed by value, moved
        pub fn set_unused_imports_removed(&mut self, v: bool) {
            self.unused_imports_removed = v;
        }

        // repeated string dependency_graph = 2;

        pub fn dependency_graph(&self) -> &[::std::string::String] {
            &self.dependency_graph
        }

        pub fn clear_dependency_graph(&mut self) {
            self.dependency_graph.clear();
        }

        // Param is passed by value, moved
        pub fn set_dependency_graph(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.dependency_graph = v;
        }

        // Mutable pointer to the field.
        pub fn mut_dependency_graph(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.dependency_graph
        }

        // Take field
        pub fn take_dependency_graph(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.dependency_graph, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.QualityRatingSystem.ModularityChecks.InterfaceSpecsEntry interface_specs = 3;

        pub fn interface_specs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.interface_specs
        }

        pub fn clear_interface_specs(&mut self) {
            self.interface_specs.clear();
        }

        // Param is passed by value, moved
        pub fn set_interface_specs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.interface_specs = v;
        }

        // Mutable pointer to the field.
        pub fn mut_interface_specs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.interface_specs
        }

        // Take field
        pub fn take_interface_specs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.interface_specs, ::std::collections::HashMap::new())
        }

        // bool circular_deps_resolved = 4;

        pub fn circular_deps_resolved(&self) -> bool {
            self.circular_deps_resolved
        }

        pub fn clear_circular_deps_resolved(&mut self) {
            self.circular_deps_resolved = false;
        }

        // Param is passed by value, moved
        pub fn set_circular_deps_resolved(&mut self, v: bool) {
            self.circular_deps_resolved = v;
        }

        // repeated string modular_boundaries = 5;

        pub fn modular_boundaries(&self) -> &[::std::string::String] {
            &self.modular_boundaries
        }

        pub fn clear_modular_boundaries(&mut self) {
            self.modular_boundaries.clear();
        }

        // Param is passed by value, moved
        pub fn set_modular_boundaries(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.modular_boundaries = v;
        }

        // Mutable pointer to the field.
        pub fn mut_modular_boundaries(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.modular_boundaries
        }

        // Take field
        pub fn take_modular_boundaries(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.modular_boundaries, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "unused_imports_removed",
                |m: &ModularityChecks| { &m.unused_imports_removed },
                |m: &mut ModularityChecks| { &mut m.unused_imports_removed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dependency_graph",
                |m: &ModularityChecks| { &m.dependency_graph },
                |m: &mut ModularityChecks| { &mut m.dependency_graph },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "interface_specs",
                |m: &ModularityChecks| { &m.interface_specs },
                |m: &mut ModularityChecks| { &mut m.interface_specs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "circular_deps_resolved",
                |m: &ModularityChecks| { &m.circular_deps_resolved },
                |m: &mut ModularityChecks| { &mut m.circular_deps_resolved },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "modular_boundaries",
                |m: &ModularityChecks| { &m.modular_boundaries },
                |m: &mut ModularityChecks| { &mut m.modular_boundaries },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModularityChecks>(
                "QualityRatingSystem.ModularityChecks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ModularityChecks {
        const NAME: &'static str = "ModularityChecks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.unused_imports_removed = is.read_bool()?;
                    },
                    18 => {
                        self.dependency_graph.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.interface_specs.insert(key, value);
                    },
                    32 => {
                        self.circular_deps_resolved = is.read_bool()?;
                    },
                    42 => {
                        self.modular_boundaries.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.unused_imports_removed != false {
                my_size += 1 + 1;
            }
            for value in &self.dependency_graph {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.interface_specs {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.circular_deps_resolved != false {
                my_size += 1 + 1;
            }
            for value in &self.modular_boundaries {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.unused_imports_removed != false {
                os.write_bool(1, self.unused_imports_removed)?;
            }
            for v in &self.dependency_graph {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.interface_specs {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.circular_deps_resolved != false {
                os.write_bool(4, self.circular_deps_resolved)?;
            }
            for v in &self.modular_boundaries {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ModularityChecks {
            ModularityChecks::new()
        }

        fn clear(&mut self) {
            self.unused_imports_removed = false;
            self.dependency_graph.clear();
            self.interface_specs.clear();
            self.circular_deps_resolved = false;
            self.modular_boundaries.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ModularityChecks {
            static instance: ::protobuf::rt::Lazy<ModularityChecks> = ::protobuf::rt::Lazy::new();
            instance.get(ModularityChecks::new)
        }
    }

    impl ::protobuf::MessageFull for ModularityChecks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.ModularityChecks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ModularityChecks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ModularityChecks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.ErrorHandling)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ErrorHandling {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ErrorHandling.error_patterns)
        pub error_patterns: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ErrorHandling.recovery_strategies)
        pub recovery_strategies: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ErrorHandling.comprehensive_handling)
        pub comprehensive_handling: bool,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ErrorHandling.safety_checks)
        pub safety_checks: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ErrorHandling.error_documentation)
        pub error_documentation: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.ErrorHandling.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ErrorHandling {
        fn default() -> &'a ErrorHandling {
            <ErrorHandling as ::protobuf::Message>::default_instance()
        }
    }

    impl ErrorHandling {
        pub fn new() -> ErrorHandling {
            ::std::default::Default::default()
        }

        // repeated string error_patterns = 1;

        pub fn error_patterns(&self) -> &[::std::string::String] {
            &self.error_patterns
        }

        pub fn clear_error_patterns(&mut self) {
            self.error_patterns.clear();
        }

        // Param is passed by value, moved
        pub fn set_error_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.error_patterns = v;
        }

        // Mutable pointer to the field.
        pub fn mut_error_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.error_patterns
        }

        // Take field
        pub fn take_error_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.error_patterns, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.QualityRatingSystem.ErrorHandling.RecoveryStrategiesEntry recovery_strategies = 2;

        pub fn recovery_strategies(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.recovery_strategies
        }

        pub fn clear_recovery_strategies(&mut self) {
            self.recovery_strategies.clear();
        }

        // Param is passed by value, moved
        pub fn set_recovery_strategies(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.recovery_strategies = v;
        }

        // Mutable pointer to the field.
        pub fn mut_recovery_strategies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.recovery_strategies
        }

        // Take field
        pub fn take_recovery_strategies(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.recovery_strategies, ::std::collections::HashMap::new())
        }

        // bool comprehensive_handling = 3;

        pub fn comprehensive_handling(&self) -> bool {
            self.comprehensive_handling
        }

        pub fn clear_comprehensive_handling(&mut self) {
            self.comprehensive_handling = false;
        }

        // Param is passed by value, moved
        pub fn set_comprehensive_handling(&mut self, v: bool) {
            self.comprehensive_handling = v;
        }

        // repeated string safety_checks = 4;

        pub fn safety_checks(&self) -> &[::std::string::String] {
            &self.safety_checks
        }

        pub fn clear_safety_checks(&mut self) {
            self.safety_checks.clear();
        }

        // Param is passed by value, moved
        pub fn set_safety_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.safety_checks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_safety_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.safety_checks
        }

        // Take field
        pub fn take_safety_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.safety_checks, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.QualityRatingSystem.ErrorHandling.ErrorDocumentationEntry error_documentation = 5;

        pub fn error_documentation(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.error_documentation
        }

        pub fn clear_error_documentation(&mut self) {
            self.error_documentation.clear();
        }

        // Param is passed by value, moved
        pub fn set_error_documentation(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.error_documentation = v;
        }

        // Mutable pointer to the field.
        pub fn mut_error_documentation(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.error_documentation
        }

        // Take field
        pub fn take_error_documentation(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.error_documentation, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "error_patterns",
                |m: &ErrorHandling| { &m.error_patterns },
                |m: &mut ErrorHandling| { &mut m.error_patterns },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "recovery_strategies",
                |m: &ErrorHandling| { &m.recovery_strategies },
                |m: &mut ErrorHandling| { &mut m.recovery_strategies },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "comprehensive_handling",
                |m: &ErrorHandling| { &m.comprehensive_handling },
                |m: &mut ErrorHandling| { &mut m.comprehensive_handling },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "safety_checks",
                |m: &ErrorHandling| { &m.safety_checks },
                |m: &mut ErrorHandling| { &mut m.safety_checks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "error_documentation",
                |m: &ErrorHandling| { &m.error_documentation },
                |m: &mut ErrorHandling| { &mut m.error_documentation },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandling>(
                "QualityRatingSystem.ErrorHandling",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ErrorHandling {
        const NAME: &'static str = "ErrorHandling";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.error_patterns.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.recovery_strategies.insert(key, value);
                    },
                    24 => {
                        self.comprehensive_handling = is.read_bool()?;
                    },
                    34 => {
                        self.safety_checks.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.error_documentation.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.error_patterns {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.recovery_strategies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.comprehensive_handling != false {
                my_size += 1 + 1;
            }
            for value in &self.safety_checks {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.error_documentation {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.error_patterns {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.recovery_strategies {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.comprehensive_handling != false {
                os.write_bool(3, self.comprehensive_handling)?;
            }
            for v in &self.safety_checks {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.error_documentation {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ErrorHandling {
            ErrorHandling::new()
        }

        fn clear(&mut self) {
            self.error_patterns.clear();
            self.recovery_strategies.clear();
            self.comprehensive_handling = false;
            self.safety_checks.clear();
            self.error_documentation.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ErrorHandling {
            static instance: ::protobuf::rt::Lazy<ErrorHandling> = ::protobuf::rt::Lazy::new();
            instance.get(ErrorHandling::new)
        }
    }

    impl ::protobuf::MessageFull for ErrorHandling {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.ErrorHandling").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ErrorHandling {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorHandling {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.PerformanceChecks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PerformanceChecks {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.PerformanceChecks.hotspots)
        pub hotspots: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.PerformanceChecks.benchmarks)
        pub benchmarks: ::std::collections::HashMap<::std::string::String, f64>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.PerformanceChecks.optimized_critical)
        pub optimized_critical: bool,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.PerformanceChecks.optimization_notes)
        pub optimization_notes: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.PerformanceChecks.perf_requirements)
        pub perf_requirements: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.PerformanceChecks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PerformanceChecks {
        fn default() -> &'a PerformanceChecks {
            <PerformanceChecks as ::protobuf::Message>::default_instance()
        }
    }

    impl PerformanceChecks {
        pub fn new() -> PerformanceChecks {
            ::std::default::Default::default()
        }

        // repeated string hotspots = 1;

        pub fn hotspots(&self) -> &[::std::string::String] {
            &self.hotspots
        }

        pub fn clear_hotspots(&mut self) {
            self.hotspots.clear();
        }

        // Param is passed by value, moved
        pub fn set_hotspots(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.hotspots = v;
        }

        // Mutable pointer to the field.
        pub fn mut_hotspots(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.hotspots
        }

        // Take field
        pub fn take_hotspots(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.hotspots, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.QualityRatingSystem.PerformanceChecks.BenchmarksEntry benchmarks = 2;

        pub fn benchmarks(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
            &self.benchmarks
        }

        pub fn clear_benchmarks(&mut self) {
            self.benchmarks.clear();
        }

        // Param is passed by value, moved
        pub fn set_benchmarks(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
            self.benchmarks = v;
        }

        // Mutable pointer to the field.
        pub fn mut_benchmarks(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
            &mut self.benchmarks
        }

        // Take field
        pub fn take_benchmarks(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
            ::std::mem::replace(&mut self.benchmarks, ::std::collections::HashMap::new())
        }

        // bool optimized_critical = 3;

        pub fn optimized_critical(&self) -> bool {
            self.optimized_critical
        }

        pub fn clear_optimized_critical(&mut self) {
            self.optimized_critical = false;
        }

        // Param is passed by value, moved
        pub fn set_optimized_critical(&mut self, v: bool) {
            self.optimized_critical = v;
        }

        // repeated string optimization_notes = 4;

        pub fn optimization_notes(&self) -> &[::std::string::String] {
            &self.optimization_notes
        }

        pub fn clear_optimization_notes(&mut self) {
            self.optimization_notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_optimization_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.optimization_notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_optimization_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.optimization_notes
        }

        // Take field
        pub fn take_optimization_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.optimization_notes, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.QualityRatingSystem.PerformanceChecks.PerfRequirementsEntry perf_requirements = 5;

        pub fn perf_requirements(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.perf_requirements
        }

        pub fn clear_perf_requirements(&mut self) {
            self.perf_requirements.clear();
        }

        // Param is passed by value, moved
        pub fn set_perf_requirements(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.perf_requirements = v;
        }

        // Mutable pointer to the field.
        pub fn mut_perf_requirements(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.perf_requirements
        }

        // Take field
        pub fn take_perf_requirements(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.perf_requirements, ::std::collections::HashMap::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "hotspots",
                |m: &PerformanceChecks| { &m.hotspots },
                |m: &mut PerformanceChecks| { &mut m.hotspots },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "benchmarks",
                |m: &PerformanceChecks| { &m.benchmarks },
                |m: &mut PerformanceChecks| { &mut m.benchmarks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "optimized_critical",
                |m: &PerformanceChecks| { &m.optimized_critical },
                |m: &mut PerformanceChecks| { &mut m.optimized_critical },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "optimization_notes",
                |m: &PerformanceChecks| { &m.optimization_notes },
                |m: &mut PerformanceChecks| { &mut m.optimization_notes },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "perf_requirements",
                |m: &PerformanceChecks| { &m.perf_requirements },
                |m: &mut PerformanceChecks| { &mut m.perf_requirements },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceChecks>(
                "QualityRatingSystem.PerformanceChecks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PerformanceChecks {
        const NAME: &'static str = "PerformanceChecks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.hotspots.push(is.read_string()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                17 => value = is.read_double()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.benchmarks.insert(key, value);
                    },
                    24 => {
                        self.optimized_critical = is.read_bool()?;
                    },
                    34 => {
                        self.optimization_notes.push(is.read_string()?);
                    },
                    42 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.perf_requirements.insert(key, value);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.hotspots {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            for (k, v) in &self.benchmarks {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.optimized_critical != false {
                my_size += 1 + 1;
            }
            for value in &self.optimization_notes {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            for (k, v) in &self.perf_requirements {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.hotspots {
                os.write_string(1, &v)?;
            };
            for (k, v) in &self.benchmarks {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += 1 + 8;
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_double(2, *v)?;
            };
            if self.optimized_critical != false {
                os.write_bool(3, self.optimized_critical)?;
            }
            for v in &self.optimization_notes {
                os.write_string(4, &v)?;
            };
            for (k, v) in &self.perf_requirements {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(42)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PerformanceChecks {
            PerformanceChecks::new()
        }

        fn clear(&mut self) {
            self.hotspots.clear();
            self.benchmarks.clear();
            self.optimized_critical = false;
            self.optimization_notes.clear();
            self.perf_requirements.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PerformanceChecks {
            static instance: ::protobuf::rt::Lazy<PerformanceChecks> = ::protobuf::rt::Lazy::new();
            instance.get(PerformanceChecks::new)
        }
    }

    impl ::protobuf::MessageFull for PerformanceChecks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.PerformanceChecks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PerformanceChecks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PerformanceChecks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.DocumentationChecks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DocumentationChecks {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.DocumentationChecks.public_documented)
        pub public_documented: bool,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.DocumentationChecks.doc_coverage)
        pub doc_coverage: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.DocumentationChecks.api_docs)
        pub api_docs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.DocumentationChecks.examples_provided)
        pub examples_provided: bool,
        // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.DocumentationChecks.doc_quality)
        pub doc_quality: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.DocumentationChecks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DocumentationChecks {
        fn default() -> &'a DocumentationChecks {
            <DocumentationChecks as ::protobuf::Message>::default_instance()
        }
    }

    impl DocumentationChecks {
        pub fn new() -> DocumentationChecks {
            ::std::default::Default::default()
        }

        // bool public_documented = 1;

        pub fn public_documented(&self) -> bool {
            self.public_documented
        }

        pub fn clear_public_documented(&mut self) {
            self.public_documented = false;
        }

        // Param is passed by value, moved
        pub fn set_public_documented(&mut self, v: bool) {
            self.public_documented = v;
        }

        // repeated string doc_coverage = 2;

        pub fn doc_coverage(&self) -> &[::std::string::String] {
            &self.doc_coverage
        }

        pub fn clear_doc_coverage(&mut self) {
            self.doc_coverage.clear();
        }

        // Param is passed by value, moved
        pub fn set_doc_coverage(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.doc_coverage = v;
        }

        // Mutable pointer to the field.
        pub fn mut_doc_coverage(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.doc_coverage
        }

        // Take field
        pub fn take_doc_coverage(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.doc_coverage, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.QualityRatingSystem.DocumentationChecks.ApiDocsEntry api_docs = 3;

        pub fn api_docs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.api_docs
        }

        pub fn clear_api_docs(&mut self) {
            self.api_docs.clear();
        }

        // Param is passed by value, moved
        pub fn set_api_docs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.api_docs = v;
        }

        // Mutable pointer to the field.
        pub fn mut_api_docs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.api_docs
        }

        // Take field
        pub fn take_api_docs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.api_docs, ::std::collections::HashMap::new())
        }

        // bool examples_provided = 4;

        pub fn examples_provided(&self) -> bool {
            self.examples_provided
        }

        pub fn clear_examples_provided(&mut self) {
            self.examples_provided = false;
        }

        // Param is passed by value, moved
        pub fn set_examples_provided(&mut self, v: bool) {
            self.examples_provided = v;
        }

        // repeated string doc_quality = 5;

        pub fn doc_quality(&self) -> &[::std::string::String] {
            &self.doc_quality
        }

        pub fn clear_doc_quality(&mut self) {
            self.doc_quality.clear();
        }

        // Param is passed by value, moved
        pub fn set_doc_quality(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.doc_quality = v;
        }

        // Mutable pointer to the field.
        pub fn mut_doc_quality(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.doc_quality
        }

        // Take field
        pub fn take_doc_quality(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.doc_quality, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "public_documented",
                |m: &DocumentationChecks| { &m.public_documented },
                |m: &mut DocumentationChecks| { &mut m.public_documented },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "doc_coverage",
                |m: &DocumentationChecks| { &m.doc_coverage },
                |m: &mut DocumentationChecks| { &mut m.doc_coverage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "api_docs",
                |m: &DocumentationChecks| { &m.api_docs },
                |m: &mut DocumentationChecks| { &mut m.api_docs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "examples_provided",
                |m: &DocumentationChecks| { &m.examples_provided },
                |m: &mut DocumentationChecks| { &mut m.examples_provided },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "doc_quality",
                |m: &DocumentationChecks| { &m.doc_quality },
                |m: &mut DocumentationChecks| { &mut m.doc_quality },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DocumentationChecks>(
                "QualityRatingSystem.DocumentationChecks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DocumentationChecks {
        const NAME: &'static str = "DocumentationChecks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.public_documented = is.read_bool()?;
                    },
                    18 => {
                        self.doc_coverage.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.api_docs.insert(key, value);
                    },
                    32 => {
                        self.examples_provided = is.read_bool()?;
                    },
                    42 => {
                        self.doc_quality.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.public_documented != false {
                my_size += 1 + 1;
            }
            for value in &self.doc_coverage {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.api_docs {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.examples_provided != false {
                my_size += 1 + 1;
            }
            for value in &self.doc_quality {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.public_documented != false {
                os.write_bool(1, self.public_documented)?;
            }
            for v in &self.doc_coverage {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.api_docs {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.examples_provided != false {
                os.write_bool(4, self.examples_provided)?;
            }
            for v in &self.doc_quality {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DocumentationChecks {
            DocumentationChecks::new()
        }

        fn clear(&mut self) {
            self.public_documented = false;
            self.doc_coverage.clear();
            self.api_docs.clear();
            self.examples_provided = false;
            self.doc_quality.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DocumentationChecks {
            static instance: ::protobuf::rt::Lazy<DocumentationChecks> = ::protobuf::rt::Lazy::new();
            instance.get(DocumentationChecks::new)
        }
    }

    impl ::protobuf::MessageFull for DocumentationChecks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.DocumentationChecks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DocumentationChecks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DocumentationChecks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.ImplementationChecks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ImplementationChecks {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.ImplementationChecks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ImplementationChecks {
        fn default() -> &'a ImplementationChecks {
            <ImplementationChecks as ::protobuf::Message>::default_instance()
        }
    }

    impl ImplementationChecks {
        pub fn new() -> ImplementationChecks {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ImplementationChecks>(
                "QualityRatingSystem.ImplementationChecks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ImplementationChecks {
        const NAME: &'static str = "ImplementationChecks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ImplementationChecks {
            ImplementationChecks::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ImplementationChecks {
            static instance: ImplementationChecks = ImplementationChecks {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ImplementationChecks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.ImplementationChecks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ImplementationChecks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ImplementationChecks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ImplementationChecks`
    pub mod implementation_checks {
        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SecurityChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.input_validated)
            pub input_validated: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.security_measures)
            pub security_measures: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.vulnerability_fixes)
            pub vulnerability_fixes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.secure_defaults)
            pub secure_defaults: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.security_review)
            pub security_review: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SecurityChecks {
            fn default() -> &'a SecurityChecks {
                <SecurityChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl SecurityChecks {
            pub fn new() -> SecurityChecks {
                ::std::default::Default::default()
            }

            // bool input_validated = 1;

            pub fn input_validated(&self) -> bool {
                self.input_validated
            }

            pub fn clear_input_validated(&mut self) {
                self.input_validated = false;
            }

            // Param is passed by value, moved
            pub fn set_input_validated(&mut self, v: bool) {
                self.input_validated = v;
            }

            // repeated string security_measures = 2;

            pub fn security_measures(&self) -> &[::std::string::String] {
                &self.security_measures
            }

            pub fn clear_security_measures(&mut self) {
                self.security_measures.clear();
            }

            // Param is passed by value, moved
            pub fn set_security_measures(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.security_measures = v;
            }

            // Mutable pointer to the field.
            pub fn mut_security_measures(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.security_measures
            }

            // Take field
            pub fn take_security_measures(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.security_measures, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.VulnerabilityFixesEntry vulnerability_fixes = 3;

            pub fn vulnerability_fixes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.vulnerability_fixes
            }

            pub fn clear_vulnerability_fixes(&mut self) {
                self.vulnerability_fixes.clear();
            }

            // Param is passed by value, moved
            pub fn set_vulnerability_fixes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.vulnerability_fixes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_vulnerability_fixes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.vulnerability_fixes
            }

            // Take field
            pub fn take_vulnerability_fixes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.vulnerability_fixes, ::std::collections::HashMap::new())
            }

            // bool secure_defaults = 4;

            pub fn secure_defaults(&self) -> bool {
                self.secure_defaults
            }

            pub fn clear_secure_defaults(&mut self) {
                self.secure_defaults = false;
            }

            // Param is passed by value, moved
            pub fn set_secure_defaults(&mut self, v: bool) {
                self.secure_defaults = v;
            }

            // repeated string security_review = 5;

            pub fn security_review(&self) -> &[::std::string::String] {
                &self.security_review
            }

            pub fn clear_security_review(&mut self) {
                self.security_review.clear();
            }

            // Param is passed by value, moved
            pub fn set_security_review(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.security_review = v;
            }

            // Mutable pointer to the field.
            pub fn mut_security_review(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.security_review
            }

            // Take field
            pub fn take_security_review(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.security_review, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "input_validated",
                    |m: &SecurityChecks| { &m.input_validated },
                    |m: &mut SecurityChecks| { &mut m.input_validated },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "security_measures",
                    |m: &SecurityChecks| { &m.security_measures },
                    |m: &mut SecurityChecks| { &mut m.security_measures },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "vulnerability_fixes",
                    |m: &SecurityChecks| { &m.vulnerability_fixes },
                    |m: &mut SecurityChecks| { &mut m.vulnerability_fixes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "secure_defaults",
                    |m: &SecurityChecks| { &m.secure_defaults },
                    |m: &mut SecurityChecks| { &mut m.secure_defaults },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "security_review",
                    |m: &SecurityChecks| { &m.security_review },
                    |m: &mut SecurityChecks| { &mut m.security_review },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SecurityChecks>(
                    "QualityRatingSystem.ImplementationChecks.SecurityChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SecurityChecks {
            const NAME: &'static str = "SecurityChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.input_validated = is.read_bool()?;
                        },
                        18 => {
                            self.security_measures.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.vulnerability_fixes.insert(key, value);
                        },
                        32 => {
                            self.secure_defaults = is.read_bool()?;
                        },
                        42 => {
                            self.security_review.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.input_validated != false {
                    my_size += 1 + 1;
                }
                for value in &self.security_measures {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.vulnerability_fixes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.secure_defaults != false {
                    my_size += 1 + 1;
                }
                for value in &self.security_review {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.input_validated != false {
                    os.write_bool(1, self.input_validated)?;
                }
                for v in &self.security_measures {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.vulnerability_fixes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.secure_defaults != false {
                    os.write_bool(4, self.secure_defaults)?;
                }
                for v in &self.security_review {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SecurityChecks {
                SecurityChecks::new()
            }

            fn clear(&mut self) {
                self.input_validated = false;
                self.security_measures.clear();
                self.vulnerability_fixes.clear();
                self.secure_defaults = false;
                self.security_review.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SecurityChecks {
                static instance: ::protobuf::rt::Lazy<SecurityChecks> = ::protobuf::rt::Lazy::new();
                instance.get(SecurityChecks::new)
            }
        }

        impl ::protobuf::MessageFull for SecurityChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.ImplementationChecks.SecurityChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SecurityChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SecurityChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TestingChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks.comprehensive_tests)
            pub comprehensive_tests: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks.test_coverage)
            pub test_coverage: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks.test_cases)
            pub test_cases: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks.integration_tests)
            pub integration_tests: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks.test_quality)
            pub test_quality: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TestingChecks {
            fn default() -> &'a TestingChecks {
                <TestingChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl TestingChecks {
            pub fn new() -> TestingChecks {
                ::std::default::Default::default()
            }

            // bool comprehensive_tests = 1;

            pub fn comprehensive_tests(&self) -> bool {
                self.comprehensive_tests
            }

            pub fn clear_comprehensive_tests(&mut self) {
                self.comprehensive_tests = false;
            }

            // Param is passed by value, moved
            pub fn set_comprehensive_tests(&mut self, v: bool) {
                self.comprehensive_tests = v;
            }

            // repeated string test_coverage = 2;

            pub fn test_coverage(&self) -> &[::std::string::String] {
                &self.test_coverage
            }

            pub fn clear_test_coverage(&mut self) {
                self.test_coverage.clear();
            }

            // Param is passed by value, moved
            pub fn set_test_coverage(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.test_coverage = v;
            }

            // Mutable pointer to the field.
            pub fn mut_test_coverage(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.test_coverage
            }

            // Take field
            pub fn take_test_coverage(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.test_coverage, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.ImplementationChecks.TestingChecks.TestCasesEntry test_cases = 3;

            pub fn test_cases(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.test_cases
            }

            pub fn clear_test_cases(&mut self) {
                self.test_cases.clear();
            }

            // Param is passed by value, moved
            pub fn set_test_cases(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.test_cases = v;
            }

            // Mutable pointer to the field.
            pub fn mut_test_cases(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.test_cases
            }

            // Take field
            pub fn take_test_cases(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.test_cases, ::std::collections::HashMap::new())
            }

            // bool integration_tests = 4;

            pub fn integration_tests(&self) -> bool {
                self.integration_tests
            }

            pub fn clear_integration_tests(&mut self) {
                self.integration_tests = false;
            }

            // Param is passed by value, moved
            pub fn set_integration_tests(&mut self, v: bool) {
                self.integration_tests = v;
            }

            // repeated string test_quality = 5;

            pub fn test_quality(&self) -> &[::std::string::String] {
                &self.test_quality
            }

            pub fn clear_test_quality(&mut self) {
                self.test_quality.clear();
            }

            // Param is passed by value, moved
            pub fn set_test_quality(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.test_quality = v;
            }

            // Mutable pointer to the field.
            pub fn mut_test_quality(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.test_quality
            }

            // Take field
            pub fn take_test_quality(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.test_quality, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "comprehensive_tests",
                    |m: &TestingChecks| { &m.comprehensive_tests },
                    |m: &mut TestingChecks| { &mut m.comprehensive_tests },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "test_coverage",
                    |m: &TestingChecks| { &m.test_coverage },
                    |m: &mut TestingChecks| { &mut m.test_coverage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "test_cases",
                    |m: &TestingChecks| { &m.test_cases },
                    |m: &mut TestingChecks| { &mut m.test_cases },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "integration_tests",
                    |m: &TestingChecks| { &m.integration_tests },
                    |m: &mut TestingChecks| { &mut m.integration_tests },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "test_quality",
                    |m: &TestingChecks| { &m.test_quality },
                    |m: &mut TestingChecks| { &mut m.test_quality },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestingChecks>(
                    "QualityRatingSystem.ImplementationChecks.TestingChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TestingChecks {
            const NAME: &'static str = "TestingChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.comprehensive_tests = is.read_bool()?;
                        },
                        18 => {
                            self.test_coverage.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.test_cases.insert(key, value);
                        },
                        32 => {
                            self.integration_tests = is.read_bool()?;
                        },
                        42 => {
                            self.test_quality.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.comprehensive_tests != false {
                    my_size += 1 + 1;
                }
                for value in &self.test_coverage {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.test_cases {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.integration_tests != false {
                    my_size += 1 + 1;
                }
                for value in &self.test_quality {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.comprehensive_tests != false {
                    os.write_bool(1, self.comprehensive_tests)?;
                }
                for v in &self.test_coverage {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.test_cases {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.integration_tests != false {
                    os.write_bool(4, self.integration_tests)?;
                }
                for v in &self.test_quality {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TestingChecks {
                TestingChecks::new()
            }

            fn clear(&mut self) {
                self.comprehensive_tests = false;
                self.test_coverage.clear();
                self.test_cases.clear();
                self.integration_tests = false;
                self.test_quality.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TestingChecks {
                static instance: ::protobuf::rt::Lazy<TestingChecks> = ::protobuf::rt::Lazy::new();
                instance.get(TestingChecks::new)
            }
        }

        impl ::protobuf::MessageFull for TestingChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.ImplementationChecks.TestingChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TestingChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TestingChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CodeQuality {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.follows_style)
            pub follows_style: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.code_metrics)
            pub code_metrics: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.review_notes)
            pub review_notes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.maintainable)
            pub maintainable: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.quality_checks)
            pub quality_checks: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CodeQuality {
            fn default() -> &'a CodeQuality {
                <CodeQuality as ::protobuf::Message>::default_instance()
            }
        }

        impl CodeQuality {
            pub fn new() -> CodeQuality {
                ::std::default::Default::default()
            }

            // bool follows_style = 1;

            pub fn follows_style(&self) -> bool {
                self.follows_style
            }

            pub fn clear_follows_style(&mut self) {
                self.follows_style = false;
            }

            // Param is passed by value, moved
            pub fn set_follows_style(&mut self, v: bool) {
                self.follows_style = v;
            }

            // repeated string code_metrics = 2;

            pub fn code_metrics(&self) -> &[::std::string::String] {
                &self.code_metrics
            }

            pub fn clear_code_metrics(&mut self) {
                self.code_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_code_metrics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.code_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_code_metrics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.code_metrics
            }

            // Take field
            pub fn take_code_metrics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.code_metrics, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.ReviewNotesEntry review_notes = 3;

            pub fn review_notes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.review_notes
            }

            pub fn clear_review_notes(&mut self) {
                self.review_notes.clear();
            }

            // Param is passed by value, moved
            pub fn set_review_notes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.review_notes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_review_notes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.review_notes
            }

            // Take field
            pub fn take_review_notes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.review_notes, ::std::collections::HashMap::new())
            }

            // bool maintainable = 4;

            pub fn maintainable(&self) -> bool {
                self.maintainable
            }

            pub fn clear_maintainable(&mut self) {
                self.maintainable = false;
            }

            // Param is passed by value, moved
            pub fn set_maintainable(&mut self, v: bool) {
                self.maintainable = v;
            }

            // repeated string quality_checks = 5;

            pub fn quality_checks(&self) -> &[::std::string::String] {
                &self.quality_checks
            }

            pub fn clear_quality_checks(&mut self) {
                self.quality_checks.clear();
            }

            // Param is passed by value, moved
            pub fn set_quality_checks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.quality_checks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_quality_checks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.quality_checks
            }

            // Take field
            pub fn take_quality_checks(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.quality_checks, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "follows_style",
                    |m: &CodeQuality| { &m.follows_style },
                    |m: &mut CodeQuality| { &mut m.follows_style },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "code_metrics",
                    |m: &CodeQuality| { &m.code_metrics },
                    |m: &mut CodeQuality| { &mut m.code_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "review_notes",
                    |m: &CodeQuality| { &m.review_notes },
                    |m: &mut CodeQuality| { &mut m.review_notes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "maintainable",
                    |m: &CodeQuality| { &m.maintainable },
                    |m: &mut CodeQuality| { &mut m.maintainable },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "quality_checks",
                    |m: &CodeQuality| { &m.quality_checks },
                    |m: &mut CodeQuality| { &mut m.quality_checks },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CodeQuality>(
                    "QualityRatingSystem.ImplementationChecks.CodeQuality",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CodeQuality {
            const NAME: &'static str = "CodeQuality";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.follows_style = is.read_bool()?;
                        },
                        18 => {
                            self.code_metrics.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.review_notes.insert(key, value);
                        },
                        32 => {
                            self.maintainable = is.read_bool()?;
                        },
                        42 => {
                            self.quality_checks.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.follows_style != false {
                    my_size += 1 + 1;
                }
                for value in &self.code_metrics {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.review_notes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.maintainable != false {
                    my_size += 1 + 1;
                }
                for value in &self.quality_checks {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.follows_style != false {
                    os.write_bool(1, self.follows_style)?;
                }
                for v in &self.code_metrics {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.review_notes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.maintainable != false {
                    os.write_bool(4, self.maintainable)?;
                }
                for v in &self.quality_checks {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CodeQuality {
                CodeQuality::new()
            }

            fn clear(&mut self) {
                self.follows_style = false;
                self.code_metrics.clear();
                self.review_notes.clear();
                self.maintainable = false;
                self.quality_checks.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CodeQuality {
                static instance: ::protobuf::rt::Lazy<CodeQuality> = ::protobuf::rt::Lazy::new();
                instance.get(CodeQuality::new)
            }
        }

        impl ::protobuf::MessageFull for CodeQuality {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.ImplementationChecks.CodeQuality").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CodeQuality {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CodeQuality {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.LanguageChecks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LanguageChecks {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.LanguageChecks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LanguageChecks {
        fn default() -> &'a LanguageChecks {
            <LanguageChecks as ::protobuf::Message>::default_instance()
        }
    }

    impl LanguageChecks {
        pub fn new() -> LanguageChecks {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanguageChecks>(
                "QualityRatingSystem.LanguageChecks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LanguageChecks {
        const NAME: &'static str = "LanguageChecks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LanguageChecks {
            LanguageChecks::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LanguageChecks {
            static instance: LanguageChecks = LanguageChecks {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LanguageChecks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.LanguageChecks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LanguageChecks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LanguageChecks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `LanguageChecks`
    pub mod language_checks {
        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RustChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks.ownership_correct)
            pub ownership_correct: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks.unsafe_justified)
            pub unsafe_justified: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks.trait_bounds)
            pub trait_bounds: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks.lifetime_elision)
            pub lifetime_elision: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks.rust_idioms)
            pub rust_idioms: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RustChecks {
            fn default() -> &'a RustChecks {
                <RustChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl RustChecks {
            pub fn new() -> RustChecks {
                ::std::default::Default::default()
            }

            // bool ownership_correct = 1;

            pub fn ownership_correct(&self) -> bool {
                self.ownership_correct
            }

            pub fn clear_ownership_correct(&mut self) {
                self.ownership_correct = false;
            }

            // Param is passed by value, moved
            pub fn set_ownership_correct(&mut self, v: bool) {
                self.ownership_correct = v;
            }

            // repeated string unsafe_justified = 2;

            pub fn unsafe_justified(&self) -> &[::std::string::String] {
                &self.unsafe_justified
            }

            pub fn clear_unsafe_justified(&mut self) {
                self.unsafe_justified.clear();
            }

            // Param is passed by value, moved
            pub fn set_unsafe_justified(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.unsafe_justified = v;
            }

            // Mutable pointer to the field.
            pub fn mut_unsafe_justified(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.unsafe_justified
            }

            // Take field
            pub fn take_unsafe_justified(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.unsafe_justified, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.LanguageChecks.RustChecks.TraitBoundsEntry trait_bounds = 3;

            pub fn trait_bounds(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.trait_bounds
            }

            pub fn clear_trait_bounds(&mut self) {
                self.trait_bounds.clear();
            }

            // Param is passed by value, moved
            pub fn set_trait_bounds(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.trait_bounds = v;
            }

            // Mutable pointer to the field.
            pub fn mut_trait_bounds(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.trait_bounds
            }

            // Take field
            pub fn take_trait_bounds(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.trait_bounds, ::std::collections::HashMap::new())
            }

            // bool lifetime_elision = 4;

            pub fn lifetime_elision(&self) -> bool {
                self.lifetime_elision
            }

            pub fn clear_lifetime_elision(&mut self) {
                self.lifetime_elision = false;
            }

            // Param is passed by value, moved
            pub fn set_lifetime_elision(&mut self, v: bool) {
                self.lifetime_elision = v;
            }

            // repeated string rust_idioms = 5;

            pub fn rust_idioms(&self) -> &[::std::string::String] {
                &self.rust_idioms
            }

            pub fn clear_rust_idioms(&mut self) {
                self.rust_idioms.clear();
            }

            // Param is passed by value, moved
            pub fn set_rust_idioms(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.rust_idioms = v;
            }

            // Mutable pointer to the field.
            pub fn mut_rust_idioms(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.rust_idioms
            }

            // Take field
            pub fn take_rust_idioms(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.rust_idioms, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "ownership_correct",
                    |m: &RustChecks| { &m.ownership_correct },
                    |m: &mut RustChecks| { &mut m.ownership_correct },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "unsafe_justified",
                    |m: &RustChecks| { &m.unsafe_justified },
                    |m: &mut RustChecks| { &mut m.unsafe_justified },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "trait_bounds",
                    |m: &RustChecks| { &m.trait_bounds },
                    |m: &mut RustChecks| { &mut m.trait_bounds },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "lifetime_elision",
                    |m: &RustChecks| { &m.lifetime_elision },
                    |m: &mut RustChecks| { &mut m.lifetime_elision },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "rust_idioms",
                    |m: &RustChecks| { &m.rust_idioms },
                    |m: &mut RustChecks| { &mut m.rust_idioms },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RustChecks>(
                    "QualityRatingSystem.LanguageChecks.RustChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for RustChecks {
            const NAME: &'static str = "RustChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.ownership_correct = is.read_bool()?;
                        },
                        18 => {
                            self.unsafe_justified.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.trait_bounds.insert(key, value);
                        },
                        32 => {
                            self.lifetime_elision = is.read_bool()?;
                        },
                        42 => {
                            self.rust_idioms.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.ownership_correct != false {
                    my_size += 1 + 1;
                }
                for value in &self.unsafe_justified {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.trait_bounds {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.lifetime_elision != false {
                    my_size += 1 + 1;
                }
                for value in &self.rust_idioms {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.ownership_correct != false {
                    os.write_bool(1, self.ownership_correct)?;
                }
                for v in &self.unsafe_justified {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.trait_bounds {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.lifetime_elision != false {
                    os.write_bool(4, self.lifetime_elision)?;
                }
                for v in &self.rust_idioms {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RustChecks {
                RustChecks::new()
            }

            fn clear(&mut self) {
                self.ownership_correct = false;
                self.unsafe_justified.clear();
                self.trait_bounds.clear();
                self.lifetime_elision = false;
                self.rust_idioms.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RustChecks {
                static instance: ::protobuf::rt::Lazy<RustChecks> = ::protobuf::rt::Lazy::new();
                instance.get(RustChecks::new)
            }
        }

        impl ::protobuf::MessageFull for RustChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.LanguageChecks.RustChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RustChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for RustChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TypeScriptChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks.type_safety)
            pub type_safety: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks.type_coverage)
            pub type_coverage: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks.interface_usage)
            pub interface_usage: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks.strict_mode)
            pub strict_mode: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks.ts_features)
            pub ts_features: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TypeScriptChecks {
            fn default() -> &'a TypeScriptChecks {
                <TypeScriptChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl TypeScriptChecks {
            pub fn new() -> TypeScriptChecks {
                ::std::default::Default::default()
            }

            // bool type_safety = 1;

            pub fn type_safety(&self) -> bool {
                self.type_safety
            }

            pub fn clear_type_safety(&mut self) {
                self.type_safety = false;
            }

            // Param is passed by value, moved
            pub fn set_type_safety(&mut self, v: bool) {
                self.type_safety = v;
            }

            // repeated string type_coverage = 2;

            pub fn type_coverage(&self) -> &[::std::string::String] {
                &self.type_coverage
            }

            pub fn clear_type_coverage(&mut self) {
                self.type_coverage.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_coverage(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.type_coverage = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_coverage(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.type_coverage
            }

            // Take field
            pub fn take_type_coverage(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.type_coverage, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChecks.InterfaceUsageEntry interface_usage = 3;

            pub fn interface_usage(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.interface_usage
            }

            pub fn clear_interface_usage(&mut self) {
                self.interface_usage.clear();
            }

            // Param is passed by value, moved
            pub fn set_interface_usage(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.interface_usage = v;
            }

            // Mutable pointer to the field.
            pub fn mut_interface_usage(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.interface_usage
            }

            // Take field
            pub fn take_interface_usage(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.interface_usage, ::std::collections::HashMap::new())
            }

            // bool strict_mode = 4;

            pub fn strict_mode(&self) -> bool {
                self.strict_mode
            }

            pub fn clear_strict_mode(&mut self) {
                self.strict_mode = false;
            }

            // Param is passed by value, moved
            pub fn set_strict_mode(&mut self, v: bool) {
                self.strict_mode = v;
            }

            // repeated string ts_features = 5;

            pub fn ts_features(&self) -> &[::std::string::String] {
                &self.ts_features
            }

            pub fn clear_ts_features(&mut self) {
                self.ts_features.clear();
            }

            // Param is passed by value, moved
            pub fn set_ts_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.ts_features = v;
            }

            // Mutable pointer to the field.
            pub fn mut_ts_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.ts_features
            }

            // Take field
            pub fn take_ts_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.ts_features, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "type_safety",
                    |m: &TypeScriptChecks| { &m.type_safety },
                    |m: &mut TypeScriptChecks| { &mut m.type_safety },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "type_coverage",
                    |m: &TypeScriptChecks| { &m.type_coverage },
                    |m: &mut TypeScriptChecks| { &mut m.type_coverage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "interface_usage",
                    |m: &TypeScriptChecks| { &m.interface_usage },
                    |m: &mut TypeScriptChecks| { &mut m.interface_usage },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "strict_mode",
                    |m: &TypeScriptChecks| { &m.strict_mode },
                    |m: &mut TypeScriptChecks| { &mut m.strict_mode },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "ts_features",
                    |m: &TypeScriptChecks| { &m.ts_features },
                    |m: &mut TypeScriptChecks| { &mut m.ts_features },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeScriptChecks>(
                    "QualityRatingSystem.LanguageChecks.TypeScriptChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TypeScriptChecks {
            const NAME: &'static str = "TypeScriptChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_safety = is.read_bool()?;
                        },
                        18 => {
                            self.type_coverage.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.interface_usage.insert(key, value);
                        },
                        32 => {
                            self.strict_mode = is.read_bool()?;
                        },
                        42 => {
                            self.ts_features.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.type_safety != false {
                    my_size += 1 + 1;
                }
                for value in &self.type_coverage {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.interface_usage {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.strict_mode != false {
                    my_size += 1 + 1;
                }
                for value in &self.ts_features {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.type_safety != false {
                    os.write_bool(1, self.type_safety)?;
                }
                for v in &self.type_coverage {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.interface_usage {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.strict_mode != false {
                    os.write_bool(4, self.strict_mode)?;
                }
                for v in &self.ts_features {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TypeScriptChecks {
                TypeScriptChecks::new()
            }

            fn clear(&mut self) {
                self.type_safety = false;
                self.type_coverage.clear();
                self.interface_usage.clear();
                self.strict_mode = false;
                self.ts_features.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TypeScriptChecks {
                static instance: ::protobuf::rt::Lazy<TypeScriptChecks> = ::protobuf::rt::Lazy::new();
                instance.get(TypeScriptChecks::new)
            }
        }

        impl ::protobuf::MessageFull for TypeScriptChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.LanguageChecks.TypeScriptChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TypeScriptChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TypeScriptChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PythonChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks.type_hints)
            pub type_hints: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks.pythonic)
            pub pythonic: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks.pep_compliance)
            pub pep_compliance: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks.async_correct)
            pub async_correct: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks.python_best_practices)
            pub python_best_practices: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PythonChecks {
            fn default() -> &'a PythonChecks {
                <PythonChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl PythonChecks {
            pub fn new() -> PythonChecks {
                ::std::default::Default::default()
            }

            // bool type_hints = 1;

            pub fn type_hints(&self) -> bool {
                self.type_hints
            }

            pub fn clear_type_hints(&mut self) {
                self.type_hints = false;
            }

            // Param is passed by value, moved
            pub fn set_type_hints(&mut self, v: bool) {
                self.type_hints = v;
            }

            // repeated string pythonic = 2;

            pub fn pythonic(&self) -> &[::std::string::String] {
                &self.pythonic
            }

            pub fn clear_pythonic(&mut self) {
                self.pythonic.clear();
            }

            // Param is passed by value, moved
            pub fn set_pythonic(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.pythonic = v;
            }

            // Mutable pointer to the field.
            pub fn mut_pythonic(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.pythonic
            }

            // Take field
            pub fn take_pythonic(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.pythonic, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.LanguageChecks.PythonChecks.PepComplianceEntry pep_compliance = 3;

            pub fn pep_compliance(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.pep_compliance
            }

            pub fn clear_pep_compliance(&mut self) {
                self.pep_compliance.clear();
            }

            // Param is passed by value, moved
            pub fn set_pep_compliance(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.pep_compliance = v;
            }

            // Mutable pointer to the field.
            pub fn mut_pep_compliance(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.pep_compliance
            }

            // Take field
            pub fn take_pep_compliance(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.pep_compliance, ::std::collections::HashMap::new())
            }

            // bool async_correct = 4;

            pub fn async_correct(&self) -> bool {
                self.async_correct
            }

            pub fn clear_async_correct(&mut self) {
                self.async_correct = false;
            }

            // Param is passed by value, moved
            pub fn set_async_correct(&mut self, v: bool) {
                self.async_correct = v;
            }

            // repeated string python_best_practices = 5;

            pub fn python_best_practices(&self) -> &[::std::string::String] {
                &self.python_best_practices
            }

            pub fn clear_python_best_practices(&mut self) {
                self.python_best_practices.clear();
            }

            // Param is passed by value, moved
            pub fn set_python_best_practices(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.python_best_practices = v;
            }

            // Mutable pointer to the field.
            pub fn mut_python_best_practices(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.python_best_practices
            }

            // Take field
            pub fn take_python_best_practices(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.python_best_practices, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "type_hints",
                    |m: &PythonChecks| { &m.type_hints },
                    |m: &mut PythonChecks| { &mut m.type_hints },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "pythonic",
                    |m: &PythonChecks| { &m.pythonic },
                    |m: &mut PythonChecks| { &mut m.pythonic },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "pep_compliance",
                    |m: &PythonChecks| { &m.pep_compliance },
                    |m: &mut PythonChecks| { &mut m.pep_compliance },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "async_correct",
                    |m: &PythonChecks| { &m.async_correct },
                    |m: &mut PythonChecks| { &mut m.async_correct },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "python_best_practices",
                    |m: &PythonChecks| { &m.python_best_practices },
                    |m: &mut PythonChecks| { &mut m.python_best_practices },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PythonChecks>(
                    "QualityRatingSystem.LanguageChecks.PythonChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PythonChecks {
            const NAME: &'static str = "PythonChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_hints = is.read_bool()?;
                        },
                        18 => {
                            self.pythonic.push(is.read_string()?);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.pep_compliance.insert(key, value);
                        },
                        32 => {
                            self.async_correct = is.read_bool()?;
                        },
                        42 => {
                            self.python_best_practices.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.type_hints != false {
                    my_size += 1 + 1;
                }
                for value in &self.pythonic {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                for (k, v) in &self.pep_compliance {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.async_correct != false {
                    my_size += 1 + 1;
                }
                for value in &self.python_best_practices {
                    my_size += ::protobuf::rt::string_size(5, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.type_hints != false {
                    os.write_bool(1, self.type_hints)?;
                }
                for v in &self.pythonic {
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.pep_compliance {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.async_correct != false {
                    os.write_bool(4, self.async_correct)?;
                }
                for v in &self.python_best_practices {
                    os.write_string(5, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PythonChecks {
                PythonChecks::new()
            }

            fn clear(&mut self) {
                self.type_hints = false;
                self.pythonic.clear();
                self.pep_compliance.clear();
                self.async_correct = false;
                self.python_best_practices.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PythonChecks {
                static instance: ::protobuf::rt::Lazy<PythonChecks> = ::protobuf::rt::Lazy::new();
                instance.get(PythonChecks::new)
            }
        }

        impl ::protobuf::MessageFull for PythonChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.LanguageChecks.PythonChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PythonChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PythonChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.QualityEnforcement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QualityEnforcement {
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.QualityEnforcement.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QualityEnforcement {
        fn default() -> &'a QualityEnforcement {
            <QualityEnforcement as ::protobuf::Message>::default_instance()
        }
    }

    impl QualityEnforcement {
        pub fn new() -> QualityEnforcement {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QualityEnforcement>(
                "QualityRatingSystem.QualityEnforcement",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QualityEnforcement {
        const NAME: &'static str = "QualityEnforcement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QualityEnforcement {
            QualityEnforcement::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QualityEnforcement {
            static instance: QualityEnforcement = QualityEnforcement {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QualityEnforcement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.QualityEnforcement").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QualityEnforcement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QualityEnforcement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `QualityEnforcement`
    pub mod quality_enforcement {
        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct AutomatedChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.linter_rules)
            pub linter_rules: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.quality_gates)
            pub quality_gates: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.ci_integration)
            pub ci_integration: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.automated_metrics)
            pub automated_metrics: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.enforcement_rules)
            pub enforcement_rules: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a AutomatedChecks {
            fn default() -> &'a AutomatedChecks {
                <AutomatedChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl AutomatedChecks {
            pub fn new() -> AutomatedChecks {
                ::std::default::Default::default()
            }

            // repeated string linter_rules = 1;

            pub fn linter_rules(&self) -> &[::std::string::String] {
                &self.linter_rules
            }

            pub fn clear_linter_rules(&mut self) {
                self.linter_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_linter_rules(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.linter_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_linter_rules(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.linter_rules
            }

            // Take field
            pub fn take_linter_rules(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.linter_rules, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.QualityGatesEntry quality_gates = 2;

            pub fn quality_gates(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.quality_gates
            }

            pub fn clear_quality_gates(&mut self) {
                self.quality_gates.clear();
            }

            // Param is passed by value, moved
            pub fn set_quality_gates(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.quality_gates = v;
            }

            // Mutable pointer to the field.
            pub fn mut_quality_gates(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.quality_gates
            }

            // Take field
            pub fn take_quality_gates(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.quality_gates, ::std::collections::HashMap::new())
            }

            // bool ci_integration = 3;

            pub fn ci_integration(&self) -> bool {
                self.ci_integration
            }

            pub fn clear_ci_integration(&mut self) {
                self.ci_integration = false;
            }

            // Param is passed by value, moved
            pub fn set_ci_integration(&mut self, v: bool) {
                self.ci_integration = v;
            }

            // repeated string automated_metrics = 4;

            pub fn automated_metrics(&self) -> &[::std::string::String] {
                &self.automated_metrics
            }

            pub fn clear_automated_metrics(&mut self) {
                self.automated_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_automated_metrics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.automated_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_automated_metrics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.automated_metrics
            }

            // Take field
            pub fn take_automated_metrics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.automated_metrics, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.QualityEnforcement.AutomatedChecks.EnforcementRulesEntry enforcement_rules = 5;

            pub fn enforcement_rules(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.enforcement_rules
            }

            pub fn clear_enforcement_rules(&mut self) {
                self.enforcement_rules.clear();
            }

            // Param is passed by value, moved
            pub fn set_enforcement_rules(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.enforcement_rules = v;
            }

            // Mutable pointer to the field.
            pub fn mut_enforcement_rules(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.enforcement_rules
            }

            // Take field
            pub fn take_enforcement_rules(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.enforcement_rules, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "linter_rules",
                    |m: &AutomatedChecks| { &m.linter_rules },
                    |m: &mut AutomatedChecks| { &mut m.linter_rules },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "quality_gates",
                    |m: &AutomatedChecks| { &m.quality_gates },
                    |m: &mut AutomatedChecks| { &mut m.quality_gates },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "ci_integration",
                    |m: &AutomatedChecks| { &m.ci_integration },
                    |m: &mut AutomatedChecks| { &mut m.ci_integration },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "automated_metrics",
                    |m: &AutomatedChecks| { &m.automated_metrics },
                    |m: &mut AutomatedChecks| { &mut m.automated_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "enforcement_rules",
                    |m: &AutomatedChecks| { &m.enforcement_rules },
                    |m: &mut AutomatedChecks| { &mut m.enforcement_rules },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AutomatedChecks>(
                    "QualityRatingSystem.QualityEnforcement.AutomatedChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for AutomatedChecks {
            const NAME: &'static str = "AutomatedChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.linter_rules.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.quality_gates.insert(key, value);
                        },
                        24 => {
                            self.ci_integration = is.read_bool()?;
                        },
                        34 => {
                            self.automated_metrics.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.enforcement_rules.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.linter_rules {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.quality_gates {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.ci_integration != false {
                    my_size += 1 + 1;
                }
                for value in &self.automated_metrics {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.enforcement_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.linter_rules {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.quality_gates {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.ci_integration != false {
                    os.write_bool(3, self.ci_integration)?;
                }
                for v in &self.automated_metrics {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.enforcement_rules {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> AutomatedChecks {
                AutomatedChecks::new()
            }

            fn clear(&mut self) {
                self.linter_rules.clear();
                self.quality_gates.clear();
                self.ci_integration = false;
                self.automated_metrics.clear();
                self.enforcement_rules.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static AutomatedChecks {
                static instance: ::protobuf::rt::Lazy<AutomatedChecks> = ::protobuf::rt::Lazy::new();
                instance.get(AutomatedChecks::new)
            }
        }

        impl ::protobuf::MessageFull for AutomatedChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.QualityEnforcement.AutomatedChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for AutomatedChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for AutomatedChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ManualReview {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.review_checklist)
            pub review_checklist: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.reviewer_notes)
            pub reviewer_notes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.peer_reviewed)
            pub peer_reviewed: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.review_findings)
            pub review_findings: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.action_items)
            pub action_items: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ManualReview {
            fn default() -> &'a ManualReview {
                <ManualReview as ::protobuf::Message>::default_instance()
            }
        }

        impl ManualReview {
            pub fn new() -> ManualReview {
                ::std::default::Default::default()
            }

            // repeated string review_checklist = 1;

            pub fn review_checklist(&self) -> &[::std::string::String] {
                &self.review_checklist
            }

            pub fn clear_review_checklist(&mut self) {
                self.review_checklist.clear();
            }

            // Param is passed by value, moved
            pub fn set_review_checklist(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.review_checklist = v;
            }

            // Mutable pointer to the field.
            pub fn mut_review_checklist(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.review_checklist
            }

            // Take field
            pub fn take_review_checklist(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.review_checklist, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.ReviewerNotesEntry reviewer_notes = 2;

            pub fn reviewer_notes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.reviewer_notes
            }

            pub fn clear_reviewer_notes(&mut self) {
                self.reviewer_notes.clear();
            }

            // Param is passed by value, moved
            pub fn set_reviewer_notes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.reviewer_notes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_reviewer_notes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.reviewer_notes
            }

            // Take field
            pub fn take_reviewer_notes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.reviewer_notes, ::std::collections::HashMap::new())
            }

            // bool peer_reviewed = 3;

            pub fn peer_reviewed(&self) -> bool {
                self.peer_reviewed
            }

            pub fn clear_peer_reviewed(&mut self) {
                self.peer_reviewed = false;
            }

            // Param is passed by value, moved
            pub fn set_peer_reviewed(&mut self, v: bool) {
                self.peer_reviewed = v;
            }

            // repeated string review_findings = 4;

            pub fn review_findings(&self) -> &[::std::string::String] {
                &self.review_findings
            }

            pub fn clear_review_findings(&mut self) {
                self.review_findings.clear();
            }

            // Param is passed by value, moved
            pub fn set_review_findings(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.review_findings = v;
            }

            // Mutable pointer to the field.
            pub fn mut_review_findings(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.review_findings
            }

            // Take field
            pub fn take_review_findings(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.review_findings, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.QualityEnforcement.ManualReview.ActionItemsEntry action_items = 5;

            pub fn action_items(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.action_items
            }

            pub fn clear_action_items(&mut self) {
                self.action_items.clear();
            }

            // Param is passed by value, moved
            pub fn set_action_items(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.action_items = v;
            }

            // Mutable pointer to the field.
            pub fn mut_action_items(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.action_items
            }

            // Take field
            pub fn take_action_items(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.action_items, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "review_checklist",
                    |m: &ManualReview| { &m.review_checklist },
                    |m: &mut ManualReview| { &mut m.review_checklist },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "reviewer_notes",
                    |m: &ManualReview| { &m.reviewer_notes },
                    |m: &mut ManualReview| { &mut m.reviewer_notes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "peer_reviewed",
                    |m: &ManualReview| { &m.peer_reviewed },
                    |m: &mut ManualReview| { &mut m.peer_reviewed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "review_findings",
                    |m: &ManualReview| { &m.review_findings },
                    |m: &mut ManualReview| { &mut m.review_findings },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "action_items",
                    |m: &ManualReview| { &m.action_items },
                    |m: &mut ManualReview| { &mut m.action_items },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ManualReview>(
                    "QualityRatingSystem.QualityEnforcement.ManualReview",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ManualReview {
            const NAME: &'static str = "ManualReview";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.review_checklist.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.reviewer_notes.insert(key, value);
                        },
                        24 => {
                            self.peer_reviewed = is.read_bool()?;
                        },
                        34 => {
                            self.review_findings.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.action_items.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.review_checklist {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.reviewer_notes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.peer_reviewed != false {
                    my_size += 1 + 1;
                }
                for value in &self.review_findings {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.action_items {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.review_checklist {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.reviewer_notes {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.peer_reviewed != false {
                    os.write_bool(3, self.peer_reviewed)?;
                }
                for v in &self.review_findings {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.action_items {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ManualReview {
                ManualReview::new()
            }

            fn clear(&mut self) {
                self.review_checklist.clear();
                self.reviewer_notes.clear();
                self.peer_reviewed = false;
                self.review_findings.clear();
                self.action_items.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ManualReview {
                static instance: ::protobuf::rt::Lazy<ManualReview> = ::protobuf::rt::Lazy::new();
                instance.get(ManualReview::new)
            }
        }

        impl ::protobuf::MessageFull for ManualReview {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.QualityEnforcement.ManualReview").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ManualReview {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ManualReview {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ContinuousImprovement {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.improvement_metrics)
            pub improvement_metrics: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.feedback_loop)
            pub feedback_loop: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.trending_positive)
            pub trending_positive: bool,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.learning_points)
            pub learning_points: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.improvement_plan)
            pub improvement_plan: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ContinuousImprovement {
            fn default() -> &'a ContinuousImprovement {
                <ContinuousImprovement as ::protobuf::Message>::default_instance()
            }
        }

        impl ContinuousImprovement {
            pub fn new() -> ContinuousImprovement {
                ::std::default::Default::default()
            }

            // repeated string improvement_metrics = 1;

            pub fn improvement_metrics(&self) -> &[::std::string::String] {
                &self.improvement_metrics
            }

            pub fn clear_improvement_metrics(&mut self) {
                self.improvement_metrics.clear();
            }

            // Param is passed by value, moved
            pub fn set_improvement_metrics(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.improvement_metrics = v;
            }

            // Mutable pointer to the field.
            pub fn mut_improvement_metrics(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.improvement_metrics
            }

            // Take field
            pub fn take_improvement_metrics(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.improvement_metrics, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.FeedbackLoopEntry feedback_loop = 2;

            pub fn feedback_loop(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.feedback_loop
            }

            pub fn clear_feedback_loop(&mut self) {
                self.feedback_loop.clear();
            }

            // Param is passed by value, moved
            pub fn set_feedback_loop(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.feedback_loop = v;
            }

            // Mutable pointer to the field.
            pub fn mut_feedback_loop(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.feedback_loop
            }

            // Take field
            pub fn take_feedback_loop(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.feedback_loop, ::std::collections::HashMap::new())
            }

            // bool trending_positive = 3;

            pub fn trending_positive(&self) -> bool {
                self.trending_positive
            }

            pub fn clear_trending_positive(&mut self) {
                self.trending_positive = false;
            }

            // Param is passed by value, moved
            pub fn set_trending_positive(&mut self, v: bool) {
                self.trending_positive = v;
            }

            // repeated string learning_points = 4;

            pub fn learning_points(&self) -> &[::std::string::String] {
                &self.learning_points
            }

            pub fn clear_learning_points(&mut self) {
                self.learning_points.clear();
            }

            // Param is passed by value, moved
            pub fn set_learning_points(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.learning_points = v;
            }

            // Mutable pointer to the field.
            pub fn mut_learning_points(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.learning_points
            }

            // Take field
            pub fn take_learning_points(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.learning_points, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImprovement.ImprovementPlanEntry improvement_plan = 5;

            pub fn improvement_plan(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.improvement_plan
            }

            pub fn clear_improvement_plan(&mut self) {
                self.improvement_plan.clear();
            }

            // Param is passed by value, moved
            pub fn set_improvement_plan(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.improvement_plan = v;
            }

            // Mutable pointer to the field.
            pub fn mut_improvement_plan(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.improvement_plan
            }

            // Take field
            pub fn take_improvement_plan(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.improvement_plan, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "improvement_metrics",
                    |m: &ContinuousImprovement| { &m.improvement_metrics },
                    |m: &mut ContinuousImprovement| { &mut m.improvement_metrics },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "feedback_loop",
                    |m: &ContinuousImprovement| { &m.feedback_loop },
                    |m: &mut ContinuousImprovement| { &mut m.feedback_loop },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "trending_positive",
                    |m: &ContinuousImprovement| { &m.trending_positive },
                    |m: &mut ContinuousImprovement| { &mut m.trending_positive },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "learning_points",
                    |m: &ContinuousImprovement| { &m.learning_points },
                    |m: &mut ContinuousImprovement| { &mut m.learning_points },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "improvement_plan",
                    |m: &ContinuousImprovement| { &m.improvement_plan },
                    |m: &mut ContinuousImprovement| { &mut m.improvement_plan },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ContinuousImprovement>(
                    "QualityRatingSystem.QualityEnforcement.ContinuousImprovement",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ContinuousImprovement {
            const NAME: &'static str = "ContinuousImprovement";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.improvement_metrics.push(is.read_string()?);
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.feedback_loop.insert(key, value);
                        },
                        24 => {
                            self.trending_positive = is.read_bool()?;
                        },
                        34 => {
                            self.learning_points.push(is.read_string()?);
                        },
                        42 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.improvement_plan.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                for value in &self.improvement_metrics {
                    my_size += ::protobuf::rt::string_size(1, &value);
                };
                for (k, v) in &self.feedback_loop {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                if self.trending_positive != false {
                    my_size += 1 + 1;
                }
                for value in &self.learning_points {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                for (k, v) in &self.improvement_plan {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                for v in &self.improvement_metrics {
                    os.write_string(1, &v)?;
                };
                for (k, v) in &self.feedback_loop {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                if self.trending_positive != false {
                    os.write_bool(3, self.trending_positive)?;
                }
                for v in &self.learning_points {
                    os.write_string(4, &v)?;
                };
                for (k, v) in &self.improvement_plan {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(42)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ContinuousImprovement {
                ContinuousImprovement::new()
            }

            fn clear(&mut self) {
                self.improvement_metrics.clear();
                self.feedback_loop.clear();
                self.trending_positive = false;
                self.learning_points.clear();
                self.improvement_plan.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ContinuousImprovement {
                static instance: ::protobuf::rt::Lazy<ContinuousImprovement> = ::protobuf::rt::Lazy::new();
                instance.get(ContinuousImprovement::new)
            }
        }

        impl ::protobuf::MessageFull for ContinuousImprovement {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("QualityRatingSystem.QualityEnforcement.ContinuousImprovement").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ContinuousImprovement {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ContinuousImprovement {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LanguageQualityPrompts {
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LanguageQualityPrompts {
    fn default() -> &'a LanguageQualityPrompts {
        <LanguageQualityPrompts as ::protobuf::Message>::default_instance()
    }
}

impl LanguageQualityPrompts {
    pub fn new() -> LanguageQualityPrompts {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanguageQualityPrompts>(
            "LanguageQualityPrompts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LanguageQualityPrompts {
    const NAME: &'static str = "LanguageQualityPrompts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LanguageQualityPrompts {
        LanguageQualityPrompts::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LanguageQualityPrompts {
        static instance: LanguageQualityPrompts = LanguageQualityPrompts {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LanguageQualityPrompts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LanguageQualityPrompts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LanguageQualityPrompts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LanguageQualityPrompts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LanguageQualityPrompts`
pub mod language_quality_prompts {
    // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.KymeraPrompt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KymeraPrompt {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.objective)
        pub objective: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KymeraPrompt {
        fn default() -> &'a KymeraPrompt {
            <KymeraPrompt as ::protobuf::Message>::default_instance()
        }
    }

    impl KymeraPrompt {
        pub fn new() -> KymeraPrompt {
            ::std::default::Default::default()
        }

        // string title = 1;

        pub fn title(&self) -> &str {
            &self.title
        }

        pub fn clear_title(&mut self) {
            self.title.clear();
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            &mut self.title
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.title, ::std::string::String::new())
        }

        // string objective = 2;

        pub fn objective(&self) -> &str {
            &self.objective
        }

        pub fn clear_objective(&mut self) {
            self.objective.clear();
        }

        // Param is passed by value, moved
        pub fn set_objective(&mut self, v: ::std::string::String) {
            self.objective = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_objective(&mut self) -> &mut ::std::string::String {
            &mut self.objective
        }

        // Take field
        pub fn take_objective(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.objective, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &KymeraPrompt| { &m.title },
                |m: &mut KymeraPrompt| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "objective",
                |m: &KymeraPrompt| { &m.objective },
                |m: &mut KymeraPrompt| { &mut m.objective },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KymeraPrompt>(
                "LanguageQualityPrompts.KymeraPrompt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KymeraPrompt {
        const NAME: &'static str = "KymeraPrompt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.objective = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.objective.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.objective);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.objective.is_empty() {
                os.write_string(2, &self.objective)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KymeraPrompt {
            KymeraPrompt::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.objective.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KymeraPrompt {
            static instance: KymeraPrompt = KymeraPrompt {
                title: ::std::string::String::new(),
                objective: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KymeraPrompt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.KymeraPrompt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KymeraPrompt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KymeraPrompt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `KymeraPrompt`
    pub mod kymera_prompt {
        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ModularityChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ModularityChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ModularityChecks.unused_refs_removed)
            pub unused_refs_removed: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ModularityChecks.auto_deps_managed)
            pub auto_deps_managed: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ModularityChecks.cleanup_tasks)
            pub cleanup_tasks: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ModularityChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ModularityChecks {
            fn default() -> &'a ModularityChecks {
                <ModularityChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl ModularityChecks {
            pub fn new() -> ModularityChecks {
                ::std::default::Default::default()
            }

            // bool unused_refs_removed = 1;

            pub fn unused_refs_removed(&self) -> bool {
                self.unused_refs_removed
            }

            pub fn clear_unused_refs_removed(&mut self) {
                self.unused_refs_removed = false;
            }

            // Param is passed by value, moved
            pub fn set_unused_refs_removed(&mut self, v: bool) {
                self.unused_refs_removed = v;
            }

            // bool auto_deps_managed = 2;

            pub fn auto_deps_managed(&self) -> bool {
                self.auto_deps_managed
            }

            pub fn clear_auto_deps_managed(&mut self) {
                self.auto_deps_managed = false;
            }

            // Param is passed by value, moved
            pub fn set_auto_deps_managed(&mut self, v: bool) {
                self.auto_deps_managed = v;
            }

            // repeated string cleanup_tasks = 3;

            pub fn cleanup_tasks(&self) -> &[::std::string::String] {
                &self.cleanup_tasks
            }

            pub fn clear_cleanup_tasks(&mut self) {
                self.cleanup_tasks.clear();
            }

            // Param is passed by value, moved
            pub fn set_cleanup_tasks(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.cleanup_tasks = v;
            }

            // Mutable pointer to the field.
            pub fn mut_cleanup_tasks(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.cleanup_tasks
            }

            // Take field
            pub fn take_cleanup_tasks(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.cleanup_tasks, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "unused_refs_removed",
                    |m: &ModularityChecks| { &m.unused_refs_removed },
                    |m: &mut ModularityChecks| { &mut m.unused_refs_removed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "auto_deps_managed",
                    |m: &ModularityChecks| { &m.auto_deps_managed },
                    |m: &mut ModularityChecks| { &mut m.auto_deps_managed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "cleanup_tasks",
                    |m: &ModularityChecks| { &m.cleanup_tasks },
                    |m: &mut ModularityChecks| { &mut m.cleanup_tasks },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModularityChecks>(
                    "LanguageQualityPrompts.KymeraPrompt.ModularityChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ModularityChecks {
            const NAME: &'static str = "ModularityChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.unused_refs_removed = is.read_bool()?;
                        },
                        16 => {
                            self.auto_deps_managed = is.read_bool()?;
                        },
                        26 => {
                            self.cleanup_tasks.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.unused_refs_removed != false {
                    my_size += 1 + 1;
                }
                if self.auto_deps_managed != false {
                    my_size += 1 + 1;
                }
                for value in &self.cleanup_tasks {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.unused_refs_removed != false {
                    os.write_bool(1, self.unused_refs_removed)?;
                }
                if self.auto_deps_managed != false {
                    os.write_bool(2, self.auto_deps_managed)?;
                }
                for v in &self.cleanup_tasks {
                    os.write_string(3, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ModularityChecks {
                ModularityChecks::new()
            }

            fn clear(&mut self) {
                self.unused_refs_removed = false;
                self.auto_deps_managed = false;
                self.cleanup_tasks.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ModularityChecks {
                static instance: ModularityChecks = ModularityChecks {
                    unused_refs_removed: false,
                    auto_deps_managed: false,
                    cleanup_tasks: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ModularityChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.KymeraPrompt.ModularityChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ModularityChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ModularityChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ErrorHandling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorHandling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ErrorHandling.custom_types)
            pub custom_types: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ErrorHandling.error_patterns)
            pub error_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ErrorHandling.graceful_handling)
            pub graceful_handling: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.ErrorHandling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorHandling {
            fn default() -> &'a ErrorHandling {
                <ErrorHandling as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorHandling {
            pub fn new() -> ErrorHandling {
                ::std::default::Default::default()
            }

            // bool custom_types = 1;

            pub fn custom_types(&self) -> bool {
                self.custom_types
            }

            pub fn clear_custom_types(&mut self) {
                self.custom_types = false;
            }

            // Param is passed by value, moved
            pub fn set_custom_types(&mut self, v: bool) {
                self.custom_types = v;
            }

            // repeated string error_patterns = 2;

            pub fn error_patterns(&self) -> &[::std::string::String] {
                &self.error_patterns
            }

            pub fn clear_error_patterns(&mut self) {
                self.error_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_error_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.error_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_error_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.error_patterns
            }

            // Take field
            pub fn take_error_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.error_patterns, ::std::vec::Vec::new())
            }

            // bool graceful_handling = 3;

            pub fn graceful_handling(&self) -> bool {
                self.graceful_handling
            }

            pub fn clear_graceful_handling(&mut self) {
                self.graceful_handling = false;
            }

            // Param is passed by value, moved
            pub fn set_graceful_handling(&mut self, v: bool) {
                self.graceful_handling = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "custom_types",
                    |m: &ErrorHandling| { &m.custom_types },
                    |m: &mut ErrorHandling| { &mut m.custom_types },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "error_patterns",
                    |m: &ErrorHandling| { &m.error_patterns },
                    |m: &mut ErrorHandling| { &mut m.error_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "graceful_handling",
                    |m: &ErrorHandling| { &m.graceful_handling },
                    |m: &mut ErrorHandling| { &mut m.graceful_handling },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandling>(
                    "LanguageQualityPrompts.KymeraPrompt.ErrorHandling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorHandling {
            const NAME: &'static str = "ErrorHandling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.custom_types = is.read_bool()?;
                        },
                        18 => {
                            self.error_patterns.push(is.read_string()?);
                        },
                        24 => {
                            self.graceful_handling = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.custom_types != false {
                    my_size += 1 + 1;
                }
                for value in &self.error_patterns {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.graceful_handling != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.custom_types != false {
                    os.write_bool(1, self.custom_types)?;
                }
                for v in &self.error_patterns {
                    os.write_string(2, &v)?;
                };
                if self.graceful_handling != false {
                    os.write_bool(3, self.graceful_handling)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorHandling {
                ErrorHandling::new()
            }

            fn clear(&mut self) {
                self.custom_types = false;
                self.error_patterns.clear();
                self.graceful_handling = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorHandling {
                static instance: ErrorHandling = ErrorHandling {
                    custom_types: false,
                    error_patterns: ::std::vec::Vec::new(),
                    graceful_handling: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorHandling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.KymeraPrompt.ErrorHandling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorHandling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorHandling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.PerformanceOptimization)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PerformanceOptimization {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.PerformanceOptimization.ai_generation)
            pub ai_generation: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.PerformanceOptimization.optimizations)
            pub optimizations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.PerformanceOptimization.hotspot_optimized)
            pub hotspot_optimized: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.PerformanceOptimization.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PerformanceOptimization {
            fn default() -> &'a PerformanceOptimization {
                <PerformanceOptimization as ::protobuf::Message>::default_instance()
            }
        }

        impl PerformanceOptimization {
            pub fn new() -> PerformanceOptimization {
                ::std::default::Default::default()
            }

            // bool ai_generation = 1;

            pub fn ai_generation(&self) -> bool {
                self.ai_generation
            }

            pub fn clear_ai_generation(&mut self) {
                self.ai_generation = false;
            }

            // Param is passed by value, moved
            pub fn set_ai_generation(&mut self, v: bool) {
                self.ai_generation = v;
            }

            // repeated string optimizations = 2;

            pub fn optimizations(&self) -> &[::std::string::String] {
                &self.optimizations
            }

            pub fn clear_optimizations(&mut self) {
                self.optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimizations
            }

            // Take field
            pub fn take_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimizations, ::std::vec::Vec::new())
            }

            // bool hotspot_optimized = 3;

            pub fn hotspot_optimized(&self) -> bool {
                self.hotspot_optimized
            }

            pub fn clear_hotspot_optimized(&mut self) {
                self.hotspot_optimized = false;
            }

            // Param is passed by value, moved
            pub fn set_hotspot_optimized(&mut self, v: bool) {
                self.hotspot_optimized = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "ai_generation",
                    |m: &PerformanceOptimization| { &m.ai_generation },
                    |m: &mut PerformanceOptimization| { &mut m.ai_generation },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimizations",
                    |m: &PerformanceOptimization| { &m.optimizations },
                    |m: &mut PerformanceOptimization| { &mut m.optimizations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "hotspot_optimized",
                    |m: &PerformanceOptimization| { &m.hotspot_optimized },
                    |m: &mut PerformanceOptimization| { &mut m.hotspot_optimized },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerformanceOptimization>(
                    "LanguageQualityPrompts.KymeraPrompt.PerformanceOptimization",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for PerformanceOptimization {
            const NAME: &'static str = "PerformanceOptimization";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.ai_generation = is.read_bool()?;
                        },
                        18 => {
                            self.optimizations.push(is.read_string()?);
                        },
                        24 => {
                            self.hotspot_optimized = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.ai_generation != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimizations {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.hotspot_optimized != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.ai_generation != false {
                    os.write_bool(1, self.ai_generation)?;
                }
                for v in &self.optimizations {
                    os.write_string(2, &v)?;
                };
                if self.hotspot_optimized != false {
                    os.write_bool(3, self.hotspot_optimized)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PerformanceOptimization {
                PerformanceOptimization::new()
            }

            fn clear(&mut self) {
                self.ai_generation = false;
                self.optimizations.clear();
                self.hotspot_optimized = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PerformanceOptimization {
                static instance: PerformanceOptimization = PerformanceOptimization {
                    ai_generation: false,
                    optimizations: ::std::vec::Vec::new(),
                    hotspot_optimized: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for PerformanceOptimization {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.KymeraPrompt.PerformanceOptimization").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for PerformanceOptimization {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for PerformanceOptimization {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.Documentation)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Documentation {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.Documentation.structured_docs)
            pub structured_docs: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.Documentation.doc_items)
            pub doc_items: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.Documentation.coverage_complete)
            pub coverage_complete: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.KymeraPrompt.Documentation.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Documentation {
            fn default() -> &'a Documentation {
                <Documentation as ::protobuf::Message>::default_instance()
            }
        }

        impl Documentation {
            pub fn new() -> Documentation {
                ::std::default::Default::default()
            }

            // bool structured_docs = 1;

            pub fn structured_docs(&self) -> bool {
                self.structured_docs
            }

            pub fn clear_structured_docs(&mut self) {
                self.structured_docs = false;
            }

            // Param is passed by value, moved
            pub fn set_structured_docs(&mut self, v: bool) {
                self.structured_docs = v;
            }

            // repeated string doc_items = 2;

            pub fn doc_items(&self) -> &[::std::string::String] {
                &self.doc_items
            }

            pub fn clear_doc_items(&mut self) {
                self.doc_items.clear();
            }

            // Param is passed by value, moved
            pub fn set_doc_items(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.doc_items = v;
            }

            // Mutable pointer to the field.
            pub fn mut_doc_items(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.doc_items
            }

            // Take field
            pub fn take_doc_items(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.doc_items, ::std::vec::Vec::new())
            }

            // bool coverage_complete = 3;

            pub fn coverage_complete(&self) -> bool {
                self.coverage_complete
            }

            pub fn clear_coverage_complete(&mut self) {
                self.coverage_complete = false;
            }

            // Param is passed by value, moved
            pub fn set_coverage_complete(&mut self, v: bool) {
                self.coverage_complete = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "structured_docs",
                    |m: &Documentation| { &m.structured_docs },
                    |m: &mut Documentation| { &mut m.structured_docs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "doc_items",
                    |m: &Documentation| { &m.doc_items },
                    |m: &mut Documentation| { &mut m.doc_items },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "coverage_complete",
                    |m: &Documentation| { &m.coverage_complete },
                    |m: &mut Documentation| { &mut m.coverage_complete },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Documentation>(
                    "LanguageQualityPrompts.KymeraPrompt.Documentation",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Documentation {
            const NAME: &'static str = "Documentation";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.structured_docs = is.read_bool()?;
                        },
                        18 => {
                            self.doc_items.push(is.read_string()?);
                        },
                        24 => {
                            self.coverage_complete = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.structured_docs != false {
                    my_size += 1 + 1;
                }
                for value in &self.doc_items {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.coverage_complete != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.structured_docs != false {
                    os.write_bool(1, self.structured_docs)?;
                }
                for v in &self.doc_items {
                    os.write_string(2, &v)?;
                };
                if self.coverage_complete != false {
                    os.write_bool(3, self.coverage_complete)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Documentation {
                Documentation::new()
            }

            fn clear(&mut self) {
                self.structured_docs = false;
                self.doc_items.clear();
                self.coverage_complete = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Documentation {
                static instance: Documentation = Documentation {
                    structured_docs: false,
                    doc_items: ::std::vec::Vec::new(),
                    coverage_complete: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Documentation {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.KymeraPrompt.Documentation").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Documentation {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Documentation {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.RustPrompt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RustPrompt {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.objective)
        pub objective: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.RustPrompt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RustPrompt {
        fn default() -> &'a RustPrompt {
            <RustPrompt as ::protobuf::Message>::default_instance()
        }
    }

    impl RustPrompt {
        pub fn new() -> RustPrompt {
            ::std::default::Default::default()
        }

        // string title = 1;

        pub fn title(&self) -> &str {
            &self.title
        }

        pub fn clear_title(&mut self) {
            self.title.clear();
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            &mut self.title
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.title, ::std::string::String::new())
        }

        // string objective = 2;

        pub fn objective(&self) -> &str {
            &self.objective
        }

        pub fn clear_objective(&mut self) {
            self.objective.clear();
        }

        // Param is passed by value, moved
        pub fn set_objective(&mut self, v: ::std::string::String) {
            self.objective = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_objective(&mut self) -> &mut ::std::string::String {
            &mut self.objective
        }

        // Take field
        pub fn take_objective(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.objective, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &RustPrompt| { &m.title },
                |m: &mut RustPrompt| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "objective",
                |m: &RustPrompt| { &m.objective },
                |m: &mut RustPrompt| { &mut m.objective },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RustPrompt>(
                "LanguageQualityPrompts.RustPrompt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RustPrompt {
        const NAME: &'static str = "RustPrompt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.objective = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.objective.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.objective);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.objective.is_empty() {
                os.write_string(2, &self.objective)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RustPrompt {
            RustPrompt::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.objective.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RustPrompt {
            static instance: RustPrompt = RustPrompt {
                title: ::std::string::String::new(),
                objective: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RustPrompt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.RustPrompt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RustPrompt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RustPrompt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `RustPrompt`
    pub mod rust_prompt {
        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.RustPrompt.ModularityChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ModularityChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ModularityChecks.cargo_updates)
            pub cargo_updates: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ModularityChecks.dependencies)
            pub dependencies: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ModularityChecks.cleanup_complete)
            pub cleanup_complete: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ModularityChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ModularityChecks {
            fn default() -> &'a ModularityChecks {
                <ModularityChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl ModularityChecks {
            pub fn new() -> ModularityChecks {
                ::std::default::Default::default()
            }

            // bool cargo_updates = 1;

            pub fn cargo_updates(&self) -> bool {
                self.cargo_updates
            }

            pub fn clear_cargo_updates(&mut self) {
                self.cargo_updates = false;
            }

            // Param is passed by value, moved
            pub fn set_cargo_updates(&mut self, v: bool) {
                self.cargo_updates = v;
            }

            // repeated string dependencies = 2;

            pub fn dependencies(&self) -> &[::std::string::String] {
                &self.dependencies
            }

            pub fn clear_dependencies(&mut self) {
                self.dependencies.clear();
            }

            // Param is passed by value, moved
            pub fn set_dependencies(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.dependencies = v;
            }

            // Mutable pointer to the field.
            pub fn mut_dependencies(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.dependencies
            }

            // Take field
            pub fn take_dependencies(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.dependencies, ::std::vec::Vec::new())
            }

            // bool cleanup_complete = 3;

            pub fn cleanup_complete(&self) -> bool {
                self.cleanup_complete
            }

            pub fn clear_cleanup_complete(&mut self) {
                self.cleanup_complete = false;
            }

            // Param is passed by value, moved
            pub fn set_cleanup_complete(&mut self, v: bool) {
                self.cleanup_complete = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "cargo_updates",
                    |m: &ModularityChecks| { &m.cargo_updates },
                    |m: &mut ModularityChecks| { &mut m.cargo_updates },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "dependencies",
                    |m: &ModularityChecks| { &m.dependencies },
                    |m: &mut ModularityChecks| { &mut m.dependencies },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "cleanup_complete",
                    |m: &ModularityChecks| { &m.cleanup_complete },
                    |m: &mut ModularityChecks| { &mut m.cleanup_complete },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModularityChecks>(
                    "LanguageQualityPrompts.RustPrompt.ModularityChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ModularityChecks {
            const NAME: &'static str = "ModularityChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.cargo_updates = is.read_bool()?;
                        },
                        18 => {
                            self.dependencies.push(is.read_string()?);
                        },
                        24 => {
                            self.cleanup_complete = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.cargo_updates != false {
                    my_size += 1 + 1;
                }
                for value in &self.dependencies {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.cleanup_complete != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.cargo_updates != false {
                    os.write_bool(1, self.cargo_updates)?;
                }
                for v in &self.dependencies {
                    os.write_string(2, &v)?;
                };
                if self.cleanup_complete != false {
                    os.write_bool(3, self.cleanup_complete)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ModularityChecks {
                ModularityChecks::new()
            }

            fn clear(&mut self) {
                self.cargo_updates = false;
                self.dependencies.clear();
                self.cleanup_complete = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ModularityChecks {
                static instance: ModularityChecks = ModularityChecks {
                    cargo_updates: false,
                    dependencies: ::std::vec::Vec::new(),
                    cleanup_complete: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ModularityChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.RustPrompt.ModularityChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ModularityChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ModularityChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.RustPrompt.ErrorHandling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorHandling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ErrorHandling.custom_errors)
            pub custom_errors: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ErrorHandling.error_patterns)
            pub error_patterns: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ErrorHandling.clarity_achieved)
            pub clarity_achieved: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.RustPrompt.ErrorHandling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorHandling {
            fn default() -> &'a ErrorHandling {
                <ErrorHandling as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorHandling {
            pub fn new() -> ErrorHandling {
                ::std::default::Default::default()
            }

            // bool custom_errors = 1;

            pub fn custom_errors(&self) -> bool {
                self.custom_errors
            }

            pub fn clear_custom_errors(&mut self) {
                self.custom_errors = false;
            }

            // Param is passed by value, moved
            pub fn set_custom_errors(&mut self, v: bool) {
                self.custom_errors = v;
            }

            // repeated string error_patterns = 2;

            pub fn error_patterns(&self) -> &[::std::string::String] {
                &self.error_patterns
            }

            pub fn clear_error_patterns(&mut self) {
                self.error_patterns.clear();
            }

            // Param is passed by value, moved
            pub fn set_error_patterns(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.error_patterns = v;
            }

            // Mutable pointer to the field.
            pub fn mut_error_patterns(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.error_patterns
            }

            // Take field
            pub fn take_error_patterns(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.error_patterns, ::std::vec::Vec::new())
            }

            // bool clarity_achieved = 3;

            pub fn clarity_achieved(&self) -> bool {
                self.clarity_achieved
            }

            pub fn clear_clarity_achieved(&mut self) {
                self.clarity_achieved = false;
            }

            // Param is passed by value, moved
            pub fn set_clarity_achieved(&mut self, v: bool) {
                self.clarity_achieved = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "custom_errors",
                    |m: &ErrorHandling| { &m.custom_errors },
                    |m: &mut ErrorHandling| { &mut m.custom_errors },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "error_patterns",
                    |m: &ErrorHandling| { &m.error_patterns },
                    |m: &mut ErrorHandling| { &mut m.error_patterns },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "clarity_achieved",
                    |m: &ErrorHandling| { &m.clarity_achieved },
                    |m: &mut ErrorHandling| { &mut m.clarity_achieved },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandling>(
                    "LanguageQualityPrompts.RustPrompt.ErrorHandling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorHandling {
            const NAME: &'static str = "ErrorHandling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.custom_errors = is.read_bool()?;
                        },
                        18 => {
                            self.error_patterns.push(is.read_string()?);
                        },
                        24 => {
                            self.clarity_achieved = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.custom_errors != false {
                    my_size += 1 + 1;
                }
                for value in &self.error_patterns {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.clarity_achieved != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.custom_errors != false {
                    os.write_bool(1, self.custom_errors)?;
                }
                for v in &self.error_patterns {
                    os.write_string(2, &v)?;
                };
                if self.clarity_achieved != false {
                    os.write_bool(3, self.clarity_achieved)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorHandling {
                ErrorHandling::new()
            }

            fn clear(&mut self) {
                self.custom_errors = false;
                self.error_patterns.clear();
                self.clarity_achieved = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorHandling {
                static instance: ErrorHandling = ErrorHandling {
                    custom_errors: false,
                    error_patterns: ::std::vec::Vec::new(),
                    clarity_achieved: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorHandling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.RustPrompt.ErrorHandling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorHandling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorHandling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.RustPrompt.Performance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Performance {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.Performance.benchmarks)
            pub benchmarks: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.Performance.optimizations)
            pub optimizations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.RustPrompt.Performance.concurrency)
            pub concurrency: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.RustPrompt.Performance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Performance {
            fn default() -> &'a Performance {
                <Performance as ::protobuf::Message>::default_instance()
            }
        }

        impl Performance {
            pub fn new() -> Performance {
                ::std::default::Default::default()
            }

            // bool benchmarks = 1;

            pub fn benchmarks(&self) -> bool {
                self.benchmarks
            }

            pub fn clear_benchmarks(&mut self) {
                self.benchmarks = false;
            }

            // Param is passed by value, moved
            pub fn set_benchmarks(&mut self, v: bool) {
                self.benchmarks = v;
            }

            // repeated string optimizations = 2;

            pub fn optimizations(&self) -> &[::std::string::String] {
                &self.optimizations
            }

            pub fn clear_optimizations(&mut self) {
                self.optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimizations
            }

            // Take field
            pub fn take_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimizations, ::std::vec::Vec::new())
            }

            // bool concurrency = 3;

            pub fn concurrency(&self) -> bool {
                self.concurrency
            }

            pub fn clear_concurrency(&mut self) {
                self.concurrency = false;
            }

            // Param is passed by value, moved
            pub fn set_concurrency(&mut self, v: bool) {
                self.concurrency = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "benchmarks",
                    |m: &Performance| { &m.benchmarks },
                    |m: &mut Performance| { &mut m.benchmarks },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimizations",
                    |m: &Performance| { &m.optimizations },
                    |m: &mut Performance| { &mut m.optimizations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "concurrency",
                    |m: &Performance| { &m.concurrency },
                    |m: &mut Performance| { &mut m.concurrency },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Performance>(
                    "LanguageQualityPrompts.RustPrompt.Performance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Performance {
            const NAME: &'static str = "Performance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.benchmarks = is.read_bool()?;
                        },
                        18 => {
                            self.optimizations.push(is.read_string()?);
                        },
                        24 => {
                            self.concurrency = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.benchmarks != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimizations {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.concurrency != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.benchmarks != false {
                    os.write_bool(1, self.benchmarks)?;
                }
                for v in &self.optimizations {
                    os.write_string(2, &v)?;
                };
                if self.concurrency != false {
                    os.write_bool(3, self.concurrency)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Performance {
                Performance::new()
            }

            fn clear(&mut self) {
                self.benchmarks = false;
                self.optimizations.clear();
                self.concurrency = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Performance {
                static instance: Performance = Performance {
                    benchmarks: false,
                    optimizations: ::std::vec::Vec::new(),
                    concurrency: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Performance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.RustPrompt.Performance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Performance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Performance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TypeScriptPrompt {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.objective)
        pub objective: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TypeScriptPrompt {
        fn default() -> &'a TypeScriptPrompt {
            <TypeScriptPrompt as ::protobuf::Message>::default_instance()
        }
    }

    impl TypeScriptPrompt {
        pub fn new() -> TypeScriptPrompt {
            ::std::default::Default::default()
        }

        // string title = 1;

        pub fn title(&self) -> &str {
            &self.title
        }

        pub fn clear_title(&mut self) {
            self.title.clear();
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            &mut self.title
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.title, ::std::string::String::new())
        }

        // string objective = 2;

        pub fn objective(&self) -> &str {
            &self.objective
        }

        pub fn clear_objective(&mut self) {
            self.objective.clear();
        }

        // Param is passed by value, moved
        pub fn set_objective(&mut self, v: ::std::string::String) {
            self.objective = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_objective(&mut self) -> &mut ::std::string::String {
            &mut self.objective
        }

        // Take field
        pub fn take_objective(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.objective, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &TypeScriptPrompt| { &m.title },
                |m: &mut TypeScriptPrompt| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "objective",
                |m: &TypeScriptPrompt| { &m.objective },
                |m: &mut TypeScriptPrompt| { &mut m.objective },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeScriptPrompt>(
                "LanguageQualityPrompts.TypeScriptPrompt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TypeScriptPrompt {
        const NAME: &'static str = "TypeScriptPrompt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.objective = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.objective.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.objective);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.objective.is_empty() {
                os.write_string(2, &self.objective)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TypeScriptPrompt {
            TypeScriptPrompt::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.objective.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TypeScriptPrompt {
            static instance: TypeScriptPrompt = TypeScriptPrompt {
                title: ::std::string::String::new(),
                objective: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TypeScriptPrompt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.TypeScriptPrompt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TypeScriptPrompt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TypeScriptPrompt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TypeScriptPrompt`
    pub mod type_script_prompt {
        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.DependencyChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DependencyChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.DependencyChecks.npm_audit)
            pub npm_audit: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.DependencyChecks.vulnerabilities)
            pub vulnerabilities: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.DependencyChecks.deps_updated)
            pub deps_updated: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.DependencyChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DependencyChecks {
            fn default() -> &'a DependencyChecks {
                <DependencyChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl DependencyChecks {
            pub fn new() -> DependencyChecks {
                ::std::default::Default::default()
            }

            // bool npm_audit = 1;

            pub fn npm_audit(&self) -> bool {
                self.npm_audit
            }

            pub fn clear_npm_audit(&mut self) {
                self.npm_audit = false;
            }

            // Param is passed by value, moved
            pub fn set_npm_audit(&mut self, v: bool) {
                self.npm_audit = v;
            }

            // repeated string vulnerabilities = 2;

            pub fn vulnerabilities(&self) -> &[::std::string::String] {
                &self.vulnerabilities
            }

            pub fn clear_vulnerabilities(&mut self) {
                self.vulnerabilities.clear();
            }

            // Param is passed by value, moved
            pub fn set_vulnerabilities(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.vulnerabilities = v;
            }

            // Mutable pointer to the field.
            pub fn mut_vulnerabilities(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.vulnerabilities
            }

            // Take field
            pub fn take_vulnerabilities(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.vulnerabilities, ::std::vec::Vec::new())
            }

            // bool deps_updated = 3;

            pub fn deps_updated(&self) -> bool {
                self.deps_updated
            }

            pub fn clear_deps_updated(&mut self) {
                self.deps_updated = false;
            }

            // Param is passed by value, moved
            pub fn set_deps_updated(&mut self, v: bool) {
                self.deps_updated = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "npm_audit",
                    |m: &DependencyChecks| { &m.npm_audit },
                    |m: &mut DependencyChecks| { &mut m.npm_audit },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "vulnerabilities",
                    |m: &DependencyChecks| { &m.vulnerabilities },
                    |m: &mut DependencyChecks| { &mut m.vulnerabilities },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "deps_updated",
                    |m: &DependencyChecks| { &m.deps_updated },
                    |m: &mut DependencyChecks| { &mut m.deps_updated },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DependencyChecks>(
                    "LanguageQualityPrompts.TypeScriptPrompt.DependencyChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DependencyChecks {
            const NAME: &'static str = "DependencyChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.npm_audit = is.read_bool()?;
                        },
                        18 => {
                            self.vulnerabilities.push(is.read_string()?);
                        },
                        24 => {
                            self.deps_updated = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.npm_audit != false {
                    my_size += 1 + 1;
                }
                for value in &self.vulnerabilities {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.deps_updated != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.npm_audit != false {
                    os.write_bool(1, self.npm_audit)?;
                }
                for v in &self.vulnerabilities {
                    os.write_string(2, &v)?;
                };
                if self.deps_updated != false {
                    os.write_bool(3, self.deps_updated)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DependencyChecks {
                DependencyChecks::new()
            }

            fn clear(&mut self) {
                self.npm_audit = false;
                self.vulnerabilities.clear();
                self.deps_updated = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DependencyChecks {
                static instance: DependencyChecks = DependencyChecks {
                    npm_audit: false,
                    vulnerabilities: ::std::vec::Vec::new(),
                    deps_updated: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DependencyChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.TypeScriptPrompt.DependencyChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DependencyChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DependencyChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.ErrorLogging)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorLogging {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.ErrorLogging.structured)
            pub structured: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.ErrorLogging.error_types)
            pub error_types: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.ErrorLogging.handlers_complete)
            pub handlers_complete: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.ErrorLogging.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorLogging {
            fn default() -> &'a ErrorLogging {
                <ErrorLogging as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorLogging {
            pub fn new() -> ErrorLogging {
                ::std::default::Default::default()
            }

            // bool structured = 1;

            pub fn structured(&self) -> bool {
                self.structured
            }

            pub fn clear_structured(&mut self) {
                self.structured = false;
            }

            // Param is passed by value, moved
            pub fn set_structured(&mut self, v: bool) {
                self.structured = v;
            }

            // repeated string error_types = 2;

            pub fn error_types(&self) -> &[::std::string::String] {
                &self.error_types
            }

            pub fn clear_error_types(&mut self) {
                self.error_types.clear();
            }

            // Param is passed by value, moved
            pub fn set_error_types(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.error_types = v;
            }

            // Mutable pointer to the field.
            pub fn mut_error_types(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.error_types
            }

            // Take field
            pub fn take_error_types(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.error_types, ::std::vec::Vec::new())
            }

            // bool handlers_complete = 3;

            pub fn handlers_complete(&self) -> bool {
                self.handlers_complete
            }

            pub fn clear_handlers_complete(&mut self) {
                self.handlers_complete = false;
            }

            // Param is passed by value, moved
            pub fn set_handlers_complete(&mut self, v: bool) {
                self.handlers_complete = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "structured",
                    |m: &ErrorLogging| { &m.structured },
                    |m: &mut ErrorLogging| { &mut m.structured },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "error_types",
                    |m: &ErrorLogging| { &m.error_types },
                    |m: &mut ErrorLogging| { &mut m.error_types },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "handlers_complete",
                    |m: &ErrorLogging| { &m.handlers_complete },
                    |m: &mut ErrorLogging| { &mut m.handlers_complete },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorLogging>(
                    "LanguageQualityPrompts.TypeScriptPrompt.ErrorLogging",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorLogging {
            const NAME: &'static str = "ErrorLogging";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.structured = is.read_bool()?;
                        },
                        18 => {
                            self.error_types.push(is.read_string()?);
                        },
                        24 => {
                            self.handlers_complete = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.structured != false {
                    my_size += 1 + 1;
                }
                for value in &self.error_types {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.handlers_complete != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.structured != false {
                    os.write_bool(1, self.structured)?;
                }
                for v in &self.error_types {
                    os.write_string(2, &v)?;
                };
                if self.handlers_complete != false {
                    os.write_bool(3, self.handlers_complete)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorLogging {
                ErrorLogging::new()
            }

            fn clear(&mut self) {
                self.structured = false;
                self.error_types.clear();
                self.handlers_complete = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorLogging {
                static instance: ErrorLogging = ErrorLogging {
                    structured: false,
                    error_types: ::std::vec::Vec::new(),
                    handlers_complete: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorLogging {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.TypeScriptPrompt.ErrorLogging").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorLogging {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorLogging {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.Performance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Performance {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.Performance.profiling)
            pub profiling: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.Performance.optimizations)
            pub optimizations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.Performance.critical_paths)
            pub critical_paths: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.TypeScriptPrompt.Performance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Performance {
            fn default() -> &'a Performance {
                <Performance as ::protobuf::Message>::default_instance()
            }
        }

        impl Performance {
            pub fn new() -> Performance {
                ::std::default::Default::default()
            }

            // bool profiling = 1;

            pub fn profiling(&self) -> bool {
                self.profiling
            }

            pub fn clear_profiling(&mut self) {
                self.profiling = false;
            }

            // Param is passed by value, moved
            pub fn set_profiling(&mut self, v: bool) {
                self.profiling = v;
            }

            // repeated string optimizations = 2;

            pub fn optimizations(&self) -> &[::std::string::String] {
                &self.optimizations
            }

            pub fn clear_optimizations(&mut self) {
                self.optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimizations
            }

            // Take field
            pub fn take_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimizations, ::std::vec::Vec::new())
            }

            // bool critical_paths = 3;

            pub fn critical_paths(&self) -> bool {
                self.critical_paths
            }

            pub fn clear_critical_paths(&mut self) {
                self.critical_paths = false;
            }

            // Param is passed by value, moved
            pub fn set_critical_paths(&mut self, v: bool) {
                self.critical_paths = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "profiling",
                    |m: &Performance| { &m.profiling },
                    |m: &mut Performance| { &mut m.profiling },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimizations",
                    |m: &Performance| { &m.optimizations },
                    |m: &mut Performance| { &mut m.optimizations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "critical_paths",
                    |m: &Performance| { &m.critical_paths },
                    |m: &mut Performance| { &mut m.critical_paths },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Performance>(
                    "LanguageQualityPrompts.TypeScriptPrompt.Performance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Performance {
            const NAME: &'static str = "Performance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.profiling = is.read_bool()?;
                        },
                        18 => {
                            self.optimizations.push(is.read_string()?);
                        },
                        24 => {
                            self.critical_paths = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.profiling != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimizations {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.critical_paths != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.profiling != false {
                    os.write_bool(1, self.profiling)?;
                }
                for v in &self.optimizations {
                    os.write_string(2, &v)?;
                };
                if self.critical_paths != false {
                    os.write_bool(3, self.critical_paths)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Performance {
                Performance::new()
            }

            fn clear(&mut self) {
                self.profiling = false;
                self.optimizations.clear();
                self.critical_paths = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Performance {
                static instance: Performance = Performance {
                    profiling: false,
                    optimizations: ::std::vec::Vec::new(),
                    critical_paths: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Performance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.TypeScriptPrompt.Performance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Performance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Performance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.PythonPrompt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PythonPrompt {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.objective)
        pub objective: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PythonPrompt {
        fn default() -> &'a PythonPrompt {
            <PythonPrompt as ::protobuf::Message>::default_instance()
        }
    }

    impl PythonPrompt {
        pub fn new() -> PythonPrompt {
            ::std::default::Default::default()
        }

        // string title = 1;

        pub fn title(&self) -> &str {
            &self.title
        }

        pub fn clear_title(&mut self) {
            self.title.clear();
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            &mut self.title
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.title, ::std::string::String::new())
        }

        // string objective = 2;

        pub fn objective(&self) -> &str {
            &self.objective
        }

        pub fn clear_objective(&mut self) {
            self.objective.clear();
        }

        // Param is passed by value, moved
        pub fn set_objective(&mut self, v: ::std::string::String) {
            self.objective = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_objective(&mut self) -> &mut ::std::string::String {
            &mut self.objective
        }

        // Take field
        pub fn take_objective(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.objective, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &PythonPrompt| { &m.title },
                |m: &mut PythonPrompt| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "objective",
                |m: &PythonPrompt| { &m.objective },
                |m: &mut PythonPrompt| { &mut m.objective },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PythonPrompt>(
                "LanguageQualityPrompts.PythonPrompt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PythonPrompt {
        const NAME: &'static str = "PythonPrompt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.objective = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.objective.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.objective);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.objective.is_empty() {
                os.write_string(2, &self.objective)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PythonPrompt {
            PythonPrompt::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.objective.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PythonPrompt {
            static instance: PythonPrompt = PythonPrompt {
                title: ::std::string::String::new(),
                objective: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PythonPrompt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.PythonPrompt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PythonPrompt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PythonPrompt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `PythonPrompt`
    pub mod python_prompt {
        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.PythonPrompt.DependencyChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DependencyChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.DependencyChecks.requirements)
            pub requirements: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.DependencyChecks.deps)
            pub deps: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.DependencyChecks.pip_updated)
            pub pip_updated: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.DependencyChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DependencyChecks {
            fn default() -> &'a DependencyChecks {
                <DependencyChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl DependencyChecks {
            pub fn new() -> DependencyChecks {
                ::std::default::Default::default()
            }

            // bool requirements = 1;

            pub fn requirements(&self) -> bool {
                self.requirements
            }

            pub fn clear_requirements(&mut self) {
                self.requirements = false;
            }

            // Param is passed by value, moved
            pub fn set_requirements(&mut self, v: bool) {
                self.requirements = v;
            }

            // repeated string deps = 2;

            pub fn deps(&self) -> &[::std::string::String] {
                &self.deps
            }

            pub fn clear_deps(&mut self) {
                self.deps.clear();
            }

            // Param is passed by value, moved
            pub fn set_deps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.deps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_deps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.deps
            }

            // Take field
            pub fn take_deps(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.deps, ::std::vec::Vec::new())
            }

            // bool pip_updated = 3;

            pub fn pip_updated(&self) -> bool {
                self.pip_updated
            }

            pub fn clear_pip_updated(&mut self) {
                self.pip_updated = false;
            }

            // Param is passed by value, moved
            pub fn set_pip_updated(&mut self, v: bool) {
                self.pip_updated = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "requirements",
                    |m: &DependencyChecks| { &m.requirements },
                    |m: &mut DependencyChecks| { &mut m.requirements },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "deps",
                    |m: &DependencyChecks| { &m.deps },
                    |m: &mut DependencyChecks| { &mut m.deps },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "pip_updated",
                    |m: &DependencyChecks| { &m.pip_updated },
                    |m: &mut DependencyChecks| { &mut m.pip_updated },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DependencyChecks>(
                    "LanguageQualityPrompts.PythonPrompt.DependencyChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DependencyChecks {
            const NAME: &'static str = "DependencyChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.requirements = is.read_bool()?;
                        },
                        18 => {
                            self.deps.push(is.read_string()?);
                        },
                        24 => {
                            self.pip_updated = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.requirements != false {
                    my_size += 1 + 1;
                }
                for value in &self.deps {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.pip_updated != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.requirements != false {
                    os.write_bool(1, self.requirements)?;
                }
                for v in &self.deps {
                    os.write_string(2, &v)?;
                };
                if self.pip_updated != false {
                    os.write_bool(3, self.pip_updated)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DependencyChecks {
                DependencyChecks::new()
            }

            fn clear(&mut self) {
                self.requirements = false;
                self.deps.clear();
                self.pip_updated = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DependencyChecks {
                static instance: DependencyChecks = DependencyChecks {
                    requirements: false,
                    deps: ::std::vec::Vec::new(),
                    pip_updated: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DependencyChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.PythonPrompt.DependencyChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DependencyChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DependencyChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.PythonPrompt.ErrorHandling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorHandling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.ErrorHandling.logging)
            pub logging: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.ErrorHandling.handlers)
            pub handlers: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.ErrorHandling.exceptions)
            pub exceptions: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.ErrorHandling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorHandling {
            fn default() -> &'a ErrorHandling {
                <ErrorHandling as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorHandling {
            pub fn new() -> ErrorHandling {
                ::std::default::Default::default()
            }

            // bool logging = 1;

            pub fn logging(&self) -> bool {
                self.logging
            }

            pub fn clear_logging(&mut self) {
                self.logging = false;
            }

            // Param is passed by value, moved
            pub fn set_logging(&mut self, v: bool) {
                self.logging = v;
            }

            // repeated string handlers = 2;

            pub fn handlers(&self) -> &[::std::string::String] {
                &self.handlers
            }

            pub fn clear_handlers(&mut self) {
                self.handlers.clear();
            }

            // Param is passed by value, moved
            pub fn set_handlers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.handlers = v;
            }

            // Mutable pointer to the field.
            pub fn mut_handlers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.handlers
            }

            // Take field
            pub fn take_handlers(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.handlers, ::std::vec::Vec::new())
            }

            // bool exceptions = 3;

            pub fn exceptions(&self) -> bool {
                self.exceptions
            }

            pub fn clear_exceptions(&mut self) {
                self.exceptions = false;
            }

            // Param is passed by value, moved
            pub fn set_exceptions(&mut self, v: bool) {
                self.exceptions = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "logging",
                    |m: &ErrorHandling| { &m.logging },
                    |m: &mut ErrorHandling| { &mut m.logging },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "handlers",
                    |m: &ErrorHandling| { &m.handlers },
                    |m: &mut ErrorHandling| { &mut m.handlers },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "exceptions",
                    |m: &ErrorHandling| { &m.exceptions },
                    |m: &mut ErrorHandling| { &mut m.exceptions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandling>(
                    "LanguageQualityPrompts.PythonPrompt.ErrorHandling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorHandling {
            const NAME: &'static str = "ErrorHandling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.logging = is.read_bool()?;
                        },
                        18 => {
                            self.handlers.push(is.read_string()?);
                        },
                        24 => {
                            self.exceptions = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.logging != false {
                    my_size += 1 + 1;
                }
                for value in &self.handlers {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.exceptions != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.logging != false {
                    os.write_bool(1, self.logging)?;
                }
                for v in &self.handlers {
                    os.write_string(2, &v)?;
                };
                if self.exceptions != false {
                    os.write_bool(3, self.exceptions)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorHandling {
                ErrorHandling::new()
            }

            fn clear(&mut self) {
                self.logging = false;
                self.handlers.clear();
                self.exceptions = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorHandling {
                static instance: ErrorHandling = ErrorHandling {
                    logging: false,
                    handlers: ::std::vec::Vec::new(),
                    exceptions: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorHandling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.PythonPrompt.ErrorHandling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorHandling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorHandling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.PythonPrompt.Performance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Performance {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.Performance.profiling)
            pub profiling: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.Performance.optimizations)
            pub optimizations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.Performance.expressions)
            pub expressions: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.PythonPrompt.Performance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Performance {
            fn default() -> &'a Performance {
                <Performance as ::protobuf::Message>::default_instance()
            }
        }

        impl Performance {
            pub fn new() -> Performance {
                ::std::default::Default::default()
            }

            // bool profiling = 1;

            pub fn profiling(&self) -> bool {
                self.profiling
            }

            pub fn clear_profiling(&mut self) {
                self.profiling = false;
            }

            // Param is passed by value, moved
            pub fn set_profiling(&mut self, v: bool) {
                self.profiling = v;
            }

            // repeated string optimizations = 2;

            pub fn optimizations(&self) -> &[::std::string::String] {
                &self.optimizations
            }

            pub fn clear_optimizations(&mut self) {
                self.optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimizations
            }

            // Take field
            pub fn take_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimizations, ::std::vec::Vec::new())
            }

            // bool expressions = 3;

            pub fn expressions(&self) -> bool {
                self.expressions
            }

            pub fn clear_expressions(&mut self) {
                self.expressions = false;
            }

            // Param is passed by value, moved
            pub fn set_expressions(&mut self, v: bool) {
                self.expressions = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "profiling",
                    |m: &Performance| { &m.profiling },
                    |m: &mut Performance| { &mut m.profiling },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimizations",
                    |m: &Performance| { &m.optimizations },
                    |m: &mut Performance| { &mut m.optimizations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "expressions",
                    |m: &Performance| { &m.expressions },
                    |m: &mut Performance| { &mut m.expressions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Performance>(
                    "LanguageQualityPrompts.PythonPrompt.Performance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Performance {
            const NAME: &'static str = "Performance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.profiling = is.read_bool()?;
                        },
                        18 => {
                            self.optimizations.push(is.read_string()?);
                        },
                        24 => {
                            self.expressions = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.profiling != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimizations {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.expressions != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.profiling != false {
                    os.write_bool(1, self.profiling)?;
                }
                for v in &self.optimizations {
                    os.write_string(2, &v)?;
                };
                if self.expressions != false {
                    os.write_bool(3, self.expressions)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Performance {
                Performance::new()
            }

            fn clear(&mut self) {
                self.profiling = false;
                self.optimizations.clear();
                self.expressions = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Performance {
                static instance: Performance = Performance {
                    profiling: false,
                    optimizations: ::std::vec::Vec::new(),
                    expressions: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Performance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.PythonPrompt.Performance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Performance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Performance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ProtobufPrompt {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.objective)
        pub objective: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ProtobufPrompt {
        fn default() -> &'a ProtobufPrompt {
            <ProtobufPrompt as ::protobuf::Message>::default_instance()
        }
    }

    impl ProtobufPrompt {
        pub fn new() -> ProtobufPrompt {
            ::std::default::Default::default()
        }

        // string title = 1;

        pub fn title(&self) -> &str {
            &self.title
        }

        pub fn clear_title(&mut self) {
            self.title.clear();
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            &mut self.title
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.title, ::std::string::String::new())
        }

        // string objective = 2;

        pub fn objective(&self) -> &str {
            &self.objective
        }

        pub fn clear_objective(&mut self) {
            self.objective.clear();
        }

        // Param is passed by value, moved
        pub fn set_objective(&mut self, v: ::std::string::String) {
            self.objective = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_objective(&mut self) -> &mut ::std::string::String {
            &mut self.objective
        }

        // Take field
        pub fn take_objective(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.objective, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &ProtobufPrompt| { &m.title },
                |m: &mut ProtobufPrompt| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "objective",
                |m: &ProtobufPrompt| { &m.objective },
                |m: &mut ProtobufPrompt| { &mut m.objective },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtobufPrompt>(
                "LanguageQualityPrompts.ProtobufPrompt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ProtobufPrompt {
        const NAME: &'static str = "ProtobufPrompt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.objective = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.objective.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.objective);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.objective.is_empty() {
                os.write_string(2, &self.objective)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ProtobufPrompt {
            ProtobufPrompt::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.objective.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ProtobufPrompt {
            static instance: ProtobufPrompt = ProtobufPrompt {
                title: ::std::string::String::new(),
                objective: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ProtobufPrompt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.ProtobufPrompt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ProtobufPrompt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ProtobufPrompt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ProtobufPrompt`
    pub mod protobuf_prompt {
        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.SchemaChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct SchemaChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.SchemaChecks.organization)
            pub organization: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.SchemaChecks.messages)
            pub messages: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.SchemaChecks.numeric_ordering)
            pub numeric_ordering: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.SchemaChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a SchemaChecks {
            fn default() -> &'a SchemaChecks {
                <SchemaChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl SchemaChecks {
            pub fn new() -> SchemaChecks {
                ::std::default::Default::default()
            }

            // bool organization = 1;

            pub fn organization(&self) -> bool {
                self.organization
            }

            pub fn clear_organization(&mut self) {
                self.organization = false;
            }

            // Param is passed by value, moved
            pub fn set_organization(&mut self, v: bool) {
                self.organization = v;
            }

            // repeated string messages = 2;

            pub fn messages(&self) -> &[::std::string::String] {
                &self.messages
            }

            pub fn clear_messages(&mut self) {
                self.messages.clear();
            }

            // Param is passed by value, moved
            pub fn set_messages(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.messages = v;
            }

            // Mutable pointer to the field.
            pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.messages
            }

            // Take field
            pub fn take_messages(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
            }

            // bool numeric_ordering = 3;

            pub fn numeric_ordering(&self) -> bool {
                self.numeric_ordering
            }

            pub fn clear_numeric_ordering(&mut self) {
                self.numeric_ordering = false;
            }

            // Param is passed by value, moved
            pub fn set_numeric_ordering(&mut self, v: bool) {
                self.numeric_ordering = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "organization",
                    |m: &SchemaChecks| { &m.organization },
                    |m: &mut SchemaChecks| { &mut m.organization },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "messages",
                    |m: &SchemaChecks| { &m.messages },
                    |m: &mut SchemaChecks| { &mut m.messages },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "numeric_ordering",
                    |m: &SchemaChecks| { &m.numeric_ordering },
                    |m: &mut SchemaChecks| { &mut m.numeric_ordering },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SchemaChecks>(
                    "LanguageQualityPrompts.ProtobufPrompt.SchemaChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for SchemaChecks {
            const NAME: &'static str = "SchemaChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.organization = is.read_bool()?;
                        },
                        18 => {
                            self.messages.push(is.read_string()?);
                        },
                        24 => {
                            self.numeric_ordering = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.organization != false {
                    my_size += 1 + 1;
                }
                for value in &self.messages {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.numeric_ordering != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.organization != false {
                    os.write_bool(1, self.organization)?;
                }
                for v in &self.messages {
                    os.write_string(2, &v)?;
                };
                if self.numeric_ordering != false {
                    os.write_bool(3, self.numeric_ordering)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> SchemaChecks {
                SchemaChecks::new()
            }

            fn clear(&mut self) {
                self.organization = false;
                self.messages.clear();
                self.numeric_ordering = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static SchemaChecks {
                static instance: SchemaChecks = SchemaChecks {
                    organization: false,
                    messages: ::std::vec::Vec::new(),
                    numeric_ordering: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for SchemaChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.ProtobufPrompt.SchemaChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for SchemaChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for SchemaChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.ErrorHandling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorHandling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.ErrorHandling.validation)
            pub validation: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.ErrorHandling.handling)
            pub handling: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.ErrorHandling.definitions)
            pub definitions: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.ErrorHandling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorHandling {
            fn default() -> &'a ErrorHandling {
                <ErrorHandling as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorHandling {
            pub fn new() -> ErrorHandling {
                ::std::default::Default::default()
            }

            // bool validation = 1;

            pub fn validation(&self) -> bool {
                self.validation
            }

            pub fn clear_validation(&mut self) {
                self.validation = false;
            }

            // Param is passed by value, moved
            pub fn set_validation(&mut self, v: bool) {
                self.validation = v;
            }

            // repeated string handling = 2;

            pub fn handling(&self) -> &[::std::string::String] {
                &self.handling
            }

            pub fn clear_handling(&mut self) {
                self.handling.clear();
            }

            // Param is passed by value, moved
            pub fn set_handling(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.handling = v;
            }

            // Mutable pointer to the field.
            pub fn mut_handling(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.handling
            }

            // Take field
            pub fn take_handling(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.handling, ::std::vec::Vec::new())
            }

            // bool definitions = 3;

            pub fn definitions(&self) -> bool {
                self.definitions
            }

            pub fn clear_definitions(&mut self) {
                self.definitions = false;
            }

            // Param is passed by value, moved
            pub fn set_definitions(&mut self, v: bool) {
                self.definitions = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "validation",
                    |m: &ErrorHandling| { &m.validation },
                    |m: &mut ErrorHandling| { &mut m.validation },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "handling",
                    |m: &ErrorHandling| { &m.handling },
                    |m: &mut ErrorHandling| { &mut m.handling },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "definitions",
                    |m: &ErrorHandling| { &m.definitions },
                    |m: &mut ErrorHandling| { &mut m.definitions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandling>(
                    "LanguageQualityPrompts.ProtobufPrompt.ErrorHandling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorHandling {
            const NAME: &'static str = "ErrorHandling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.validation = is.read_bool()?;
                        },
                        18 => {
                            self.handling.push(is.read_string()?);
                        },
                        24 => {
                            self.definitions = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.validation != false {
                    my_size += 1 + 1;
                }
                for value in &self.handling {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.definitions != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.validation != false {
                    os.write_bool(1, self.validation)?;
                }
                for v in &self.handling {
                    os.write_string(2, &v)?;
                };
                if self.definitions != false {
                    os.write_bool(3, self.definitions)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorHandling {
                ErrorHandling::new()
            }

            fn clear(&mut self) {
                self.validation = false;
                self.handling.clear();
                self.definitions = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorHandling {
                static instance: ErrorHandling = ErrorHandling {
                    validation: false,
                    handling: ::std::vec::Vec::new(),
                    definitions: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorHandling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.ProtobufPrompt.ErrorHandling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorHandling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorHandling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.Performance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Performance {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.Performance.repeated)
            pub repeated: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.Performance.compatibility)
            pub compatibility: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.Performance.field_numbering)
            pub field_numbering: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.ProtobufPrompt.Performance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Performance {
            fn default() -> &'a Performance {
                <Performance as ::protobuf::Message>::default_instance()
            }
        }

        impl Performance {
            pub fn new() -> Performance {
                ::std::default::Default::default()
            }

            // bool repeated = 1;

            pub fn repeated(&self) -> bool {
                self.repeated
            }

            pub fn clear_repeated(&mut self) {
                self.repeated = false;
            }

            // Param is passed by value, moved
            pub fn set_repeated(&mut self, v: bool) {
                self.repeated = v;
            }

            // repeated string compatibility = 2;

            pub fn compatibility(&self) -> &[::std::string::String] {
                &self.compatibility
            }

            pub fn clear_compatibility(&mut self) {
                self.compatibility.clear();
            }

            // Param is passed by value, moved
            pub fn set_compatibility(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.compatibility = v;
            }

            // Mutable pointer to the field.
            pub fn mut_compatibility(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.compatibility
            }

            // Take field
            pub fn take_compatibility(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.compatibility, ::std::vec::Vec::new())
            }

            // bool field_numbering = 3;

            pub fn field_numbering(&self) -> bool {
                self.field_numbering
            }

            pub fn clear_field_numbering(&mut self) {
                self.field_numbering = false;
            }

            // Param is passed by value, moved
            pub fn set_field_numbering(&mut self, v: bool) {
                self.field_numbering = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "repeated",
                    |m: &Performance| { &m.repeated },
                    |m: &mut Performance| { &mut m.repeated },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "compatibility",
                    |m: &Performance| { &m.compatibility },
                    |m: &mut Performance| { &mut m.compatibility },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "field_numbering",
                    |m: &Performance| { &m.field_numbering },
                    |m: &mut Performance| { &mut m.field_numbering },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Performance>(
                    "LanguageQualityPrompts.ProtobufPrompt.Performance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Performance {
            const NAME: &'static str = "Performance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.repeated = is.read_bool()?;
                        },
                        18 => {
                            self.compatibility.push(is.read_string()?);
                        },
                        24 => {
                            self.field_numbering = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.repeated != false {
                    my_size += 1 + 1;
                }
                for value in &self.compatibility {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.field_numbering != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.repeated != false {
                    os.write_bool(1, self.repeated)?;
                }
                for v in &self.compatibility {
                    os.write_string(2, &v)?;
                };
                if self.field_numbering != false {
                    os.write_bool(3, self.field_numbering)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Performance {
                Performance::new()
            }

            fn clear(&mut self) {
                self.repeated = false;
                self.compatibility.clear();
                self.field_numbering = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Performance {
                static instance: Performance = Performance {
                    repeated: false,
                    compatibility: ::std::vec::Vec::new(),
                    field_numbering: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Performance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.ProtobufPrompt.Performance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Performance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Performance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct JavaScriptPrompt {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.objective)
        pub objective: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a JavaScriptPrompt {
        fn default() -> &'a JavaScriptPrompt {
            <JavaScriptPrompt as ::protobuf::Message>::default_instance()
        }
    }

    impl JavaScriptPrompt {
        pub fn new() -> JavaScriptPrompt {
            ::std::default::Default::default()
        }

        // string title = 1;

        pub fn title(&self) -> &str {
            &self.title
        }

        pub fn clear_title(&mut self) {
            self.title.clear();
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            &mut self.title
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.title, ::std::string::String::new())
        }

        // string objective = 2;

        pub fn objective(&self) -> &str {
            &self.objective
        }

        pub fn clear_objective(&mut self) {
            self.objective.clear();
        }

        // Param is passed by value, moved
        pub fn set_objective(&mut self, v: ::std::string::String) {
            self.objective = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_objective(&mut self) -> &mut ::std::string::String {
            &mut self.objective
        }

        // Take field
        pub fn take_objective(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.objective, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &JavaScriptPrompt| { &m.title },
                |m: &mut JavaScriptPrompt| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "objective",
                |m: &JavaScriptPrompt| { &m.objective },
                |m: &mut JavaScriptPrompt| { &mut m.objective },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JavaScriptPrompt>(
                "LanguageQualityPrompts.JavaScriptPrompt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for JavaScriptPrompt {
        const NAME: &'static str = "JavaScriptPrompt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.objective = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.objective.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.objective);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.objective.is_empty() {
                os.write_string(2, &self.objective)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> JavaScriptPrompt {
            JavaScriptPrompt::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.objective.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static JavaScriptPrompt {
            static instance: JavaScriptPrompt = JavaScriptPrompt {
                title: ::std::string::String::new(),
                objective: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for JavaScriptPrompt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.JavaScriptPrompt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for JavaScriptPrompt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for JavaScriptPrompt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `JavaScriptPrompt`
    pub mod java_script_prompt {
        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.DependencyChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DependencyChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.DependencyChecks.organization)
            pub organization: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.DependencyChecks.deps)
            pub deps: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.DependencyChecks.npm_audit)
            pub npm_audit: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.DependencyChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DependencyChecks {
            fn default() -> &'a DependencyChecks {
                <DependencyChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl DependencyChecks {
            pub fn new() -> DependencyChecks {
                ::std::default::Default::default()
            }

            // bool organization = 1;

            pub fn organization(&self) -> bool {
                self.organization
            }

            pub fn clear_organization(&mut self) {
                self.organization = false;
            }

            // Param is passed by value, moved
            pub fn set_organization(&mut self, v: bool) {
                self.organization = v;
            }

            // repeated string deps = 2;

            pub fn deps(&self) -> &[::std::string::String] {
                &self.deps
            }

            pub fn clear_deps(&mut self) {
                self.deps.clear();
            }

            // Param is passed by value, moved
            pub fn set_deps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.deps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_deps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.deps
            }

            // Take field
            pub fn take_deps(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.deps, ::std::vec::Vec::new())
            }

            // bool npm_audit = 3;

            pub fn npm_audit(&self) -> bool {
                self.npm_audit
            }

            pub fn clear_npm_audit(&mut self) {
                self.npm_audit = false;
            }

            // Param is passed by value, moved
            pub fn set_npm_audit(&mut self, v: bool) {
                self.npm_audit = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "organization",
                    |m: &DependencyChecks| { &m.organization },
                    |m: &mut DependencyChecks| { &mut m.organization },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "deps",
                    |m: &DependencyChecks| { &m.deps },
                    |m: &mut DependencyChecks| { &mut m.deps },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "npm_audit",
                    |m: &DependencyChecks| { &m.npm_audit },
                    |m: &mut DependencyChecks| { &mut m.npm_audit },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DependencyChecks>(
                    "LanguageQualityPrompts.JavaScriptPrompt.DependencyChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for DependencyChecks {
            const NAME: &'static str = "DependencyChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.organization = is.read_bool()?;
                        },
                        18 => {
                            self.deps.push(is.read_string()?);
                        },
                        24 => {
                            self.npm_audit = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.organization != false {
                    my_size += 1 + 1;
                }
                for value in &self.deps {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.npm_audit != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.organization != false {
                    os.write_bool(1, self.organization)?;
                }
                for v in &self.deps {
                    os.write_string(2, &v)?;
                };
                if self.npm_audit != false {
                    os.write_bool(3, self.npm_audit)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DependencyChecks {
                DependencyChecks::new()
            }

            fn clear(&mut self) {
                self.organization = false;
                self.deps.clear();
                self.npm_audit = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DependencyChecks {
                static instance: DependencyChecks = DependencyChecks {
                    organization: false,
                    deps: ::std::vec::Vec::new(),
                    npm_audit: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for DependencyChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.JavaScriptPrompt.DependencyChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DependencyChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for DependencyChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.ErrorHandling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorHandling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.ErrorHandling.try_catch)
            pub try_catch: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.ErrorHandling.handlers)
            pub handlers: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.ErrorHandling.logging)
            pub logging: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.ErrorHandling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorHandling {
            fn default() -> &'a ErrorHandling {
                <ErrorHandling as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorHandling {
            pub fn new() -> ErrorHandling {
                ::std::default::Default::default()
            }

            // bool try_catch = 1;

            pub fn try_catch(&self) -> bool {
                self.try_catch
            }

            pub fn clear_try_catch(&mut self) {
                self.try_catch = false;
            }

            // Param is passed by value, moved
            pub fn set_try_catch(&mut self, v: bool) {
                self.try_catch = v;
            }

            // repeated string handlers = 2;

            pub fn handlers(&self) -> &[::std::string::String] {
                &self.handlers
            }

            pub fn clear_handlers(&mut self) {
                self.handlers.clear();
            }

            // Param is passed by value, moved
            pub fn set_handlers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.handlers = v;
            }

            // Mutable pointer to the field.
            pub fn mut_handlers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.handlers
            }

            // Take field
            pub fn take_handlers(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.handlers, ::std::vec::Vec::new())
            }

            // bool logging = 3;

            pub fn logging(&self) -> bool {
                self.logging
            }

            pub fn clear_logging(&mut self) {
                self.logging = false;
            }

            // Param is passed by value, moved
            pub fn set_logging(&mut self, v: bool) {
                self.logging = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "try_catch",
                    |m: &ErrorHandling| { &m.try_catch },
                    |m: &mut ErrorHandling| { &mut m.try_catch },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "handlers",
                    |m: &ErrorHandling| { &m.handlers },
                    |m: &mut ErrorHandling| { &mut m.handlers },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "logging",
                    |m: &ErrorHandling| { &m.logging },
                    |m: &mut ErrorHandling| { &mut m.logging },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandling>(
                    "LanguageQualityPrompts.JavaScriptPrompt.ErrorHandling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorHandling {
            const NAME: &'static str = "ErrorHandling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.try_catch = is.read_bool()?;
                        },
                        18 => {
                            self.handlers.push(is.read_string()?);
                        },
                        24 => {
                            self.logging = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.try_catch != false {
                    my_size += 1 + 1;
                }
                for value in &self.handlers {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.logging != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.try_catch != false {
                    os.write_bool(1, self.try_catch)?;
                }
                for v in &self.handlers {
                    os.write_string(2, &v)?;
                };
                if self.logging != false {
                    os.write_bool(3, self.logging)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorHandling {
                ErrorHandling::new()
            }

            fn clear(&mut self) {
                self.try_catch = false;
                self.handlers.clear();
                self.logging = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorHandling {
                static instance: ErrorHandling = ErrorHandling {
                    try_catch: false,
                    handlers: ::std::vec::Vec::new(),
                    logging: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorHandling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.JavaScriptPrompt.ErrorHandling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorHandling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorHandling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.Performance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Performance {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.Performance.profiling)
            pub profiling: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.Performance.optimizations)
            pub optimizations: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.Performance.memory)
            pub memory: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.JavaScriptPrompt.Performance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Performance {
            fn default() -> &'a Performance {
                <Performance as ::protobuf::Message>::default_instance()
            }
        }

        impl Performance {
            pub fn new() -> Performance {
                ::std::default::Default::default()
            }

            // bool profiling = 1;

            pub fn profiling(&self) -> bool {
                self.profiling
            }

            pub fn clear_profiling(&mut self) {
                self.profiling = false;
            }

            // Param is passed by value, moved
            pub fn set_profiling(&mut self, v: bool) {
                self.profiling = v;
            }

            // repeated string optimizations = 2;

            pub fn optimizations(&self) -> &[::std::string::String] {
                &self.optimizations
            }

            pub fn clear_optimizations(&mut self) {
                self.optimizations.clear();
            }

            // Param is passed by value, moved
            pub fn set_optimizations(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.optimizations = v;
            }

            // Mutable pointer to the field.
            pub fn mut_optimizations(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.optimizations
            }

            // Take field
            pub fn take_optimizations(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.optimizations, ::std::vec::Vec::new())
            }

            // bool memory = 3;

            pub fn memory(&self) -> bool {
                self.memory
            }

            pub fn clear_memory(&mut self) {
                self.memory = false;
            }

            // Param is passed by value, moved
            pub fn set_memory(&mut self, v: bool) {
                self.memory = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "profiling",
                    |m: &Performance| { &m.profiling },
                    |m: &mut Performance| { &mut m.profiling },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "optimizations",
                    |m: &Performance| { &m.optimizations },
                    |m: &mut Performance| { &mut m.optimizations },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "memory",
                    |m: &Performance| { &m.memory },
                    |m: &mut Performance| { &mut m.memory },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Performance>(
                    "LanguageQualityPrompts.JavaScriptPrompt.Performance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Performance {
            const NAME: &'static str = "Performance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.profiling = is.read_bool()?;
                        },
                        18 => {
                            self.optimizations.push(is.read_string()?);
                        },
                        24 => {
                            self.memory = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.profiling != false {
                    my_size += 1 + 1;
                }
                for value in &self.optimizations {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.memory != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.profiling != false {
                    os.write_bool(1, self.profiling)?;
                }
                for v in &self.optimizations {
                    os.write_string(2, &v)?;
                };
                if self.memory != false {
                    os.write_bool(3, self.memory)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Performance {
                Performance::new()
            }

            fn clear(&mut self) {
                self.profiling = false;
                self.optimizations.clear();
                self.memory = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Performance {
                static instance: Performance = Performance {
                    profiling: false,
                    optimizations: ::std::vec::Vec::new(),
                    memory: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Performance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.JavaScriptPrompt.Performance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Performance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Performance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AgnosticPrompt {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.title)
        pub title: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.objective)
        pub objective: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AgnosticPrompt {
        fn default() -> &'a AgnosticPrompt {
            <AgnosticPrompt as ::protobuf::Message>::default_instance()
        }
    }

    impl AgnosticPrompt {
        pub fn new() -> AgnosticPrompt {
            ::std::default::Default::default()
        }

        // string title = 1;

        pub fn title(&self) -> &str {
            &self.title
        }

        pub fn clear_title(&mut self) {
            self.title.clear();
        }

        // Param is passed by value, moved
        pub fn set_title(&mut self, v: ::std::string::String) {
            self.title = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_title(&mut self) -> &mut ::std::string::String {
            &mut self.title
        }

        // Take field
        pub fn take_title(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.title, ::std::string::String::new())
        }

        // string objective = 2;

        pub fn objective(&self) -> &str {
            &self.objective
        }

        pub fn clear_objective(&mut self) {
            self.objective.clear();
        }

        // Param is passed by value, moved
        pub fn set_objective(&mut self, v: ::std::string::String) {
            self.objective = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_objective(&mut self) -> &mut ::std::string::String {
            &mut self.objective
        }

        // Take field
        pub fn take_objective(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.objective, ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "title",
                |m: &AgnosticPrompt| { &m.title },
                |m: &mut AgnosticPrompt| { &mut m.title },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "objective",
                |m: &AgnosticPrompt| { &m.objective },
                |m: &mut AgnosticPrompt| { &mut m.objective },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AgnosticPrompt>(
                "LanguageQualityPrompts.AgnosticPrompt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AgnosticPrompt {
        const NAME: &'static str = "AgnosticPrompt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.title = is.read_string()?;
                    },
                    18 => {
                        self.objective = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.title.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.title);
            }
            if !self.objective.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.objective);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.title.is_empty() {
                os.write_string(1, &self.title)?;
            }
            if !self.objective.is_empty() {
                os.write_string(2, &self.objective)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AgnosticPrompt {
            AgnosticPrompt::new()
        }

        fn clear(&mut self) {
            self.title.clear();
            self.objective.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AgnosticPrompt {
            static instance: AgnosticPrompt = AgnosticPrompt {
                title: ::std::string::String::new(),
                objective: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AgnosticPrompt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.AgnosticPrompt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AgnosticPrompt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AgnosticPrompt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `AgnosticPrompt`
    pub mod agnostic_prompt {
        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ModularityChecks)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ModularityChecks {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ModularityChecks.unused_removed)
            pub unused_removed: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ModularityChecks.deps)
            pub deps: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ModularityChecks.lightweight)
            pub lightweight: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ModularityChecks.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ModularityChecks {
            fn default() -> &'a ModularityChecks {
                <ModularityChecks as ::protobuf::Message>::default_instance()
            }
        }

        impl ModularityChecks {
            pub fn new() -> ModularityChecks {
                ::std::default::Default::default()
            }

            // bool unused_removed = 1;

            pub fn unused_removed(&self) -> bool {
                self.unused_removed
            }

            pub fn clear_unused_removed(&mut self) {
                self.unused_removed = false;
            }

            // Param is passed by value, moved
            pub fn set_unused_removed(&mut self, v: bool) {
                self.unused_removed = v;
            }

            // repeated string deps = 2;

            pub fn deps(&self) -> &[::std::string::String] {
                &self.deps
            }

            pub fn clear_deps(&mut self) {
                self.deps.clear();
            }

            // Param is passed by value, moved
            pub fn set_deps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.deps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_deps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.deps
            }

            // Take field
            pub fn take_deps(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.deps, ::std::vec::Vec::new())
            }

            // bool lightweight = 3;

            pub fn lightweight(&self) -> bool {
                self.lightweight
            }

            pub fn clear_lightweight(&mut self) {
                self.lightweight = false;
            }

            // Param is passed by value, moved
            pub fn set_lightweight(&mut self, v: bool) {
                self.lightweight = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "unused_removed",
                    |m: &ModularityChecks| { &m.unused_removed },
                    |m: &mut ModularityChecks| { &mut m.unused_removed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "deps",
                    |m: &ModularityChecks| { &m.deps },
                    |m: &mut ModularityChecks| { &mut m.deps },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "lightweight",
                    |m: &ModularityChecks| { &m.lightweight },
                    |m: &mut ModularityChecks| { &mut m.lightweight },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModularityChecks>(
                    "LanguageQualityPrompts.AgnosticPrompt.ModularityChecks",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ModularityChecks {
            const NAME: &'static str = "ModularityChecks";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.unused_removed = is.read_bool()?;
                        },
                        18 => {
                            self.deps.push(is.read_string()?);
                        },
                        24 => {
                            self.lightweight = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.unused_removed != false {
                    my_size += 1 + 1;
                }
                for value in &self.deps {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.lightweight != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.unused_removed != false {
                    os.write_bool(1, self.unused_removed)?;
                }
                for v in &self.deps {
                    os.write_string(2, &v)?;
                };
                if self.lightweight != false {
                    os.write_bool(3, self.lightweight)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ModularityChecks {
                ModularityChecks::new()
            }

            fn clear(&mut self) {
                self.unused_removed = false;
                self.deps.clear();
                self.lightweight = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ModularityChecks {
                static instance: ModularityChecks = ModularityChecks {
                    unused_removed: false,
                    deps: ::std::vec::Vec::new(),
                    lightweight: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ModularityChecks {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.AgnosticPrompt.ModularityChecks").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ModularityChecks {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ModularityChecks {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ErrorHandling)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct ErrorHandling {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ErrorHandling.observability)
            pub observability: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ErrorHandling.handlers)
            pub handlers: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ErrorHandling.diagnostics)
            pub diagnostics: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.ErrorHandling.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ErrorHandling {
            fn default() -> &'a ErrorHandling {
                <ErrorHandling as ::protobuf::Message>::default_instance()
            }
        }

        impl ErrorHandling {
            pub fn new() -> ErrorHandling {
                ::std::default::Default::default()
            }

            // bool observability = 1;

            pub fn observability(&self) -> bool {
                self.observability
            }

            pub fn clear_observability(&mut self) {
                self.observability = false;
            }

            // Param is passed by value, moved
            pub fn set_observability(&mut self, v: bool) {
                self.observability = v;
            }

            // repeated string handlers = 2;

            pub fn handlers(&self) -> &[::std::string::String] {
                &self.handlers
            }

            pub fn clear_handlers(&mut self) {
                self.handlers.clear();
            }

            // Param is passed by value, moved
            pub fn set_handlers(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.handlers = v;
            }

            // Mutable pointer to the field.
            pub fn mut_handlers(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.handlers
            }

            // Take field
            pub fn take_handlers(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.handlers, ::std::vec::Vec::new())
            }

            // bool diagnostics = 3;

            pub fn diagnostics(&self) -> bool {
                self.diagnostics
            }

            pub fn clear_diagnostics(&mut self) {
                self.diagnostics = false;
            }

            // Param is passed by value, moved
            pub fn set_diagnostics(&mut self, v: bool) {
                self.diagnostics = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "observability",
                    |m: &ErrorHandling| { &m.observability },
                    |m: &mut ErrorHandling| { &mut m.observability },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "handlers",
                    |m: &ErrorHandling| { &m.handlers },
                    |m: &mut ErrorHandling| { &mut m.handlers },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "diagnostics",
                    |m: &ErrorHandling| { &m.diagnostics },
                    |m: &mut ErrorHandling| { &mut m.diagnostics },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandling>(
                    "LanguageQualityPrompts.AgnosticPrompt.ErrorHandling",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ErrorHandling {
            const NAME: &'static str = "ErrorHandling";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.observability = is.read_bool()?;
                        },
                        18 => {
                            self.handlers.push(is.read_string()?);
                        },
                        24 => {
                            self.diagnostics = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.observability != false {
                    my_size += 1 + 1;
                }
                for value in &self.handlers {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.diagnostics != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.observability != false {
                    os.write_bool(1, self.observability)?;
                }
                for v in &self.handlers {
                    os.write_string(2, &v)?;
                };
                if self.diagnostics != false {
                    os.write_bool(3, self.diagnostics)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ErrorHandling {
                ErrorHandling::new()
            }

            fn clear(&mut self) {
                self.observability = false;
                self.handlers.clear();
                self.diagnostics = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ErrorHandling {
                static instance: ErrorHandling = ErrorHandling {
                    observability: false,
                    handlers: ::std::vec::Vec::new(),
                    diagnostics: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ErrorHandling {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.AgnosticPrompt.ErrorHandling").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ErrorHandling {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ErrorHandling {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.Performance)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Performance {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.Performance.bottlenecks)
            pub bottlenecks: bool,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.Performance.caching)
            pub caching: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.Performance.monitoring)
            pub monitoring: bool,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.LanguageQualityPrompts.AgnosticPrompt.Performance.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Performance {
            fn default() -> &'a Performance {
                <Performance as ::protobuf::Message>::default_instance()
            }
        }

        impl Performance {
            pub fn new() -> Performance {
                ::std::default::Default::default()
            }

            // bool bottlenecks = 1;

            pub fn bottlenecks(&self) -> bool {
                self.bottlenecks
            }

            pub fn clear_bottlenecks(&mut self) {
                self.bottlenecks = false;
            }

            // Param is passed by value, moved
            pub fn set_bottlenecks(&mut self, v: bool) {
                self.bottlenecks = v;
            }

            // repeated string caching = 2;

            pub fn caching(&self) -> &[::std::string::String] {
                &self.caching
            }

            pub fn clear_caching(&mut self) {
                self.caching.clear();
            }

            // Param is passed by value, moved
            pub fn set_caching(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.caching = v;
            }

            // Mutable pointer to the field.
            pub fn mut_caching(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.caching
            }

            // Take field
            pub fn take_caching(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.caching, ::std::vec::Vec::new())
            }

            // bool monitoring = 3;

            pub fn monitoring(&self) -> bool {
                self.monitoring
            }

            pub fn clear_monitoring(&mut self) {
                self.monitoring = false;
            }

            // Param is passed by value, moved
            pub fn set_monitoring(&mut self, v: bool) {
                self.monitoring = v;
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "bottlenecks",
                    |m: &Performance| { &m.bottlenecks },
                    |m: &mut Performance| { &mut m.bottlenecks },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "caching",
                    |m: &Performance| { &m.caching },
                    |m: &mut Performance| { &mut m.caching },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "monitoring",
                    |m: &Performance| { &m.monitoring },
                    |m: &mut Performance| { &mut m.monitoring },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Performance>(
                    "LanguageQualityPrompts.AgnosticPrompt.Performance",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Performance {
            const NAME: &'static str = "Performance";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.bottlenecks = is.read_bool()?;
                        },
                        18 => {
                            self.caching.push(is.read_string()?);
                        },
                        24 => {
                            self.monitoring = is.read_bool()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if self.bottlenecks != false {
                    my_size += 1 + 1;
                }
                for value in &self.caching {
                    my_size += ::protobuf::rt::string_size(2, &value);
                };
                if self.monitoring != false {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if self.bottlenecks != false {
                    os.write_bool(1, self.bottlenecks)?;
                }
                for v in &self.caching {
                    os.write_string(2, &v)?;
                };
                if self.monitoring != false {
                    os.write_bool(3, self.monitoring)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Performance {
                Performance::new()
            }

            fn clear(&mut self) {
                self.bottlenecks = false;
                self.caching.clear();
                self.monitoring = false;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Performance {
                static instance: Performance = Performance {
                    bottlenecks: false,
                    caching: ::std::vec::Vec::new(),
                    monitoring: false,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Performance {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("LanguageQualityPrompts.AgnosticPrompt.Performance").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Performance {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Performance {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:kymera_mappings.ExampleMappings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExampleMappings {
    // message fields
    // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.rust_examples)
    pub rust_examples: ::protobuf::MessageField<example_mappings::KymeraToRustExamples>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.python_examples)
    pub python_examples: ::protobuf::MessageField<example_mappings::KymeraToPythonExamples>,
    // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.typescript_examples)
    pub typescript_examples: ::protobuf::MessageField<example_mappings::KymeraToTypeScriptExamples>,
    // special fields
    // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExampleMappings {
    fn default() -> &'a ExampleMappings {
        <ExampleMappings as ::protobuf::Message>::default_instance()
    }
}

impl ExampleMappings {
    pub fn new() -> ExampleMappings {
        ::std::default::Default::default()
    }

    // .kymera_mappings.ExampleMappings.KymeraToRustExamples rust_examples = 1;

    pub fn rust_examples(&self) -> &example_mappings::KymeraToRustExamples {
        self.rust_examples.as_ref().unwrap_or_else(|| <example_mappings::KymeraToRustExamples as ::protobuf::Message>::default_instance())
    }

    pub fn clear_rust_examples(&mut self) {
        self.rust_examples.clear();
    }

    pub fn has_rust_examples(&self) -> bool {
        self.rust_examples.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rust_examples(&mut self, v: example_mappings::KymeraToRustExamples) {
        self.rust_examples = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rust_examples(&mut self) -> &mut example_mappings::KymeraToRustExamples {
        self.rust_examples.mut_or_insert_default()
    }

    // Take field
    pub fn take_rust_examples(&mut self) -> example_mappings::KymeraToRustExamples {
        self.rust_examples.take().unwrap_or_else(|| example_mappings::KymeraToRustExamples::new())
    }

    // .kymera_mappings.ExampleMappings.KymeraToPythonExamples python_examples = 2;

    pub fn python_examples(&self) -> &example_mappings::KymeraToPythonExamples {
        self.python_examples.as_ref().unwrap_or_else(|| <example_mappings::KymeraToPythonExamples as ::protobuf::Message>::default_instance())
    }

    pub fn clear_python_examples(&mut self) {
        self.python_examples.clear();
    }

    pub fn has_python_examples(&self) -> bool {
        self.python_examples.is_some()
    }

    // Param is passed by value, moved
    pub fn set_python_examples(&mut self, v: example_mappings::KymeraToPythonExamples) {
        self.python_examples = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_python_examples(&mut self) -> &mut example_mappings::KymeraToPythonExamples {
        self.python_examples.mut_or_insert_default()
    }

    // Take field
    pub fn take_python_examples(&mut self) -> example_mappings::KymeraToPythonExamples {
        self.python_examples.take().unwrap_or_else(|| example_mappings::KymeraToPythonExamples::new())
    }

    // .kymera_mappings.ExampleMappings.KymeraToTypeScriptExamples typescript_examples = 3;

    pub fn typescript_examples(&self) -> &example_mappings::KymeraToTypeScriptExamples {
        self.typescript_examples.as_ref().unwrap_or_else(|| <example_mappings::KymeraToTypeScriptExamples as ::protobuf::Message>::default_instance())
    }

    pub fn clear_typescript_examples(&mut self) {
        self.typescript_examples.clear();
    }

    pub fn has_typescript_examples(&self) -> bool {
        self.typescript_examples.is_some()
    }

    // Param is passed by value, moved
    pub fn set_typescript_examples(&mut self, v: example_mappings::KymeraToTypeScriptExamples) {
        self.typescript_examples = ::protobuf::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_typescript_examples(&mut self) -> &mut example_mappings::KymeraToTypeScriptExamples {
        self.typescript_examples.mut_or_insert_default()
    }

    // Take field
    pub fn take_typescript_examples(&mut self) -> example_mappings::KymeraToTypeScriptExamples {
        self.typescript_examples.take().unwrap_or_else(|| example_mappings::KymeraToTypeScriptExamples::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, example_mappings::KymeraToRustExamples>(
            "rust_examples",
            |m: &ExampleMappings| { &m.rust_examples },
            |m: &mut ExampleMappings| { &mut m.rust_examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, example_mappings::KymeraToPythonExamples>(
            "python_examples",
            |m: &ExampleMappings| { &m.python_examples },
            |m: &mut ExampleMappings| { &mut m.python_examples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, example_mappings::KymeraToTypeScriptExamples>(
            "typescript_examples",
            |m: &ExampleMappings| { &m.typescript_examples },
            |m: &mut ExampleMappings| { &mut m.typescript_examples },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExampleMappings>(
            "ExampleMappings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExampleMappings {
    const NAME: &'static str = "ExampleMappings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.rust_examples)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.python_examples)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.typescript_examples)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rust_examples.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.python_examples.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.typescript_examples.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rust_examples.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.python_examples.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.typescript_examples.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExampleMappings {
        ExampleMappings::new()
    }

    fn clear(&mut self) {
        self.rust_examples.clear();
        self.python_examples.clear();
        self.typescript_examples.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExampleMappings {
        static instance: ExampleMappings = ExampleMappings {
            rust_examples: ::protobuf::MessageField::none(),
            python_examples: ::protobuf::MessageField::none(),
            typescript_examples: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExampleMappings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExampleMappings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExampleMappings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExampleMappings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ExampleMappings`
pub mod example_mappings {
    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.FunctionMapping)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FunctionMapping {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.base_mapping)
        pub base_mapping: ::protobuf::MessageField<super::BaseMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.examples)
        pub examples: ::std::vec::Vec<function_mapping::Example>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.metadata)
        pub metadata: ::protobuf::MessageField<super::ConstructMetadata>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.numeric_mappings)
        pub numeric_mappings: ::std::vec::Vec<super::NumericTypeMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.compatibility_notes)
        pub compatibility_notes: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.FunctionMapping.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FunctionMapping {
        fn default() -> &'a FunctionMapping {
            <FunctionMapping as ::protobuf::Message>::default_instance()
        }
    }

    impl FunctionMapping {
        pub fn new() -> FunctionMapping {
            ::std::default::Default::default()
        }

        // .kymera_mappings.BaseMapping base_mapping = 1;

        pub fn base_mapping(&self) -> &super::BaseMapping {
            self.base_mapping.as_ref().unwrap_or_else(|| <super::BaseMapping as ::protobuf::Message>::default_instance())
        }

        pub fn clear_base_mapping(&mut self) {
            self.base_mapping.clear();
        }

        pub fn has_base_mapping(&self) -> bool {
            self.base_mapping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_mapping(&mut self, v: super::BaseMapping) {
            self.base_mapping = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_base_mapping(&mut self) -> &mut super::BaseMapping {
            self.base_mapping.mut_or_insert_default()
        }

        // Take field
        pub fn take_base_mapping(&mut self) -> super::BaseMapping {
            self.base_mapping.take().unwrap_or_else(|| super::BaseMapping::new())
        }

        // repeated .kymera_mappings.ExampleMappings.FunctionMapping.Example examples = 2;

        pub fn examples(&self) -> &[function_mapping::Example] {
            &self.examples
        }

        pub fn clear_examples(&mut self) {
            self.examples.clear();
        }

        // Param is passed by value, moved
        pub fn set_examples(&mut self, v: ::std::vec::Vec<function_mapping::Example>) {
            self.examples = v;
        }

        // Mutable pointer to the field.
        pub fn mut_examples(&mut self) -> &mut ::std::vec::Vec<function_mapping::Example> {
            &mut self.examples
        }

        // Take field
        pub fn take_examples(&mut self) -> ::std::vec::Vec<function_mapping::Example> {
            ::std::mem::replace(&mut self.examples, ::std::vec::Vec::new())
        }

        // .kymera_mappings.ConstructMetadata metadata = 3;

        pub fn metadata(&self) -> &super::ConstructMetadata {
            self.metadata.as_ref().unwrap_or_else(|| <super::ConstructMetadata as ::protobuf::Message>::default_instance())
        }

        pub fn clear_metadata(&mut self) {
            self.metadata.clear();
        }

        pub fn has_metadata(&self) -> bool {
            self.metadata.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metadata(&mut self, v: super::ConstructMetadata) {
            self.metadata = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metadata(&mut self) -> &mut super::ConstructMetadata {
            self.metadata.mut_or_insert_default()
        }

        // Take field
        pub fn take_metadata(&mut self) -> super::ConstructMetadata {
            self.metadata.take().unwrap_or_else(|| super::ConstructMetadata::new())
        }

        // repeated .kymera_mappings.NumericTypeMapping numeric_mappings = 4;

        pub fn numeric_mappings(&self) -> &[super::NumericTypeMapping] {
            &self.numeric_mappings
        }

        pub fn clear_numeric_mappings(&mut self) {
            self.numeric_mappings.clear();
        }

        // Param is passed by value, moved
        pub fn set_numeric_mappings(&mut self, v: ::std::vec::Vec<super::NumericTypeMapping>) {
            self.numeric_mappings = v;
        }

        // Mutable pointer to the field.
        pub fn mut_numeric_mappings(&mut self) -> &mut ::std::vec::Vec<super::NumericTypeMapping> {
            &mut self.numeric_mappings
        }

        // Take field
        pub fn take_numeric_mappings(&mut self) -> ::std::vec::Vec<super::NumericTypeMapping> {
            ::std::mem::replace(&mut self.numeric_mappings, ::std::vec::Vec::new())
        }

        // repeated string compatibility_notes = 5;

        pub fn compatibility_notes(&self) -> &[::std::string::String] {
            &self.compatibility_notes
        }

        pub fn clear_compatibility_notes(&mut self) {
            self.compatibility_notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_compatibility_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.compatibility_notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_compatibility_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.compatibility_notes
        }

        // Take field
        pub fn take_compatibility_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.compatibility_notes, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::BaseMapping>(
                "base_mapping",
                |m: &FunctionMapping| { &m.base_mapping },
                |m: &mut FunctionMapping| { &mut m.base_mapping },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "examples",
                |m: &FunctionMapping| { &m.examples },
                |m: &mut FunctionMapping| { &mut m.examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::ConstructMetadata>(
                "metadata",
                |m: &FunctionMapping| { &m.metadata },
                |m: &mut FunctionMapping| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "numeric_mappings",
                |m: &FunctionMapping| { &m.numeric_mappings },
                |m: &mut FunctionMapping| { &mut m.numeric_mappings },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "compatibility_notes",
                |m: &FunctionMapping| { &m.compatibility_notes },
                |m: &mut FunctionMapping| { &mut m.compatibility_notes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FunctionMapping>(
                "ExampleMappings.FunctionMapping",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FunctionMapping {
        const NAME: &'static str = "FunctionMapping";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.base_mapping)?;
                    },
                    18 => {
                        self.examples.push(is.read_message()?);
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.metadata)?;
                    },
                    34 => {
                        self.numeric_mappings.push(is.read_message()?);
                    },
                    42 => {
                        self.compatibility_notes.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.base_mapping.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.examples {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.metadata.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.numeric_mappings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.compatibility_notes {
                my_size += ::protobuf::rt::string_size(5, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.base_mapping.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.examples {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.metadata.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            for v in &self.numeric_mappings {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            for v in &self.compatibility_notes {
                os.write_string(5, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FunctionMapping {
            FunctionMapping::new()
        }

        fn clear(&mut self) {
            self.base_mapping.clear();
            self.examples.clear();
            self.metadata.clear();
            self.numeric_mappings.clear();
            self.compatibility_notes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FunctionMapping {
            static instance: FunctionMapping = FunctionMapping {
                base_mapping: ::protobuf::MessageField::none(),
                examples: ::std::vec::Vec::new(),
                metadata: ::protobuf::MessageField::none(),
                numeric_mappings: ::std::vec::Vec::new(),
                compatibility_notes: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FunctionMapping {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.FunctionMapping").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FunctionMapping {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FunctionMapping {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `FunctionMapping`
    pub mod function_mapping {
        // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.FunctionMapping.Example)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Example {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.Example.kymera_code)
            pub kymera_code: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.Example.target_code)
            pub target_code: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.Example.notes)
            pub notes: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FunctionMapping.Example.type_mappings)
            pub type_mappings: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.FunctionMapping.Example.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Example {
            fn default() -> &'a Example {
                <Example as ::protobuf::Message>::default_instance()
            }
        }

        impl Example {
            pub fn new() -> Example {
                ::std::default::Default::default()
            }

            // string kymera_code = 1;

            pub fn kymera_code(&self) -> &str {
                &self.kymera_code
            }

            pub fn clear_kymera_code(&mut self) {
                self.kymera_code.clear();
            }

            // Param is passed by value, moved
            pub fn set_kymera_code(&mut self, v: ::std::string::String) {
                self.kymera_code = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_kymera_code(&mut self) -> &mut ::std::string::String {
                &mut self.kymera_code
            }

            // Take field
            pub fn take_kymera_code(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.kymera_code, ::std::string::String::new())
            }

            // string target_code = 2;

            pub fn target_code(&self) -> &str {
                &self.target_code
            }

            pub fn clear_target_code(&mut self) {
                self.target_code.clear();
            }

            // Param is passed by value, moved
            pub fn set_target_code(&mut self, v: ::std::string::String) {
                self.target_code = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_target_code(&mut self) -> &mut ::std::string::String {
                &mut self.target_code
            }

            // Take field
            pub fn take_target_code(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.target_code, ::std::string::String::new())
            }

            // repeated string notes = 3;

            pub fn notes(&self) -> &[::std::string::String] {
                &self.notes
            }

            pub fn clear_notes(&mut self) {
                self.notes.clear();
            }

            // Param is passed by value, moved
            pub fn set_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.notes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.notes
            }

            // Take field
            pub fn take_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.notes, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.ExampleMappings.FunctionMapping.Example.TypeMappingsEntry type_mappings = 4;

            pub fn type_mappings(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.type_mappings
            }

            pub fn clear_type_mappings(&mut self) {
                self.type_mappings.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_mappings(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.type_mappings = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_mappings(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.type_mappings
            }

            // Take field
            pub fn take_type_mappings(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.type_mappings, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "kymera_code",
                    |m: &Example| { &m.kymera_code },
                    |m: &mut Example| { &mut m.kymera_code },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "target_code",
                    |m: &Example| { &m.target_code },
                    |m: &mut Example| { &mut m.target_code },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "notes",
                    |m: &Example| { &m.notes },
                    |m: &mut Example| { &mut m.notes },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "type_mappings",
                    |m: &Example| { &m.type_mappings },
                    |m: &mut Example| { &mut m.type_mappings },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Example>(
                    "ExampleMappings.FunctionMapping.Example",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Example {
            const NAME: &'static str = "Example";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.kymera_code = is.read_string()?;
                        },
                        18 => {
                            self.target_code = is.read_string()?;
                        },
                        26 => {
                            self.notes.push(is.read_string()?);
                        },
                        34 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.type_mappings.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.kymera_code.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.kymera_code);
                }
                if !self.target_code.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.target_code);
                }
                for value in &self.notes {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for (k, v) in &self.type_mappings {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.kymera_code.is_empty() {
                    os.write_string(1, &self.kymera_code)?;
                }
                if !self.target_code.is_empty() {
                    os.write_string(2, &self.target_code)?;
                }
                for v in &self.notes {
                    os.write_string(3, &v)?;
                };
                for (k, v) in &self.type_mappings {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(34)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Example {
                Example::new()
            }

            fn clear(&mut self) {
                self.kymera_code.clear();
                self.target_code.clear();
                self.notes.clear();
                self.type_mappings.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Example {
                static instance: ::protobuf::rt::Lazy<Example> = ::protobuf::rt::Lazy::new();
                instance.get(Example::new)
            }
        }

        impl ::protobuf::MessageFull for Example {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ExampleMappings.FunctionMapping.Example").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Example {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Example {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.TypeMapping)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TypeMapping {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TypeMapping.type_examples)
        pub type_examples: ::std::vec::Vec<type_mapping::Example>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TypeMapping.common_patterns)
        pub common_patterns: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TypeMapping.best_practices)
        pub best_practices: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.TypeMapping.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TypeMapping {
        fn default() -> &'a TypeMapping {
            <TypeMapping as ::protobuf::Message>::default_instance()
        }
    }

    impl TypeMapping {
        pub fn new() -> TypeMapping {
            ::std::default::Default::default()
        }

        // repeated .kymera_mappings.ExampleMappings.TypeMapping.Example type_examples = 1;

        pub fn type_examples(&self) -> &[type_mapping::Example] {
            &self.type_examples
        }

        pub fn clear_type_examples(&mut self) {
            self.type_examples.clear();
        }

        // Param is passed by value, moved
        pub fn set_type_examples(&mut self, v: ::std::vec::Vec<type_mapping::Example>) {
            self.type_examples = v;
        }

        // Mutable pointer to the field.
        pub fn mut_type_examples(&mut self) -> &mut ::std::vec::Vec<type_mapping::Example> {
            &mut self.type_examples
        }

        // Take field
        pub fn take_type_examples(&mut self) -> ::std::vec::Vec<type_mapping::Example> {
            ::std::mem::replace(&mut self.type_examples, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.ExampleMappings.TypeMapping.CommonPatternsEntry common_patterns = 2;

        pub fn common_patterns(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.common_patterns
        }

        pub fn clear_common_patterns(&mut self) {
            self.common_patterns.clear();
        }

        // Param is passed by value, moved
        pub fn set_common_patterns(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.common_patterns = v;
        }

        // Mutable pointer to the field.
        pub fn mut_common_patterns(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.common_patterns
        }

        // Take field
        pub fn take_common_patterns(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.common_patterns, ::std::collections::HashMap::new())
        }

        // repeated string best_practices = 3;

        pub fn best_practices(&self) -> &[::std::string::String] {
            &self.best_practices
        }

        pub fn clear_best_practices(&mut self) {
            self.best_practices.clear();
        }

        // Param is passed by value, moved
        pub fn set_best_practices(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.best_practices = v;
        }

        // Mutable pointer to the field.
        pub fn mut_best_practices(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.best_practices
        }

        // Take field
        pub fn take_best_practices(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.best_practices, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type_examples",
                |m: &TypeMapping| { &m.type_examples },
                |m: &mut TypeMapping| { &mut m.type_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "common_patterns",
                |m: &TypeMapping| { &m.common_patterns },
                |m: &mut TypeMapping| { &mut m.common_patterns },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "best_practices",
                |m: &TypeMapping| { &m.best_practices },
                |m: &mut TypeMapping| { &mut m.best_practices },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeMapping>(
                "ExampleMappings.TypeMapping",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TypeMapping {
        const NAME: &'static str = "TypeMapping";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.type_examples.push(is.read_message()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.common_patterns.insert(key, value);
                    },
                    26 => {
                        self.best_practices.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.type_examples {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for (k, v) in &self.common_patterns {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.best_practices {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.type_examples {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for (k, v) in &self.common_patterns {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.best_practices {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TypeMapping {
            TypeMapping::new()
        }

        fn clear(&mut self) {
            self.type_examples.clear();
            self.common_patterns.clear();
            self.best_practices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TypeMapping {
            static instance: ::protobuf::rt::Lazy<TypeMapping> = ::protobuf::rt::Lazy::new();
            instance.get(TypeMapping::new)
        }
    }

    impl ::protobuf::MessageFull for TypeMapping {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.TypeMapping").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TypeMapping {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TypeMapping {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TypeMapping`
    pub mod type_mapping {
        // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.TypeMapping.Example)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Example {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TypeMapping.Example.kymera_type)
            pub kymera_type: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TypeMapping.Example.target_type)
            pub target_type: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TypeMapping.Example.direct_mapping)
            pub direct_mapping: bool,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TypeMapping.Example.conversion_notes)
            pub conversion_notes: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.TypeMapping.Example.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Example {
            fn default() -> &'a Example {
                <Example as ::protobuf::Message>::default_instance()
            }
        }

        impl Example {
            pub fn new() -> Example {
                ::std::default::Default::default()
            }

            // string kymera_type = 1;

            pub fn kymera_type(&self) -> &str {
                &self.kymera_type
            }

            pub fn clear_kymera_type(&mut self) {
                self.kymera_type.clear();
            }

            // Param is passed by value, moved
            pub fn set_kymera_type(&mut self, v: ::std::string::String) {
                self.kymera_type = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_kymera_type(&mut self) -> &mut ::std::string::String {
                &mut self.kymera_type
            }

            // Take field
            pub fn take_kymera_type(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.kymera_type, ::std::string::String::new())
            }

            // string target_type = 2;

            pub fn target_type(&self) -> &str {
                &self.target_type
            }

            pub fn clear_target_type(&mut self) {
                self.target_type.clear();
            }

            // Param is passed by value, moved
            pub fn set_target_type(&mut self, v: ::std::string::String) {
                self.target_type = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_target_type(&mut self) -> &mut ::std::string::String {
                &mut self.target_type
            }

            // Take field
            pub fn take_target_type(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.target_type, ::std::string::String::new())
            }

            // bool direct_mapping = 3;

            pub fn direct_mapping(&self) -> bool {
                self.direct_mapping
            }

            pub fn clear_direct_mapping(&mut self) {
                self.direct_mapping = false;
            }

            // Param is passed by value, moved
            pub fn set_direct_mapping(&mut self, v: bool) {
                self.direct_mapping = v;
            }

            // repeated string conversion_notes = 4;

            pub fn conversion_notes(&self) -> &[::std::string::String] {
                &self.conversion_notes
            }

            pub fn clear_conversion_notes(&mut self) {
                self.conversion_notes.clear();
            }

            // Param is passed by value, moved
            pub fn set_conversion_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.conversion_notes = v;
            }

            // Mutable pointer to the field.
            pub fn mut_conversion_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.conversion_notes
            }

            // Take field
            pub fn take_conversion_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.conversion_notes, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "kymera_type",
                    |m: &Example| { &m.kymera_type },
                    |m: &mut Example| { &mut m.kymera_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "target_type",
                    |m: &Example| { &m.target_type },
                    |m: &mut Example| { &mut m.target_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "direct_mapping",
                    |m: &Example| { &m.direct_mapping },
                    |m: &mut Example| { &mut m.direct_mapping },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "conversion_notes",
                    |m: &Example| { &m.conversion_notes },
                    |m: &mut Example| { &mut m.conversion_notes },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Example>(
                    "ExampleMappings.TypeMapping.Example",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Example {
            const NAME: &'static str = "Example";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.kymera_type = is.read_string()?;
                        },
                        18 => {
                            self.target_type = is.read_string()?;
                        },
                        24 => {
                            self.direct_mapping = is.read_bool()?;
                        },
                        34 => {
                            self.conversion_notes.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.kymera_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.kymera_type);
                }
                if !self.target_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.target_type);
                }
                if self.direct_mapping != false {
                    my_size += 1 + 1;
                }
                for value in &self.conversion_notes {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.kymera_type.is_empty() {
                    os.write_string(1, &self.kymera_type)?;
                }
                if !self.target_type.is_empty() {
                    os.write_string(2, &self.target_type)?;
                }
                if self.direct_mapping != false {
                    os.write_bool(3, self.direct_mapping)?;
                }
                for v in &self.conversion_notes {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Example {
                Example::new()
            }

            fn clear(&mut self) {
                self.kymera_type.clear();
                self.target_type.clear();
                self.direct_mapping = false;
                self.conversion_notes.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Example {
                static instance: Example = Example {
                    kymera_type: ::std::string::String::new(),
                    target_type: ::std::string::String::new(),
                    direct_mapping: false,
                    conversion_notes: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Example {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ExampleMappings.TypeMapping.Example").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Example {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Example {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.ErrorHandlingExample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ErrorHandlingExample {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.ErrorHandlingExample.error_examples)
        pub error_examples: ::std::vec::Vec<error_handling_example::Example>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.ErrorHandlingExample.error_patterns)
        pub error_patterns: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.ErrorHandlingExample.guidelines)
        pub guidelines: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.ErrorHandlingExample.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ErrorHandlingExample {
        fn default() -> &'a ErrorHandlingExample {
            <ErrorHandlingExample as ::protobuf::Message>::default_instance()
        }
    }

    impl ErrorHandlingExample {
        pub fn new() -> ErrorHandlingExample {
            ::std::default::Default::default()
        }

        // repeated .kymera_mappings.ExampleMappings.ErrorHandlingExample.Example error_examples = 1;

        pub fn error_examples(&self) -> &[error_handling_example::Example] {
            &self.error_examples
        }

        pub fn clear_error_examples(&mut self) {
            self.error_examples.clear();
        }

        // Param is passed by value, moved
        pub fn set_error_examples(&mut self, v: ::std::vec::Vec<error_handling_example::Example>) {
            self.error_examples = v;
        }

        // Mutable pointer to the field.
        pub fn mut_error_examples(&mut self) -> &mut ::std::vec::Vec<error_handling_example::Example> {
            &mut self.error_examples
        }

        // Take field
        pub fn take_error_examples(&mut self) -> ::std::vec::Vec<error_handling_example::Example> {
            ::std::mem::replace(&mut self.error_examples, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.ExampleMappings.ErrorHandlingExample.ErrorPatternsEntry error_patterns = 2;

        pub fn error_patterns(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.error_patterns
        }

        pub fn clear_error_patterns(&mut self) {
            self.error_patterns.clear();
        }

        // Param is passed by value, moved
        pub fn set_error_patterns(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.error_patterns = v;
        }

        // Mutable pointer to the field.
        pub fn mut_error_patterns(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.error_patterns
        }

        // Take field
        pub fn take_error_patterns(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.error_patterns, ::std::collections::HashMap::new())
        }

        // repeated string guidelines = 3;

        pub fn guidelines(&self) -> &[::std::string::String] {
            &self.guidelines
        }

        pub fn clear_guidelines(&mut self) {
            self.guidelines.clear();
        }

        // Param is passed by value, moved
        pub fn set_guidelines(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.guidelines = v;
        }

        // Mutable pointer to the field.
        pub fn mut_guidelines(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.guidelines
        }

        // Take field
        pub fn take_guidelines(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.guidelines, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "error_examples",
                |m: &ErrorHandlingExample| { &m.error_examples },
                |m: &mut ErrorHandlingExample| { &mut m.error_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "error_patterns",
                |m: &ErrorHandlingExample| { &m.error_patterns },
                |m: &mut ErrorHandlingExample| { &mut m.error_patterns },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "guidelines",
                |m: &ErrorHandlingExample| { &m.guidelines },
                |m: &mut ErrorHandlingExample| { &mut m.guidelines },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorHandlingExample>(
                "ExampleMappings.ErrorHandlingExample",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ErrorHandlingExample {
        const NAME: &'static str = "ErrorHandlingExample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.error_examples.push(is.read_message()?);
                    },
                    18 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.error_patterns.insert(key, value);
                    },
                    26 => {
                        self.guidelines.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.error_examples {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for (k, v) in &self.error_patterns {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            for value in &self.guidelines {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.error_examples {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for (k, v) in &self.error_patterns {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(18)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            for v in &self.guidelines {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ErrorHandlingExample {
            ErrorHandlingExample::new()
        }

        fn clear(&mut self) {
            self.error_examples.clear();
            self.error_patterns.clear();
            self.guidelines.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ErrorHandlingExample {
            static instance: ::protobuf::rt::Lazy<ErrorHandlingExample> = ::protobuf::rt::Lazy::new();
            instance.get(ErrorHandlingExample::new)
        }
    }

    impl ::protobuf::MessageFull for ErrorHandlingExample {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.ErrorHandlingExample").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ErrorHandlingExample {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorHandlingExample {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ErrorHandlingExample`
    pub mod error_handling_example {
        // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.ErrorHandlingExample.Example)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Example {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.ErrorHandlingExample.Example.kymera_error)
            pub kymera_error: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.ErrorHandlingExample.Example.target_error)
            pub target_error: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.ErrorHandlingExample.Example.handling_strategy)
            pub handling_strategy: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.ErrorHandlingExample.Example.recovery_steps)
            pub recovery_steps: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.ErrorHandlingExample.Example.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Example {
            fn default() -> &'a Example {
                <Example as ::protobuf::Message>::default_instance()
            }
        }

        impl Example {
            pub fn new() -> Example {
                ::std::default::Default::default()
            }

            // string kymera_error = 1;

            pub fn kymera_error(&self) -> &str {
                &self.kymera_error
            }

            pub fn clear_kymera_error(&mut self) {
                self.kymera_error.clear();
            }

            // Param is passed by value, moved
            pub fn set_kymera_error(&mut self, v: ::std::string::String) {
                self.kymera_error = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_kymera_error(&mut self) -> &mut ::std::string::String {
                &mut self.kymera_error
            }

            // Take field
            pub fn take_kymera_error(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.kymera_error, ::std::string::String::new())
            }

            // string target_error = 2;

            pub fn target_error(&self) -> &str {
                &self.target_error
            }

            pub fn clear_target_error(&mut self) {
                self.target_error.clear();
            }

            // Param is passed by value, moved
            pub fn set_target_error(&mut self, v: ::std::string::String) {
                self.target_error = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_target_error(&mut self) -> &mut ::std::string::String {
                &mut self.target_error
            }

            // Take field
            pub fn take_target_error(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.target_error, ::std::string::String::new())
            }

            // string handling_strategy = 3;

            pub fn handling_strategy(&self) -> &str {
                &self.handling_strategy
            }

            pub fn clear_handling_strategy(&mut self) {
                self.handling_strategy.clear();
            }

            // Param is passed by value, moved
            pub fn set_handling_strategy(&mut self, v: ::std::string::String) {
                self.handling_strategy = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_handling_strategy(&mut self) -> &mut ::std::string::String {
                &mut self.handling_strategy
            }

            // Take field
            pub fn take_handling_strategy(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.handling_strategy, ::std::string::String::new())
            }

            // repeated string recovery_steps = 4;

            pub fn recovery_steps(&self) -> &[::std::string::String] {
                &self.recovery_steps
            }

            pub fn clear_recovery_steps(&mut self) {
                self.recovery_steps.clear();
            }

            // Param is passed by value, moved
            pub fn set_recovery_steps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.recovery_steps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_recovery_steps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.recovery_steps
            }

            // Take field
            pub fn take_recovery_steps(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.recovery_steps, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "kymera_error",
                    |m: &Example| { &m.kymera_error },
                    |m: &mut Example| { &mut m.kymera_error },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "target_error",
                    |m: &Example| { &m.target_error },
                    |m: &mut Example| { &mut m.target_error },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "handling_strategy",
                    |m: &Example| { &m.handling_strategy },
                    |m: &mut Example| { &mut m.handling_strategy },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "recovery_steps",
                    |m: &Example| { &m.recovery_steps },
                    |m: &mut Example| { &mut m.recovery_steps },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Example>(
                    "ExampleMappings.ErrorHandlingExample.Example",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Example {
            const NAME: &'static str = "Example";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.kymera_error = is.read_string()?;
                        },
                        18 => {
                            self.target_error = is.read_string()?;
                        },
                        26 => {
                            self.handling_strategy = is.read_string()?;
                        },
                        34 => {
                            self.recovery_steps.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.kymera_error.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.kymera_error);
                }
                if !self.target_error.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.target_error);
                }
                if !self.handling_strategy.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.handling_strategy);
                }
                for value in &self.recovery_steps {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.kymera_error.is_empty() {
                    os.write_string(1, &self.kymera_error)?;
                }
                if !self.target_error.is_empty() {
                    os.write_string(2, &self.target_error)?;
                }
                if !self.handling_strategy.is_empty() {
                    os.write_string(3, &self.handling_strategy)?;
                }
                for v in &self.recovery_steps {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Example {
                Example::new()
            }

            fn clear(&mut self) {
                self.kymera_error.clear();
                self.target_error.clear();
                self.handling_strategy.clear();
                self.recovery_steps.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Example {
                static instance: Example = Example {
                    kymera_error: ::std::string::String::new(),
                    target_error: ::std::string::String::new(),
                    handling_strategy: ::std::string::String::new(),
                    recovery_steps: ::std::vec::Vec::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Example {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ExampleMappings.ErrorHandlingExample.Example").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Example {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Example {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.FFIExample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FFIExample {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIExample.ffi_examples)
        pub ffi_examples: ::std::vec::Vec<ffiexample::Example>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIExample.ffi_config)
        pub ffi_config: ::protobuf::MessageField<FFIConfig>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIExample.integration_notes)
        pub integration_notes: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.FFIExample.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FFIExample {
        fn default() -> &'a FFIExample {
            <FFIExample as ::protobuf::Message>::default_instance()
        }
    }

    impl FFIExample {
        pub fn new() -> FFIExample {
            ::std::default::Default::default()
        }

        // repeated .kymera_mappings.ExampleMappings.FFIExample.Example ffi_examples = 1;

        pub fn ffi_examples(&self) -> &[ffiexample::Example] {
            &self.ffi_examples
        }

        pub fn clear_ffi_examples(&mut self) {
            self.ffi_examples.clear();
        }

        // Param is passed by value, moved
        pub fn set_ffi_examples(&mut self, v: ::std::vec::Vec<ffiexample::Example>) {
            self.ffi_examples = v;
        }

        // Mutable pointer to the field.
        pub fn mut_ffi_examples(&mut self) -> &mut ::std::vec::Vec<ffiexample::Example> {
            &mut self.ffi_examples
        }

        // Take field
        pub fn take_ffi_examples(&mut self) -> ::std::vec::Vec<ffiexample::Example> {
            ::std::mem::replace(&mut self.ffi_examples, ::std::vec::Vec::new())
        }

        // .kymera_mappings.ExampleMappings.FFIConfig ffi_config = 2;

        pub fn ffi_config(&self) -> &FFIConfig {
            self.ffi_config.as_ref().unwrap_or_else(|| <FFIConfig as ::protobuf::Message>::default_instance())
        }

        pub fn clear_ffi_config(&mut self) {
            self.ffi_config.clear();
        }

        pub fn has_ffi_config(&self) -> bool {
            self.ffi_config.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ffi_config(&mut self, v: FFIConfig) {
            self.ffi_config = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ffi_config(&mut self) -> &mut FFIConfig {
            self.ffi_config.mut_or_insert_default()
        }

        // Take field
        pub fn take_ffi_config(&mut self) -> FFIConfig {
            self.ffi_config.take().unwrap_or_else(|| FFIConfig::new())
        }

        // repeated string integration_notes = 3;

        pub fn integration_notes(&self) -> &[::std::string::String] {
            &self.integration_notes
        }

        pub fn clear_integration_notes(&mut self) {
            self.integration_notes.clear();
        }

        // Param is passed by value, moved
        pub fn set_integration_notes(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.integration_notes = v;
        }

        // Mutable pointer to the field.
        pub fn mut_integration_notes(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.integration_notes
        }

        // Take field
        pub fn take_integration_notes(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.integration_notes, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "ffi_examples",
                |m: &FFIExample| { &m.ffi_examples },
                |m: &mut FFIExample| { &mut m.ffi_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FFIConfig>(
                "ffi_config",
                |m: &FFIExample| { &m.ffi_config },
                |m: &mut FFIExample| { &mut m.ffi_config },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "integration_notes",
                |m: &FFIExample| { &m.integration_notes },
                |m: &mut FFIExample| { &mut m.integration_notes },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FFIExample>(
                "ExampleMappings.FFIExample",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FFIExample {
        const NAME: &'static str = "FFIExample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.ffi_examples.push(is.read_message()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ffi_config)?;
                    },
                    26 => {
                        self.integration_notes.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.ffi_examples {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.ffi_config.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.integration_notes {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.ffi_examples {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.ffi_config.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.integration_notes {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FFIExample {
            FFIExample::new()
        }

        fn clear(&mut self) {
            self.ffi_examples.clear();
            self.ffi_config.clear();
            self.integration_notes.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FFIExample {
            static instance: FFIExample = FFIExample {
                ffi_examples: ::std::vec::Vec::new(),
                ffi_config: ::protobuf::MessageField::none(),
                integration_notes: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FFIExample {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.FFIExample").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FFIExample {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FFIExample {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `FFIExample`
    pub mod ffiexample {
        // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.FFIExample.Example)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Example {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIExample.Example.kymera_interface)
            pub kymera_interface: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIExample.Example.foreign_interface)
            pub foreign_interface: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIExample.Example.binding_steps)
            pub binding_steps: ::std::vec::Vec<::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIExample.Example.type_conversions)
            pub type_conversions: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.FFIExample.Example.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Example {
            fn default() -> &'a Example {
                <Example as ::protobuf::Message>::default_instance()
            }
        }

        impl Example {
            pub fn new() -> Example {
                ::std::default::Default::default()
            }

            // string kymera_interface = 1;

            pub fn kymera_interface(&self) -> &str {
                &self.kymera_interface
            }

            pub fn clear_kymera_interface(&mut self) {
                self.kymera_interface.clear();
            }

            // Param is passed by value, moved
            pub fn set_kymera_interface(&mut self, v: ::std::string::String) {
                self.kymera_interface = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_kymera_interface(&mut self) -> &mut ::std::string::String {
                &mut self.kymera_interface
            }

            // Take field
            pub fn take_kymera_interface(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.kymera_interface, ::std::string::String::new())
            }

            // string foreign_interface = 2;

            pub fn foreign_interface(&self) -> &str {
                &self.foreign_interface
            }

            pub fn clear_foreign_interface(&mut self) {
                self.foreign_interface.clear();
            }

            // Param is passed by value, moved
            pub fn set_foreign_interface(&mut self, v: ::std::string::String) {
                self.foreign_interface = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_foreign_interface(&mut self) -> &mut ::std::string::String {
                &mut self.foreign_interface
            }

            // Take field
            pub fn take_foreign_interface(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.foreign_interface, ::std::string::String::new())
            }

            // repeated string binding_steps = 3;

            pub fn binding_steps(&self) -> &[::std::string::String] {
                &self.binding_steps
            }

            pub fn clear_binding_steps(&mut self) {
                self.binding_steps.clear();
            }

            // Param is passed by value, moved
            pub fn set_binding_steps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.binding_steps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_binding_steps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.binding_steps
            }

            // Take field
            pub fn take_binding_steps(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.binding_steps, ::std::vec::Vec::new())
            }

            // repeated .kymera_mappings.ExampleMappings.FFIExample.Example.TypeConversionsEntry type_conversions = 4;

            pub fn type_conversions(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.type_conversions
            }

            pub fn clear_type_conversions(&mut self) {
                self.type_conversions.clear();
            }

            // Param is passed by value, moved
            pub fn set_type_conversions(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.type_conversions = v;
            }

            // Mutable pointer to the field.
            pub fn mut_type_conversions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.type_conversions
            }

            // Take field
            pub fn take_type_conversions(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.type_conversions, ::std::collections::HashMap::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "kymera_interface",
                    |m: &Example| { &m.kymera_interface },
                    |m: &mut Example| { &mut m.kymera_interface },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "foreign_interface",
                    |m: &Example| { &m.foreign_interface },
                    |m: &mut Example| { &mut m.foreign_interface },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "binding_steps",
                    |m: &Example| { &m.binding_steps },
                    |m: &mut Example| { &mut m.binding_steps },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "type_conversions",
                    |m: &Example| { &m.type_conversions },
                    |m: &mut Example| { &mut m.type_conversions },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Example>(
                    "ExampleMappings.FFIExample.Example",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Example {
            const NAME: &'static str = "Example";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.kymera_interface = is.read_string()?;
                        },
                        18 => {
                            self.foreign_interface = is.read_string()?;
                        },
                        26 => {
                            self.binding_steps.push(is.read_string()?);
                        },
                        34 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.type_conversions.insert(key, value);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.kymera_interface.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.kymera_interface);
                }
                if !self.foreign_interface.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.foreign_interface);
                }
                for value in &self.binding_steps {
                    my_size += ::protobuf::rt::string_size(3, &value);
                };
                for (k, v) in &self.type_conversions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.kymera_interface.is_empty() {
                    os.write_string(1, &self.kymera_interface)?;
                }
                if !self.foreign_interface.is_empty() {
                    os.write_string(2, &self.foreign_interface)?;
                }
                for v in &self.binding_steps {
                    os.write_string(3, &v)?;
                };
                for (k, v) in &self.type_conversions {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(34)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Example {
                Example::new()
            }

            fn clear(&mut self) {
                self.kymera_interface.clear();
                self.foreign_interface.clear();
                self.binding_steps.clear();
                self.type_conversions.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Example {
                static instance: ::protobuf::rt::Lazy<Example> = ::protobuf::rt::Lazy::new();
                instance.get(Example::new)
            }
        }

        impl ::protobuf::MessageFull for Example {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ExampleMappings.FFIExample.Example").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Example {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Example {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.FFIConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FFIConfig {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIConfig.abi_version)
        pub abi_version: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIConfig.supported_languages)
        pub supported_languages: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIConfig.safety_checks_enabled)
        pub safety_checks_enabled: bool,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.FFIConfig.ffi_features)
        pub ffi_features: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.FFIConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FFIConfig {
        fn default() -> &'a FFIConfig {
            <FFIConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl FFIConfig {
        pub fn new() -> FFIConfig {
            ::std::default::Default::default()
        }

        // string abi_version = 1;

        pub fn abi_version(&self) -> &str {
            &self.abi_version
        }

        pub fn clear_abi_version(&mut self) {
            self.abi_version.clear();
        }

        // Param is passed by value, moved
        pub fn set_abi_version(&mut self, v: ::std::string::String) {
            self.abi_version = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_abi_version(&mut self) -> &mut ::std::string::String {
            &mut self.abi_version
        }

        // Take field
        pub fn take_abi_version(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.abi_version, ::std::string::String::new())
        }

        // repeated string supported_languages = 2;

        pub fn supported_languages(&self) -> &[::std::string::String] {
            &self.supported_languages
        }

        pub fn clear_supported_languages(&mut self) {
            self.supported_languages.clear();
        }

        // Param is passed by value, moved
        pub fn set_supported_languages(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.supported_languages = v;
        }

        // Mutable pointer to the field.
        pub fn mut_supported_languages(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.supported_languages
        }

        // Take field
        pub fn take_supported_languages(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.supported_languages, ::std::vec::Vec::new())
        }

        // bool safety_checks_enabled = 3;

        pub fn safety_checks_enabled(&self) -> bool {
            self.safety_checks_enabled
        }

        pub fn clear_safety_checks_enabled(&mut self) {
            self.safety_checks_enabled = false;
        }

        // Param is passed by value, moved
        pub fn set_safety_checks_enabled(&mut self, v: bool) {
            self.safety_checks_enabled = v;
        }

        // repeated string ffi_features = 4;

        pub fn ffi_features(&self) -> &[::std::string::String] {
            &self.ffi_features
        }

        pub fn clear_ffi_features(&mut self) {
            self.ffi_features.clear();
        }

        // Param is passed by value, moved
        pub fn set_ffi_features(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.ffi_features = v;
        }

        // Mutable pointer to the field.
        pub fn mut_ffi_features(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.ffi_features
        }

        // Take field
        pub fn take_ffi_features(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.ffi_features, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "abi_version",
                |m: &FFIConfig| { &m.abi_version },
                |m: &mut FFIConfig| { &mut m.abi_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "supported_languages",
                |m: &FFIConfig| { &m.supported_languages },
                |m: &mut FFIConfig| { &mut m.supported_languages },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "safety_checks_enabled",
                |m: &FFIConfig| { &m.safety_checks_enabled },
                |m: &mut FFIConfig| { &mut m.safety_checks_enabled },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "ffi_features",
                |m: &FFIConfig| { &m.ffi_features },
                |m: &mut FFIConfig| { &mut m.ffi_features },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FFIConfig>(
                "ExampleMappings.FFIConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FFIConfig {
        const NAME: &'static str = "FFIConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.abi_version = is.read_string()?;
                    },
                    18 => {
                        self.supported_languages.push(is.read_string()?);
                    },
                    24 => {
                        self.safety_checks_enabled = is.read_bool()?;
                    },
                    34 => {
                        self.ffi_features.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.abi_version.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.abi_version);
            }
            for value in &self.supported_languages {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            if self.safety_checks_enabled != false {
                my_size += 1 + 1;
            }
            for value in &self.ffi_features {
                my_size += ::protobuf::rt::string_size(4, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.abi_version.is_empty() {
                os.write_string(1, &self.abi_version)?;
            }
            for v in &self.supported_languages {
                os.write_string(2, &v)?;
            };
            if self.safety_checks_enabled != false {
                os.write_bool(3, self.safety_checks_enabled)?;
            }
            for v in &self.ffi_features {
                os.write_string(4, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FFIConfig {
            FFIConfig::new()
        }

        fn clear(&mut self) {
            self.abi_version.clear();
            self.supported_languages.clear();
            self.safety_checks_enabled = false;
            self.ffi_features.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FFIConfig {
            static instance: FFIConfig = FFIConfig {
                abi_version: ::std::string::String::new(),
                supported_languages: ::std::vec::Vec::new(),
                safety_checks_enabled: false,
                ffi_features: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FFIConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.FFIConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FFIConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FFIConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.TestExample)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestExample {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestExample.test_examples)
        pub test_examples: ::std::vec::Vec<test_example::Example>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestExample.test_config)
        pub test_config: ::protobuf::MessageField<TestConfig>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestExample.testing_guidelines)
        pub testing_guidelines: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.TestExample.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestExample {
        fn default() -> &'a TestExample {
            <TestExample as ::protobuf::Message>::default_instance()
        }
    }

    impl TestExample {
        pub fn new() -> TestExample {
            ::std::default::Default::default()
        }

        // repeated .kymera_mappings.ExampleMappings.TestExample.Example test_examples = 1;

        pub fn test_examples(&self) -> &[test_example::Example] {
            &self.test_examples
        }

        pub fn clear_test_examples(&mut self) {
            self.test_examples.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_examples(&mut self, v: ::std::vec::Vec<test_example::Example>) {
            self.test_examples = v;
        }

        // Mutable pointer to the field.
        pub fn mut_test_examples(&mut self) -> &mut ::std::vec::Vec<test_example::Example> {
            &mut self.test_examples
        }

        // Take field
        pub fn take_test_examples(&mut self) -> ::std::vec::Vec<test_example::Example> {
            ::std::mem::replace(&mut self.test_examples, ::std::vec::Vec::new())
        }

        // .kymera_mappings.ExampleMappings.TestConfig test_config = 2;

        pub fn test_config(&self) -> &TestConfig {
            self.test_config.as_ref().unwrap_or_else(|| <TestConfig as ::protobuf::Message>::default_instance())
        }

        pub fn clear_test_config(&mut self) {
            self.test_config.clear();
        }

        pub fn has_test_config(&self) -> bool {
            self.test_config.is_some()
        }

        // Param is passed by value, moved
        pub fn set_test_config(&mut self, v: TestConfig) {
            self.test_config = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_test_config(&mut self) -> &mut TestConfig {
            self.test_config.mut_or_insert_default()
        }

        // Take field
        pub fn take_test_config(&mut self) -> TestConfig {
            self.test_config.take().unwrap_or_else(|| TestConfig::new())
        }

        // repeated string testing_guidelines = 3;

        pub fn testing_guidelines(&self) -> &[::std::string::String] {
            &self.testing_guidelines
        }

        pub fn clear_testing_guidelines(&mut self) {
            self.testing_guidelines.clear();
        }

        // Param is passed by value, moved
        pub fn set_testing_guidelines(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.testing_guidelines = v;
        }

        // Mutable pointer to the field.
        pub fn mut_testing_guidelines(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.testing_guidelines
        }

        // Take field
        pub fn take_testing_guidelines(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.testing_guidelines, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "test_examples",
                |m: &TestExample| { &m.test_examples },
                |m: &mut TestExample| { &mut m.test_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TestConfig>(
                "test_config",
                |m: &TestExample| { &m.test_config },
                |m: &mut TestExample| { &mut m.test_config },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "testing_guidelines",
                |m: &TestExample| { &m.testing_guidelines },
                |m: &mut TestExample| { &mut m.testing_guidelines },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestExample>(
                "ExampleMappings.TestExample",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestExample {
        const NAME: &'static str = "TestExample";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.test_examples.push(is.read_message()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.test_config)?;
                    },
                    26 => {
                        self.testing_guidelines.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.test_examples {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.test_config.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.testing_guidelines {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.test_examples {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.test_config.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            for v in &self.testing_guidelines {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestExample {
            TestExample::new()
        }

        fn clear(&mut self) {
            self.test_examples.clear();
            self.test_config.clear();
            self.testing_guidelines.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestExample {
            static instance: TestExample = TestExample {
                test_examples: ::std::vec::Vec::new(),
                test_config: ::protobuf::MessageField::none(),
                testing_guidelines: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TestExample {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.TestExample").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestExample {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestExample {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `TestExample`
    pub mod test_example {
        // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.TestExample.Example)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Example {
            // message fields
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestExample.Example.test_case)
            pub test_case: ::std::string::String,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestExample.Example.inputs)
            pub inputs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestExample.Example.expected_outputs)
            pub expected_outputs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestExample.Example.validation_steps)
            pub validation_steps: ::std::vec::Vec<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.TestExample.Example.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Example {
            fn default() -> &'a Example {
                <Example as ::protobuf::Message>::default_instance()
            }
        }

        impl Example {
            pub fn new() -> Example {
                ::std::default::Default::default()
            }

            // string test_case = 1;

            pub fn test_case(&self) -> &str {
                &self.test_case
            }

            pub fn clear_test_case(&mut self) {
                self.test_case.clear();
            }

            // Param is passed by value, moved
            pub fn set_test_case(&mut self, v: ::std::string::String) {
                self.test_case = v;
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_test_case(&mut self) -> &mut ::std::string::String {
                &mut self.test_case
            }

            // Take field
            pub fn take_test_case(&mut self) -> ::std::string::String {
                ::std::mem::replace(&mut self.test_case, ::std::string::String::new())
            }

            // repeated .kymera_mappings.ExampleMappings.TestExample.Example.InputsEntry inputs = 2;

            pub fn inputs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.inputs
            }

            pub fn clear_inputs(&mut self) {
                self.inputs.clear();
            }

            // Param is passed by value, moved
            pub fn set_inputs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.inputs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_inputs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.inputs
            }

            // Take field
            pub fn take_inputs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.inputs, ::std::collections::HashMap::new())
            }

            // repeated .kymera_mappings.ExampleMappings.TestExample.Example.ExpectedOutputsEntry expected_outputs = 3;

            pub fn expected_outputs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &self.expected_outputs
            }

            pub fn clear_expected_outputs(&mut self) {
                self.expected_outputs.clear();
            }

            // Param is passed by value, moved
            pub fn set_expected_outputs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
                self.expected_outputs = v;
            }

            // Mutable pointer to the field.
            pub fn mut_expected_outputs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                &mut self.expected_outputs
            }

            // Take field
            pub fn take_expected_outputs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
                ::std::mem::replace(&mut self.expected_outputs, ::std::collections::HashMap::new())
            }

            // repeated string validation_steps = 4;

            pub fn validation_steps(&self) -> &[::std::string::String] {
                &self.validation_steps
            }

            pub fn clear_validation_steps(&mut self) {
                self.validation_steps.clear();
            }

            // Param is passed by value, moved
            pub fn set_validation_steps(&mut self, v: ::std::vec::Vec<::std::string::String>) {
                self.validation_steps = v;
            }

            // Mutable pointer to the field.
            pub fn mut_validation_steps(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
                &mut self.validation_steps
            }

            // Take field
            pub fn take_validation_steps(&mut self) -> ::std::vec::Vec<::std::string::String> {
                ::std::mem::replace(&mut self.validation_steps, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "test_case",
                    |m: &Example| { &m.test_case },
                    |m: &mut Example| { &mut m.test_case },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "inputs",
                    |m: &Example| { &m.inputs },
                    |m: &mut Example| { &mut m.inputs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                    "expected_outputs",
                    |m: &Example| { &m.expected_outputs },
                    |m: &mut Example| { &mut m.expected_outputs },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "validation_steps",
                    |m: &Example| { &m.validation_steps },
                    |m: &mut Example| { &mut m.validation_steps },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Example>(
                    "ExampleMappings.TestExample.Example",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Example {
            const NAME: &'static str = "Example";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.test_case = is.read_string()?;
                        },
                        18 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.inputs.insert(key, value);
                        },
                        26 => {
                            let len = is.read_raw_varint32()?;
                            let old_limit = is.push_limit(len as u64)?;
                            let mut key = ::std::default::Default::default();
                            let mut value = ::std::default::Default::default();
                            while let Some(tag) = is.read_raw_tag_or_eof()? {
                                match tag {
                                    10 => key = is.read_string()?,
                                    18 => value = is.read_string()?,
                                    _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                                };
                            }
                            is.pop_limit(old_limit);
                            self.expected_outputs.insert(key, value);
                        },
                        34 => {
                            self.validation_steps.push(is.read_string()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.test_case.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.test_case);
                }
                for (k, v) in &self.inputs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                for (k, v) in &self.expected_outputs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
                };
                for value in &self.validation_steps {
                    my_size += ::protobuf::rt::string_size(4, &value);
                };
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.test_case.is_empty() {
                    os.write_string(1, &self.test_case)?;
                }
                for (k, v) in &self.inputs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(18)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                for (k, v) in &self.expected_outputs {
                    let mut entry_size = 0;
                    entry_size += ::protobuf::rt::string_size(1, &k);
                    entry_size += ::protobuf::rt::string_size(2, &v);
                    os.write_raw_varint32(26)?; // Tag.
                    os.write_raw_varint32(entry_size as u32)?;
                    os.write_string(1, &k)?;
                    os.write_string(2, &v)?;
                };
                for v in &self.validation_steps {
                    os.write_string(4, &v)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Example {
                Example::new()
            }

            fn clear(&mut self) {
                self.test_case.clear();
                self.inputs.clear();
                self.expected_outputs.clear();
                self.validation_steps.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Example {
                static instance: ::protobuf::rt::Lazy<Example> = ::protobuf::rt::Lazy::new();
                instance.get(Example::new)
            }
        }

        impl ::protobuf::MessageFull for Example {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("ExampleMappings.TestExample.Example").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Example {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Example {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.TestConfig)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TestConfig {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestConfig.test_name)
        pub test_name: ::std::string::String,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestConfig.test_cases)
        pub test_cases: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestConfig.expected_results)
        pub expected_results: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.TestConfig.automated)
        pub automated: bool,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.TestConfig.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TestConfig {
        fn default() -> &'a TestConfig {
            <TestConfig as ::protobuf::Message>::default_instance()
        }
    }

    impl TestConfig {
        pub fn new() -> TestConfig {
            ::std::default::Default::default()
        }

        // string test_name = 1;

        pub fn test_name(&self) -> &str {
            &self.test_name
        }

        pub fn clear_test_name(&mut self) {
            self.test_name.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_name(&mut self, v: ::std::string::String) {
            self.test_name = v;
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_test_name(&mut self) -> &mut ::std::string::String {
            &mut self.test_name
        }

        // Take field
        pub fn take_test_name(&mut self) -> ::std::string::String {
            ::std::mem::replace(&mut self.test_name, ::std::string::String::new())
        }

        // repeated string test_cases = 2;

        pub fn test_cases(&self) -> &[::std::string::String] {
            &self.test_cases
        }

        pub fn clear_test_cases(&mut self) {
            self.test_cases.clear();
        }

        // Param is passed by value, moved
        pub fn set_test_cases(&mut self, v: ::std::vec::Vec<::std::string::String>) {
            self.test_cases = v;
        }

        // Mutable pointer to the field.
        pub fn mut_test_cases(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
            &mut self.test_cases
        }

        // Take field
        pub fn take_test_cases(&mut self) -> ::std::vec::Vec<::std::string::String> {
            ::std::mem::replace(&mut self.test_cases, ::std::vec::Vec::new())
        }

        // repeated .kymera_mappings.ExampleMappings.TestConfig.ExpectedResultsEntry expected_results = 3;

        pub fn expected_results(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &self.expected_results
        }

        pub fn clear_expected_results(&mut self) {
            self.expected_results.clear();
        }

        // Param is passed by value, moved
        pub fn set_expected_results(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
            self.expected_results = v;
        }

        // Mutable pointer to the field.
        pub fn mut_expected_results(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            &mut self.expected_results
        }

        // Take field
        pub fn take_expected_results(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
            ::std::mem::replace(&mut self.expected_results, ::std::collections::HashMap::new())
        }

        // bool automated = 4;

        pub fn automated(&self) -> bool {
            self.automated
        }

        pub fn clear_automated(&mut self) {
            self.automated = false;
        }

        // Param is passed by value, moved
        pub fn set_automated(&mut self, v: bool) {
            self.automated = v;
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "test_name",
                |m: &TestConfig| { &m.test_name },
                |m: &mut TestConfig| { &mut m.test_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "test_cases",
                |m: &TestConfig| { &m.test_cases },
                |m: &mut TestConfig| { &mut m.test_cases },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
                "expected_results",
                |m: &TestConfig| { &m.expected_results },
                |m: &mut TestConfig| { &mut m.expected_results },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "automated",
                |m: &TestConfig| { &m.automated },
                |m: &mut TestConfig| { &mut m.automated },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TestConfig>(
                "ExampleMappings.TestConfig",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TestConfig {
        const NAME: &'static str = "TestConfig";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.test_name = is.read_string()?;
                    },
                    18 => {
                        self.test_cases.push(is.read_string()?);
                    },
                    26 => {
                        let len = is.read_raw_varint32()?;
                        let old_limit = is.push_limit(len as u64)?;
                        let mut key = ::std::default::Default::default();
                        let mut value = ::std::default::Default::default();
                        while let Some(tag) = is.read_raw_tag_or_eof()? {
                            match tag {
                                10 => key = is.read_string()?,
                                18 => value = is.read_string()?,
                                _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                            };
                        }
                        is.pop_limit(old_limit);
                        self.expected_results.insert(key, value);
                    },
                    32 => {
                        self.automated = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.test_name.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.test_name);
            }
            for value in &self.test_cases {
                my_size += ::protobuf::rt::string_size(2, &value);
            };
            for (k, v) in &self.expected_results {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
            };
            if self.automated != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.test_name.is_empty() {
                os.write_string(1, &self.test_name)?;
            }
            for v in &self.test_cases {
                os.write_string(2, &v)?;
            };
            for (k, v) in &self.expected_results {
                let mut entry_size = 0;
                entry_size += ::protobuf::rt::string_size(1, &k);
                entry_size += ::protobuf::rt::string_size(2, &v);
                os.write_raw_varint32(26)?; // Tag.
                os.write_raw_varint32(entry_size as u32)?;
                os.write_string(1, &k)?;
                os.write_string(2, &v)?;
            };
            if self.automated != false {
                os.write_bool(4, self.automated)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TestConfig {
            TestConfig::new()
        }

        fn clear(&mut self) {
            self.test_name.clear();
            self.test_cases.clear();
            self.expected_results.clear();
            self.automated = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TestConfig {
            static instance: ::protobuf::rt::Lazy<TestConfig> = ::protobuf::rt::Lazy::new();
            instance.get(TestConfig::new)
        }
    }

    impl ::protobuf::MessageFull for TestConfig {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.TestConfig").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TestConfig {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TestConfig {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.KymeraToRustExamples)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KymeraToRustExamples {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToRustExamples.function_examples)
        pub function_examples: ::protobuf::MessageField<FunctionMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToRustExamples.type_examples)
        pub type_examples: ::protobuf::MessageField<TypeMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToRustExamples.error_examples)
        pub error_examples: ::protobuf::MessageField<ErrorHandlingExample>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.KymeraToRustExamples.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KymeraToRustExamples {
        fn default() -> &'a KymeraToRustExamples {
            <KymeraToRustExamples as ::protobuf::Message>::default_instance()
        }
    }

    impl KymeraToRustExamples {
        pub fn new() -> KymeraToRustExamples {
            ::std::default::Default::default()
        }

        // .kymera_mappings.ExampleMappings.FunctionMapping function_examples = 1;

        pub fn function_examples(&self) -> &FunctionMapping {
            self.function_examples.as_ref().unwrap_or_else(|| <FunctionMapping as ::protobuf::Message>::default_instance())
        }

        pub fn clear_function_examples(&mut self) {
            self.function_examples.clear();
        }

        pub fn has_function_examples(&self) -> bool {
            self.function_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_function_examples(&mut self, v: FunctionMapping) {
            self.function_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_function_examples(&mut self) -> &mut FunctionMapping {
            self.function_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_function_examples(&mut self) -> FunctionMapping {
            self.function_examples.take().unwrap_or_else(|| FunctionMapping::new())
        }

        // .kymera_mappings.ExampleMappings.TypeMapping type_examples = 2;

        pub fn type_examples(&self) -> &TypeMapping {
            self.type_examples.as_ref().unwrap_or_else(|| <TypeMapping as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_examples(&mut self) {
            self.type_examples.clear();
        }

        pub fn has_type_examples(&self) -> bool {
            self.type_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_examples(&mut self, v: TypeMapping) {
            self.type_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type_examples(&mut self) -> &mut TypeMapping {
            self.type_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_examples(&mut self) -> TypeMapping {
            self.type_examples.take().unwrap_or_else(|| TypeMapping::new())
        }

        // .kymera_mappings.ExampleMappings.ErrorHandlingExample error_examples = 3;

        pub fn error_examples(&self) -> &ErrorHandlingExample {
            self.error_examples.as_ref().unwrap_or_else(|| <ErrorHandlingExample as ::protobuf::Message>::default_instance())
        }

        pub fn clear_error_examples(&mut self) {
            self.error_examples.clear();
        }

        pub fn has_error_examples(&self) -> bool {
            self.error_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_error_examples(&mut self, v: ErrorHandlingExample) {
            self.error_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_error_examples(&mut self) -> &mut ErrorHandlingExample {
            self.error_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_error_examples(&mut self) -> ErrorHandlingExample {
            self.error_examples.take().unwrap_or_else(|| ErrorHandlingExample::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionMapping>(
                "function_examples",
                |m: &KymeraToRustExamples| { &m.function_examples },
                |m: &mut KymeraToRustExamples| { &mut m.function_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypeMapping>(
                "type_examples",
                |m: &KymeraToRustExamples| { &m.type_examples },
                |m: &mut KymeraToRustExamples| { &mut m.type_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ErrorHandlingExample>(
                "error_examples",
                |m: &KymeraToRustExamples| { &m.error_examples },
                |m: &mut KymeraToRustExamples| { &mut m.error_examples },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KymeraToRustExamples>(
                "ExampleMappings.KymeraToRustExamples",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KymeraToRustExamples {
        const NAME: &'static str = "KymeraToRustExamples";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.function_examples)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_examples)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_examples)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.function_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.type_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.error_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.function_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.type_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.error_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KymeraToRustExamples {
            KymeraToRustExamples::new()
        }

        fn clear(&mut self) {
            self.function_examples.clear();
            self.type_examples.clear();
            self.error_examples.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KymeraToRustExamples {
            static instance: KymeraToRustExamples = KymeraToRustExamples {
                function_examples: ::protobuf::MessageField::none(),
                type_examples: ::protobuf::MessageField::none(),
                error_examples: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KymeraToRustExamples {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.KymeraToRustExamples").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KymeraToRustExamples {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KymeraToRustExamples {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.KymeraToPythonExamples)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KymeraToPythonExamples {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToPythonExamples.function_examples)
        pub function_examples: ::protobuf::MessageField<FunctionMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToPythonExamples.type_examples)
        pub type_examples: ::protobuf::MessageField<TypeMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToPythonExamples.error_examples)
        pub error_examples: ::protobuf::MessageField<ErrorHandlingExample>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.KymeraToPythonExamples.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KymeraToPythonExamples {
        fn default() -> &'a KymeraToPythonExamples {
            <KymeraToPythonExamples as ::protobuf::Message>::default_instance()
        }
    }

    impl KymeraToPythonExamples {
        pub fn new() -> KymeraToPythonExamples {
            ::std::default::Default::default()
        }

        // .kymera_mappings.ExampleMappings.FunctionMapping function_examples = 1;

        pub fn function_examples(&self) -> &FunctionMapping {
            self.function_examples.as_ref().unwrap_or_else(|| <FunctionMapping as ::protobuf::Message>::default_instance())
        }

        pub fn clear_function_examples(&mut self) {
            self.function_examples.clear();
        }

        pub fn has_function_examples(&self) -> bool {
            self.function_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_function_examples(&mut self, v: FunctionMapping) {
            self.function_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_function_examples(&mut self) -> &mut FunctionMapping {
            self.function_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_function_examples(&mut self) -> FunctionMapping {
            self.function_examples.take().unwrap_or_else(|| FunctionMapping::new())
        }

        // .kymera_mappings.ExampleMappings.TypeMapping type_examples = 2;

        pub fn type_examples(&self) -> &TypeMapping {
            self.type_examples.as_ref().unwrap_or_else(|| <TypeMapping as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_examples(&mut self) {
            self.type_examples.clear();
        }

        pub fn has_type_examples(&self) -> bool {
            self.type_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_examples(&mut self, v: TypeMapping) {
            self.type_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type_examples(&mut self) -> &mut TypeMapping {
            self.type_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_examples(&mut self) -> TypeMapping {
            self.type_examples.take().unwrap_or_else(|| TypeMapping::new())
        }

        // .kymera_mappings.ExampleMappings.ErrorHandlingExample error_examples = 3;

        pub fn error_examples(&self) -> &ErrorHandlingExample {
            self.error_examples.as_ref().unwrap_or_else(|| <ErrorHandlingExample as ::protobuf::Message>::default_instance())
        }

        pub fn clear_error_examples(&mut self) {
            self.error_examples.clear();
        }

        pub fn has_error_examples(&self) -> bool {
            self.error_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_error_examples(&mut self, v: ErrorHandlingExample) {
            self.error_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_error_examples(&mut self) -> &mut ErrorHandlingExample {
            self.error_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_error_examples(&mut self) -> ErrorHandlingExample {
            self.error_examples.take().unwrap_or_else(|| ErrorHandlingExample::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionMapping>(
                "function_examples",
                |m: &KymeraToPythonExamples| { &m.function_examples },
                |m: &mut KymeraToPythonExamples| { &mut m.function_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypeMapping>(
                "type_examples",
                |m: &KymeraToPythonExamples| { &m.type_examples },
                |m: &mut KymeraToPythonExamples| { &mut m.type_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ErrorHandlingExample>(
                "error_examples",
                |m: &KymeraToPythonExamples| { &m.error_examples },
                |m: &mut KymeraToPythonExamples| { &mut m.error_examples },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KymeraToPythonExamples>(
                "ExampleMappings.KymeraToPythonExamples",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KymeraToPythonExamples {
        const NAME: &'static str = "KymeraToPythonExamples";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.function_examples)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_examples)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_examples)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.function_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.type_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.error_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.function_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.type_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.error_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KymeraToPythonExamples {
            KymeraToPythonExamples::new()
        }

        fn clear(&mut self) {
            self.function_examples.clear();
            self.type_examples.clear();
            self.error_examples.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KymeraToPythonExamples {
            static instance: KymeraToPythonExamples = KymeraToPythonExamples {
                function_examples: ::protobuf::MessageField::none(),
                type_examples: ::protobuf::MessageField::none(),
                error_examples: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KymeraToPythonExamples {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.KymeraToPythonExamples").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KymeraToPythonExamples {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KymeraToPythonExamples {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:kymera_mappings.ExampleMappings.KymeraToTypeScriptExamples)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KymeraToTypeScriptExamples {
        // message fields
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToTypeScriptExamples.function_examples)
        pub function_examples: ::protobuf::MessageField<FunctionMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToTypeScriptExamples.type_examples)
        pub type_examples: ::protobuf::MessageField<TypeMapping>,
        // @@protoc_insertion_point(field:kymera_mappings.ExampleMappings.KymeraToTypeScriptExamples.error_examples)
        pub error_examples: ::protobuf::MessageField<ErrorHandlingExample>,
        // special fields
        // @@protoc_insertion_point(special_field:kymera_mappings.ExampleMappings.KymeraToTypeScriptExamples.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KymeraToTypeScriptExamples {
        fn default() -> &'a KymeraToTypeScriptExamples {
            <KymeraToTypeScriptExamples as ::protobuf::Message>::default_instance()
        }
    }

    impl KymeraToTypeScriptExamples {
        pub fn new() -> KymeraToTypeScriptExamples {
            ::std::default::Default::default()
        }

        // .kymera_mappings.ExampleMappings.FunctionMapping function_examples = 1;

        pub fn function_examples(&self) -> &FunctionMapping {
            self.function_examples.as_ref().unwrap_or_else(|| <FunctionMapping as ::protobuf::Message>::default_instance())
        }

        pub fn clear_function_examples(&mut self) {
            self.function_examples.clear();
        }

        pub fn has_function_examples(&self) -> bool {
            self.function_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_function_examples(&mut self, v: FunctionMapping) {
            self.function_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_function_examples(&mut self) -> &mut FunctionMapping {
            self.function_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_function_examples(&mut self) -> FunctionMapping {
            self.function_examples.take().unwrap_or_else(|| FunctionMapping::new())
        }

        // .kymera_mappings.ExampleMappings.TypeMapping type_examples = 2;

        pub fn type_examples(&self) -> &TypeMapping {
            self.type_examples.as_ref().unwrap_or_else(|| <TypeMapping as ::protobuf::Message>::default_instance())
        }

        pub fn clear_type_examples(&mut self) {
            self.type_examples.clear();
        }

        pub fn has_type_examples(&self) -> bool {
            self.type_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_examples(&mut self, v: TypeMapping) {
            self.type_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_type_examples(&mut self) -> &mut TypeMapping {
            self.type_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_type_examples(&mut self) -> TypeMapping {
            self.type_examples.take().unwrap_or_else(|| TypeMapping::new())
        }

        // .kymera_mappings.ExampleMappings.ErrorHandlingExample error_examples = 3;

        pub fn error_examples(&self) -> &ErrorHandlingExample {
            self.error_examples.as_ref().unwrap_or_else(|| <ErrorHandlingExample as ::protobuf::Message>::default_instance())
        }

        pub fn clear_error_examples(&mut self) {
            self.error_examples.clear();
        }

        pub fn has_error_examples(&self) -> bool {
            self.error_examples.is_some()
        }

        // Param is passed by value, moved
        pub fn set_error_examples(&mut self, v: ErrorHandlingExample) {
            self.error_examples = ::protobuf::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_error_examples(&mut self) -> &mut ErrorHandlingExample {
            self.error_examples.mut_or_insert_default()
        }

        // Take field
        pub fn take_error_examples(&mut self) -> ErrorHandlingExample {
            self.error_examples.take().unwrap_or_else(|| ErrorHandlingExample::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FunctionMapping>(
                "function_examples",
                |m: &KymeraToTypeScriptExamples| { &m.function_examples },
                |m: &mut KymeraToTypeScriptExamples| { &mut m.function_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TypeMapping>(
                "type_examples",
                |m: &KymeraToTypeScriptExamples| { &m.type_examples },
                |m: &mut KymeraToTypeScriptExamples| { &mut m.type_examples },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ErrorHandlingExample>(
                "error_examples",
                |m: &KymeraToTypeScriptExamples| { &m.error_examples },
                |m: &mut KymeraToTypeScriptExamples| { &mut m.error_examples },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KymeraToTypeScriptExamples>(
                "ExampleMappings.KymeraToTypeScriptExamples",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KymeraToTypeScriptExamples {
        const NAME: &'static str = "KymeraToTypeScriptExamples";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.function_examples)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_examples)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.error_examples)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.function_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.type_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.error_examples.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.function_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.type_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.error_examples.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KymeraToTypeScriptExamples {
            KymeraToTypeScriptExamples::new()
        }

        fn clear(&mut self) {
            self.function_examples.clear();
            self.type_examples.clear();
            self.error_examples.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KymeraToTypeScriptExamples {
            static instance: KymeraToTypeScriptExamples = KymeraToTypeScriptExamples {
                function_examples: ::protobuf::MessageField::none(),
                type_examples: ::protobuf::MessageField::none(),
                error_examples: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KymeraToTypeScriptExamples {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ExampleMappings.KymeraToTypeScriptExamples").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KymeraToTypeScriptExamples {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KymeraToTypeScriptExamples {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.ComputationalCost)
pub enum ComputationalCost {
    // @@protoc_insertion_point(enum_value:kymera_mappings.ComputationalCost.CCU)
    CCU = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.ComputationalCost.CCZ)
    CCZ = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.ComputationalCost.CCL)
    CCL = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.ComputationalCost.CCM)
    CCM = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.ComputationalCost.CCH)
    CCH = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.ComputationalCost.CCV)
    CCV = 5,
}

impl ::protobuf::Enum for ComputationalCost {
    const NAME: &'static str = "ComputationalCost";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ComputationalCost> {
        match value {
            0 => ::std::option::Option::Some(ComputationalCost::CCU),
            1 => ::std::option::Option::Some(ComputationalCost::CCZ),
            2 => ::std::option::Option::Some(ComputationalCost::CCL),
            3 => ::std::option::Option::Some(ComputationalCost::CCM),
            4 => ::std::option::Option::Some(ComputationalCost::CCH),
            5 => ::std::option::Option::Some(ComputationalCost::CCV),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ComputationalCost> {
        match str {
            "CCU" => ::std::option::Option::Some(ComputationalCost::CCU),
            "CCZ" => ::std::option::Option::Some(ComputationalCost::CCZ),
            "CCL" => ::std::option::Option::Some(ComputationalCost::CCL),
            "CCM" => ::std::option::Option::Some(ComputationalCost::CCM),
            "CCH" => ::std::option::Option::Some(ComputationalCost::CCH),
            "CCV" => ::std::option::Option::Some(ComputationalCost::CCV),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ComputationalCost] = &[
        ComputationalCost::CCU,
        ComputationalCost::CCZ,
        ComputationalCost::CCL,
        ComputationalCost::CCM,
        ComputationalCost::CCH,
        ComputationalCost::CCV,
    ];
}

impl ::protobuf::EnumFull for ComputationalCost {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ComputationalCost").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ComputationalCost {
    fn default() -> Self {
        ComputationalCost::CCU
    }
}

impl ComputationalCost {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ComputationalCost>("ComputationalCost")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.MemoryManagement)
pub enum MemoryManagement {
    // @@protoc_insertion_point(enum_value:kymera_mappings.MemoryManagement.MMU)
    MMU = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.MemoryManagement.MMSTAT)
    MMSTAT = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.MemoryManagement.MMSTAK)
    MMSTAK = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.MemoryManagement.MMHEAP)
    MMHEAP = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.MemoryManagement.MMBRWD)
    MMBRWD = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.MemoryManagement.MMSHRD)
    MMSHRD = 5,
}

impl ::protobuf::Enum for MemoryManagement {
    const NAME: &'static str = "MemoryManagement";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MemoryManagement> {
        match value {
            0 => ::std::option::Option::Some(MemoryManagement::MMU),
            1 => ::std::option::Option::Some(MemoryManagement::MMSTAT),
            2 => ::std::option::Option::Some(MemoryManagement::MMSTAK),
            3 => ::std::option::Option::Some(MemoryManagement::MMHEAP),
            4 => ::std::option::Option::Some(MemoryManagement::MMBRWD),
            5 => ::std::option::Option::Some(MemoryManagement::MMSHRD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MemoryManagement> {
        match str {
            "MMU" => ::std::option::Option::Some(MemoryManagement::MMU),
            "MMSTAT" => ::std::option::Option::Some(MemoryManagement::MMSTAT),
            "MMSTAK" => ::std::option::Option::Some(MemoryManagement::MMSTAK),
            "MMHEAP" => ::std::option::Option::Some(MemoryManagement::MMHEAP),
            "MMBRWD" => ::std::option::Option::Some(MemoryManagement::MMBRWD),
            "MMSHRD" => ::std::option::Option::Some(MemoryManagement::MMSHRD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MemoryManagement] = &[
        MemoryManagement::MMU,
        MemoryManagement::MMSTAT,
        MemoryManagement::MMSTAK,
        MemoryManagement::MMHEAP,
        MemoryManagement::MMBRWD,
        MemoryManagement::MMSHRD,
    ];
}

impl ::protobuf::EnumFull for MemoryManagement {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MemoryManagement").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MemoryManagement {
    fn default() -> Self {
        MemoryManagement::MMU
    }
}

impl MemoryManagement {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MemoryManagement>("MemoryManagement")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.KymeraConstruct)
pub enum KymeraConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.KYMERA_UNKNOWN_CONSTRUCT)
    KYMERA_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.des)
    des = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.SPACS)
    SPACS = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.forma)
    forma = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.enum)
    enum_ = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.imp)
    imp = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.fnc)
    fnc = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.soy)
    soy = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.SNC)
    SNC = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.XNC)
    XNC = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.SPRO)
    SPRO = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.Res)
    Res = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.djq)
    djq = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.ret)
    ret = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.REV)
    REV = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.wyo)
    wyo = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.ate)
    ate = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.MTH)
    MTH = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.SPA)
    SPA = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.Optn)
    Optn = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.Stilo)
    Stilo = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.Strng)
    Strng = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.MUTA)
    MUTA = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.NMUT)
    NMUT = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.IDIT)
    IDIT = 24,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.IFZ)
    IFZ = 25,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.i8)
    i8 = 26,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.i16)
    i16 = 27,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.i32)
    i32 = 28,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.i64)
    i64 = 29,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.i128)
    i128 = 30,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.ISZE)
    ISZE = 31,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.u8)
    u8 = 32,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.u16)
    u16 = 33,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.u32)
    u32 = 34,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.u64)
    u64 = 35,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.u128)
    u128 = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.USZE)
    USZE = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.f32)
    f32 = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.f64)
    f64 = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.PRNT)
    PRNT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.CMT)
    CMT = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.BMT)
    BMT = 42,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.DMT)
    DMT = 43,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.AICG)
    AICG = 44,
    // @@protoc_insertion_point(enum_value:kymera_mappings.KymeraConstruct.VERX)
    VERX = 45,
}

impl ::protobuf::Enum for KymeraConstruct {
    const NAME: &'static str = "KymeraConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<KymeraConstruct> {
        match value {
            0 => ::std::option::Option::Some(KymeraConstruct::KYMERA_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(KymeraConstruct::des),
            2 => ::std::option::Option::Some(KymeraConstruct::SPACS),
            3 => ::std::option::Option::Some(KymeraConstruct::forma),
            4 => ::std::option::Option::Some(KymeraConstruct::enum_),
            5 => ::std::option::Option::Some(KymeraConstruct::imp),
            6 => ::std::option::Option::Some(KymeraConstruct::fnc),
            7 => ::std::option::Option::Some(KymeraConstruct::soy),
            8 => ::std::option::Option::Some(KymeraConstruct::SNC),
            9 => ::std::option::Option::Some(KymeraConstruct::XNC),
            10 => ::std::option::Option::Some(KymeraConstruct::SPRO),
            11 => ::std::option::Option::Some(KymeraConstruct::Res),
            12 => ::std::option::Option::Some(KymeraConstruct::djq),
            13 => ::std::option::Option::Some(KymeraConstruct::ret),
            14 => ::std::option::Option::Some(KymeraConstruct::REV),
            15 => ::std::option::Option::Some(KymeraConstruct::wyo),
            16 => ::std::option::Option::Some(KymeraConstruct::ate),
            17 => ::std::option::Option::Some(KymeraConstruct::MTH),
            18 => ::std::option::Option::Some(KymeraConstruct::SPA),
            19 => ::std::option::Option::Some(KymeraConstruct::Optn),
            20 => ::std::option::Option::Some(KymeraConstruct::Stilo),
            21 => ::std::option::Option::Some(KymeraConstruct::Strng),
            22 => ::std::option::Option::Some(KymeraConstruct::MUTA),
            23 => ::std::option::Option::Some(KymeraConstruct::NMUT),
            24 => ::std::option::Option::Some(KymeraConstruct::IDIT),
            25 => ::std::option::Option::Some(KymeraConstruct::IFZ),
            26 => ::std::option::Option::Some(KymeraConstruct::i8),
            27 => ::std::option::Option::Some(KymeraConstruct::i16),
            28 => ::std::option::Option::Some(KymeraConstruct::i32),
            29 => ::std::option::Option::Some(KymeraConstruct::i64),
            30 => ::std::option::Option::Some(KymeraConstruct::i128),
            31 => ::std::option::Option::Some(KymeraConstruct::ISZE),
            32 => ::std::option::Option::Some(KymeraConstruct::u8),
            33 => ::std::option::Option::Some(KymeraConstruct::u16),
            34 => ::std::option::Option::Some(KymeraConstruct::u32),
            35 => ::std::option::Option::Some(KymeraConstruct::u64),
            36 => ::std::option::Option::Some(KymeraConstruct::u128),
            37 => ::std::option::Option::Some(KymeraConstruct::USZE),
            38 => ::std::option::Option::Some(KymeraConstruct::f32),
            39 => ::std::option::Option::Some(KymeraConstruct::f64),
            40 => ::std::option::Option::Some(KymeraConstruct::PRNT),
            41 => ::std::option::Option::Some(KymeraConstruct::CMT),
            42 => ::std::option::Option::Some(KymeraConstruct::BMT),
            43 => ::std::option::Option::Some(KymeraConstruct::DMT),
            44 => ::std::option::Option::Some(KymeraConstruct::AICG),
            45 => ::std::option::Option::Some(KymeraConstruct::VERX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<KymeraConstruct> {
        match str {
            "KYMERA_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(KymeraConstruct::KYMERA_UNKNOWN_CONSTRUCT),
            "des" => ::std::option::Option::Some(KymeraConstruct::des),
            "SPACS" => ::std::option::Option::Some(KymeraConstruct::SPACS),
            "forma" => ::std::option::Option::Some(KymeraConstruct::forma),
            "enum" => ::std::option::Option::Some(KymeraConstruct::enum_),
            "imp" => ::std::option::Option::Some(KymeraConstruct::imp),
            "fnc" => ::std::option::Option::Some(KymeraConstruct::fnc),
            "soy" => ::std::option::Option::Some(KymeraConstruct::soy),
            "SNC" => ::std::option::Option::Some(KymeraConstruct::SNC),
            "XNC" => ::std::option::Option::Some(KymeraConstruct::XNC),
            "SPRO" => ::std::option::Option::Some(KymeraConstruct::SPRO),
            "Res" => ::std::option::Option::Some(KymeraConstruct::Res),
            "djq" => ::std::option::Option::Some(KymeraConstruct::djq),
            "ret" => ::std::option::Option::Some(KymeraConstruct::ret),
            "REV" => ::std::option::Option::Some(KymeraConstruct::REV),
            "wyo" => ::std::option::Option::Some(KymeraConstruct::wyo),
            "ate" => ::std::option::Option::Some(KymeraConstruct::ate),
            "MTH" => ::std::option::Option::Some(KymeraConstruct::MTH),
            "SPA" => ::std::option::Option::Some(KymeraConstruct::SPA),
            "Optn" => ::std::option::Option::Some(KymeraConstruct::Optn),
            "Stilo" => ::std::option::Option::Some(KymeraConstruct::Stilo),
            "Strng" => ::std::option::Option::Some(KymeraConstruct::Strng),
            "MUTA" => ::std::option::Option::Some(KymeraConstruct::MUTA),
            "NMUT" => ::std::option::Option::Some(KymeraConstruct::NMUT),
            "IDIT" => ::std::option::Option::Some(KymeraConstruct::IDIT),
            "IFZ" => ::std::option::Option::Some(KymeraConstruct::IFZ),
            "i8" => ::std::option::Option::Some(KymeraConstruct::i8),
            "i16" => ::std::option::Option::Some(KymeraConstruct::i16),
            "i32" => ::std::option::Option::Some(KymeraConstruct::i32),
            "i64" => ::std::option::Option::Some(KymeraConstruct::i64),
            "i128" => ::std::option::Option::Some(KymeraConstruct::i128),
            "ISZE" => ::std::option::Option::Some(KymeraConstruct::ISZE),
            "u8" => ::std::option::Option::Some(KymeraConstruct::u8),
            "u16" => ::std::option::Option::Some(KymeraConstruct::u16),
            "u32" => ::std::option::Option::Some(KymeraConstruct::u32),
            "u64" => ::std::option::Option::Some(KymeraConstruct::u64),
            "u128" => ::std::option::Option::Some(KymeraConstruct::u128),
            "USZE" => ::std::option::Option::Some(KymeraConstruct::USZE),
            "f32" => ::std::option::Option::Some(KymeraConstruct::f32),
            "f64" => ::std::option::Option::Some(KymeraConstruct::f64),
            "PRNT" => ::std::option::Option::Some(KymeraConstruct::PRNT),
            "CMT" => ::std::option::Option::Some(KymeraConstruct::CMT),
            "BMT" => ::std::option::Option::Some(KymeraConstruct::BMT),
            "DMT" => ::std::option::Option::Some(KymeraConstruct::DMT),
            "AICG" => ::std::option::Option::Some(KymeraConstruct::AICG),
            "VERX" => ::std::option::Option::Some(KymeraConstruct::VERX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [KymeraConstruct] = &[
        KymeraConstruct::KYMERA_UNKNOWN_CONSTRUCT,
        KymeraConstruct::des,
        KymeraConstruct::SPACS,
        KymeraConstruct::forma,
        KymeraConstruct::enum_,
        KymeraConstruct::imp,
        KymeraConstruct::fnc,
        KymeraConstruct::soy,
        KymeraConstruct::SNC,
        KymeraConstruct::XNC,
        KymeraConstruct::SPRO,
        KymeraConstruct::Res,
        KymeraConstruct::djq,
        KymeraConstruct::ret,
        KymeraConstruct::REV,
        KymeraConstruct::wyo,
        KymeraConstruct::ate,
        KymeraConstruct::MTH,
        KymeraConstruct::SPA,
        KymeraConstruct::Optn,
        KymeraConstruct::Stilo,
        KymeraConstruct::Strng,
        KymeraConstruct::MUTA,
        KymeraConstruct::NMUT,
        KymeraConstruct::IDIT,
        KymeraConstruct::IFZ,
        KymeraConstruct::i8,
        KymeraConstruct::i16,
        KymeraConstruct::i32,
        KymeraConstruct::i64,
        KymeraConstruct::i128,
        KymeraConstruct::ISZE,
        KymeraConstruct::u8,
        KymeraConstruct::u16,
        KymeraConstruct::u32,
        KymeraConstruct::u64,
        KymeraConstruct::u128,
        KymeraConstruct::USZE,
        KymeraConstruct::f32,
        KymeraConstruct::f64,
        KymeraConstruct::PRNT,
        KymeraConstruct::CMT,
        KymeraConstruct::BMT,
        KymeraConstruct::DMT,
        KymeraConstruct::AICG,
        KymeraConstruct::VERX,
    ];
}

impl ::protobuf::EnumFull for KymeraConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("KymeraConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for KymeraConstruct {
    fn default() -> Self {
        KymeraConstruct::KYMERA_UNKNOWN_CONSTRUCT
    }
}

impl KymeraConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<KymeraConstruct>("KymeraConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.RustConstruct)
pub enum RustConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_UNKNOWN_CONSTRUCT)
    RUST_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_USE)
    RUST_USE = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_SCOPE)
    RUST_SCOPE = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_STRUCT)
    RUST_STRUCT = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_ENUM)
    RUST_ENUM = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_IMPL)
    RUST_IMPL = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_METHOD)
    RUST_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_FN)
    RUST_FN = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_AWAIT)
    RUST_AWAIT = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_LET)
    RUST_LET = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_RESULT)
    RUST_RESULT = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_RETURN)
    RUST_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_CATCH)
    RUST_CATCH = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_SELF)
    RUST_SELF = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_WHILE)
    RUST_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_TRY)
    RUST_TRY = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_MATCH)
    RUST_MATCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_FOR)
    RUST_FOR = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_TUPLE)
    RUST_TUPLE = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_OPTION)
    RUST_OPTION = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_STR)
    RUST_STR = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_STRING)
    RUST_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_I8)
    RUST_I8 = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_I16)
    RUST_I16 = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_I32)
    RUST_I32 = 24,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_I64)
    RUST_I64 = 25,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_I128)
    RUST_I128 = 26,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_ISIZE)
    RUST_ISIZE = 27,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_U8)
    RUST_U8 = 28,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_U16)
    RUST_U16 = 29,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_U32)
    RUST_U32 = 30,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_U64)
    RUST_U64 = 31,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_U128)
    RUST_U128 = 32,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_USIZE)
    RUST_USIZE = 33,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_F32)
    RUST_F32 = 34,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_F64)
    RUST_F64 = 35,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_IDENT)
    RUST_IDENT = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_TRAIT)
    RUST_TRAIT = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_MUT)
    RUST_MUT = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_COMMENT)
    RUST_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_BLOCK_COMMENT)
    RUST_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RustConstruct.RUST_DOC_COMMENT)
    RUST_DOC_COMMENT = 41,
}

impl ::protobuf::Enum for RustConstruct {
    const NAME: &'static str = "RustConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RustConstruct> {
        match value {
            0 => ::std::option::Option::Some(RustConstruct::RUST_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(RustConstruct::RUST_USE),
            2 => ::std::option::Option::Some(RustConstruct::RUST_SCOPE),
            3 => ::std::option::Option::Some(RustConstruct::RUST_STRUCT),
            4 => ::std::option::Option::Some(RustConstruct::RUST_ENUM),
            5 => ::std::option::Option::Some(RustConstruct::RUST_IMPL),
            6 => ::std::option::Option::Some(RustConstruct::RUST_METHOD),
            7 => ::std::option::Option::Some(RustConstruct::RUST_FN),
            8 => ::std::option::Option::Some(RustConstruct::RUST_AWAIT),
            9 => ::std::option::Option::Some(RustConstruct::RUST_LET),
            10 => ::std::option::Option::Some(RustConstruct::RUST_RESULT),
            11 => ::std::option::Option::Some(RustConstruct::RUST_RETURN),
            12 => ::std::option::Option::Some(RustConstruct::RUST_CATCH),
            13 => ::std::option::Option::Some(RustConstruct::RUST_SELF),
            14 => ::std::option::Option::Some(RustConstruct::RUST_WHILE),
            15 => ::std::option::Option::Some(RustConstruct::RUST_TRY),
            16 => ::std::option::Option::Some(RustConstruct::RUST_MATCH),
            17 => ::std::option::Option::Some(RustConstruct::RUST_FOR),
            18 => ::std::option::Option::Some(RustConstruct::RUST_TUPLE),
            19 => ::std::option::Option::Some(RustConstruct::RUST_OPTION),
            20 => ::std::option::Option::Some(RustConstruct::RUST_STR),
            21 => ::std::option::Option::Some(RustConstruct::RUST_STRING),
            22 => ::std::option::Option::Some(RustConstruct::RUST_I8),
            23 => ::std::option::Option::Some(RustConstruct::RUST_I16),
            24 => ::std::option::Option::Some(RustConstruct::RUST_I32),
            25 => ::std::option::Option::Some(RustConstruct::RUST_I64),
            26 => ::std::option::Option::Some(RustConstruct::RUST_I128),
            27 => ::std::option::Option::Some(RustConstruct::RUST_ISIZE),
            28 => ::std::option::Option::Some(RustConstruct::RUST_U8),
            29 => ::std::option::Option::Some(RustConstruct::RUST_U16),
            30 => ::std::option::Option::Some(RustConstruct::RUST_U32),
            31 => ::std::option::Option::Some(RustConstruct::RUST_U64),
            32 => ::std::option::Option::Some(RustConstruct::RUST_U128),
            33 => ::std::option::Option::Some(RustConstruct::RUST_USIZE),
            34 => ::std::option::Option::Some(RustConstruct::RUST_F32),
            35 => ::std::option::Option::Some(RustConstruct::RUST_F64),
            36 => ::std::option::Option::Some(RustConstruct::RUST_IDENT),
            37 => ::std::option::Option::Some(RustConstruct::RUST_TRAIT),
            38 => ::std::option::Option::Some(RustConstruct::RUST_MUT),
            39 => ::std::option::Option::Some(RustConstruct::RUST_COMMENT),
            40 => ::std::option::Option::Some(RustConstruct::RUST_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(RustConstruct::RUST_DOC_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RustConstruct> {
        match str {
            "RUST_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(RustConstruct::RUST_UNKNOWN_CONSTRUCT),
            "RUST_USE" => ::std::option::Option::Some(RustConstruct::RUST_USE),
            "RUST_SCOPE" => ::std::option::Option::Some(RustConstruct::RUST_SCOPE),
            "RUST_STRUCT" => ::std::option::Option::Some(RustConstruct::RUST_STRUCT),
            "RUST_ENUM" => ::std::option::Option::Some(RustConstruct::RUST_ENUM),
            "RUST_IMPL" => ::std::option::Option::Some(RustConstruct::RUST_IMPL),
            "RUST_METHOD" => ::std::option::Option::Some(RustConstruct::RUST_METHOD),
            "RUST_FN" => ::std::option::Option::Some(RustConstruct::RUST_FN),
            "RUST_AWAIT" => ::std::option::Option::Some(RustConstruct::RUST_AWAIT),
            "RUST_LET" => ::std::option::Option::Some(RustConstruct::RUST_LET),
            "RUST_RESULT" => ::std::option::Option::Some(RustConstruct::RUST_RESULT),
            "RUST_RETURN" => ::std::option::Option::Some(RustConstruct::RUST_RETURN),
            "RUST_CATCH" => ::std::option::Option::Some(RustConstruct::RUST_CATCH),
            "RUST_SELF" => ::std::option::Option::Some(RustConstruct::RUST_SELF),
            "RUST_WHILE" => ::std::option::Option::Some(RustConstruct::RUST_WHILE),
            "RUST_TRY" => ::std::option::Option::Some(RustConstruct::RUST_TRY),
            "RUST_MATCH" => ::std::option::Option::Some(RustConstruct::RUST_MATCH),
            "RUST_FOR" => ::std::option::Option::Some(RustConstruct::RUST_FOR),
            "RUST_TUPLE" => ::std::option::Option::Some(RustConstruct::RUST_TUPLE),
            "RUST_OPTION" => ::std::option::Option::Some(RustConstruct::RUST_OPTION),
            "RUST_STR" => ::std::option::Option::Some(RustConstruct::RUST_STR),
            "RUST_STRING" => ::std::option::Option::Some(RustConstruct::RUST_STRING),
            "RUST_I8" => ::std::option::Option::Some(RustConstruct::RUST_I8),
            "RUST_I16" => ::std::option::Option::Some(RustConstruct::RUST_I16),
            "RUST_I32" => ::std::option::Option::Some(RustConstruct::RUST_I32),
            "RUST_I64" => ::std::option::Option::Some(RustConstruct::RUST_I64),
            "RUST_I128" => ::std::option::Option::Some(RustConstruct::RUST_I128),
            "RUST_ISIZE" => ::std::option::Option::Some(RustConstruct::RUST_ISIZE),
            "RUST_U8" => ::std::option::Option::Some(RustConstruct::RUST_U8),
            "RUST_U16" => ::std::option::Option::Some(RustConstruct::RUST_U16),
            "RUST_U32" => ::std::option::Option::Some(RustConstruct::RUST_U32),
            "RUST_U64" => ::std::option::Option::Some(RustConstruct::RUST_U64),
            "RUST_U128" => ::std::option::Option::Some(RustConstruct::RUST_U128),
            "RUST_USIZE" => ::std::option::Option::Some(RustConstruct::RUST_USIZE),
            "RUST_F32" => ::std::option::Option::Some(RustConstruct::RUST_F32),
            "RUST_F64" => ::std::option::Option::Some(RustConstruct::RUST_F64),
            "RUST_IDENT" => ::std::option::Option::Some(RustConstruct::RUST_IDENT),
            "RUST_TRAIT" => ::std::option::Option::Some(RustConstruct::RUST_TRAIT),
            "RUST_MUT" => ::std::option::Option::Some(RustConstruct::RUST_MUT),
            "RUST_COMMENT" => ::std::option::Option::Some(RustConstruct::RUST_COMMENT),
            "RUST_BLOCK_COMMENT" => ::std::option::Option::Some(RustConstruct::RUST_BLOCK_COMMENT),
            "RUST_DOC_COMMENT" => ::std::option::Option::Some(RustConstruct::RUST_DOC_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RustConstruct] = &[
        RustConstruct::RUST_UNKNOWN_CONSTRUCT,
        RustConstruct::RUST_USE,
        RustConstruct::RUST_SCOPE,
        RustConstruct::RUST_STRUCT,
        RustConstruct::RUST_ENUM,
        RustConstruct::RUST_IMPL,
        RustConstruct::RUST_METHOD,
        RustConstruct::RUST_FN,
        RustConstruct::RUST_AWAIT,
        RustConstruct::RUST_LET,
        RustConstruct::RUST_RESULT,
        RustConstruct::RUST_RETURN,
        RustConstruct::RUST_CATCH,
        RustConstruct::RUST_SELF,
        RustConstruct::RUST_WHILE,
        RustConstruct::RUST_TRY,
        RustConstruct::RUST_MATCH,
        RustConstruct::RUST_FOR,
        RustConstruct::RUST_TUPLE,
        RustConstruct::RUST_OPTION,
        RustConstruct::RUST_STR,
        RustConstruct::RUST_STRING,
        RustConstruct::RUST_I8,
        RustConstruct::RUST_I16,
        RustConstruct::RUST_I32,
        RustConstruct::RUST_I64,
        RustConstruct::RUST_I128,
        RustConstruct::RUST_ISIZE,
        RustConstruct::RUST_U8,
        RustConstruct::RUST_U16,
        RustConstruct::RUST_U32,
        RustConstruct::RUST_U64,
        RustConstruct::RUST_U128,
        RustConstruct::RUST_USIZE,
        RustConstruct::RUST_F32,
        RustConstruct::RUST_F64,
        RustConstruct::RUST_IDENT,
        RustConstruct::RUST_TRAIT,
        RustConstruct::RUST_MUT,
        RustConstruct::RUST_COMMENT,
        RustConstruct::RUST_BLOCK_COMMENT,
        RustConstruct::RUST_DOC_COMMENT,
    ];
}

impl ::protobuf::EnumFull for RustConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RustConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RustConstruct {
    fn default() -> Self {
        RustConstruct::RUST_UNKNOWN_CONSTRUCT
    }
}

impl RustConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RustConstruct>("RustConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.PythonConstruct)
pub enum PythonConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_UNKNOWN_CONSTRUCT)
    PYTHON_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_IMPORT)
    PYTHON_IMPORT = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_DOT)
    PYTHON_DOT = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_CLASS)
    PYTHON_CLASS = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_ENUM)
    PYTHON_ENUM = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_DECORATOR)
    PYTHON_DECORATOR = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_METHOD)
    PYTHON_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_DEF)
    PYTHON_DEF = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_AWAIT)
    PYTHON_AWAIT = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_ASSIGN)
    PYTHON_ASSIGN = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_OPTIONAL)
    PYTHON_OPTIONAL = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_RETURN)
    PYTHON_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_EXCEPT)
    PYTHON_EXCEPT = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_SELF)
    PYTHON_SELF = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_WHILE)
    PYTHON_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_TRY)
    PYTHON_TRY = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_MATCH)
    PYTHON_MATCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_FOR)
    PYTHON_FOR = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_TUPLE)
    PYTHON_TUPLE = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_OPTIONAL_TYPE)
    PYTHON_OPTIONAL_TYPE = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_STR)
    PYTHON_STR = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_STRING)
    PYTHON_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_INT)
    PYTHON_INT = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_FLOAT)
    PYTHON_FLOAT = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_IDENTIFIER)
    PYTHON_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_PROTOCOL)
    PYTHON_PROTOCOL = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_FINAL)
    PYTHON_FINAL = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_COMMENT)
    PYTHON_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_BLOCK_COMMENT)
    PYTHON_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_DOCSTRING)
    PYTHON_DOCSTRING = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.PythonConstruct.PYTHON_TYPE_COMMENT)
    PYTHON_TYPE_COMMENT = 42,
}

impl ::protobuf::Enum for PythonConstruct {
    const NAME: &'static str = "PythonConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PythonConstruct> {
        match value {
            0 => ::std::option::Option::Some(PythonConstruct::PYTHON_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(PythonConstruct::PYTHON_IMPORT),
            2 => ::std::option::Option::Some(PythonConstruct::PYTHON_DOT),
            3 => ::std::option::Option::Some(PythonConstruct::PYTHON_CLASS),
            4 => ::std::option::Option::Some(PythonConstruct::PYTHON_ENUM),
            5 => ::std::option::Option::Some(PythonConstruct::PYTHON_DECORATOR),
            6 => ::std::option::Option::Some(PythonConstruct::PYTHON_METHOD),
            7 => ::std::option::Option::Some(PythonConstruct::PYTHON_DEF),
            8 => ::std::option::Option::Some(PythonConstruct::PYTHON_AWAIT),
            9 => ::std::option::Option::Some(PythonConstruct::PYTHON_ASSIGN),
            10 => ::std::option::Option::Some(PythonConstruct::PYTHON_OPTIONAL),
            11 => ::std::option::Option::Some(PythonConstruct::PYTHON_RETURN),
            12 => ::std::option::Option::Some(PythonConstruct::PYTHON_EXCEPT),
            13 => ::std::option::Option::Some(PythonConstruct::PYTHON_SELF),
            14 => ::std::option::Option::Some(PythonConstruct::PYTHON_WHILE),
            15 => ::std::option::Option::Some(PythonConstruct::PYTHON_TRY),
            16 => ::std::option::Option::Some(PythonConstruct::PYTHON_MATCH),
            17 => ::std::option::Option::Some(PythonConstruct::PYTHON_FOR),
            18 => ::std::option::Option::Some(PythonConstruct::PYTHON_TUPLE),
            19 => ::std::option::Option::Some(PythonConstruct::PYTHON_OPTIONAL_TYPE),
            20 => ::std::option::Option::Some(PythonConstruct::PYTHON_STR),
            21 => ::std::option::Option::Some(PythonConstruct::PYTHON_STRING),
            22 => ::std::option::Option::Some(PythonConstruct::PYTHON_INT),
            23 => ::std::option::Option::Some(PythonConstruct::PYTHON_FLOAT),
            36 => ::std::option::Option::Some(PythonConstruct::PYTHON_IDENTIFIER),
            37 => ::std::option::Option::Some(PythonConstruct::PYTHON_PROTOCOL),
            38 => ::std::option::Option::Some(PythonConstruct::PYTHON_FINAL),
            39 => ::std::option::Option::Some(PythonConstruct::PYTHON_COMMENT),
            40 => ::std::option::Option::Some(PythonConstruct::PYTHON_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(PythonConstruct::PYTHON_DOCSTRING),
            42 => ::std::option::Option::Some(PythonConstruct::PYTHON_TYPE_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PythonConstruct> {
        match str {
            "PYTHON_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(PythonConstruct::PYTHON_UNKNOWN_CONSTRUCT),
            "PYTHON_IMPORT" => ::std::option::Option::Some(PythonConstruct::PYTHON_IMPORT),
            "PYTHON_DOT" => ::std::option::Option::Some(PythonConstruct::PYTHON_DOT),
            "PYTHON_CLASS" => ::std::option::Option::Some(PythonConstruct::PYTHON_CLASS),
            "PYTHON_ENUM" => ::std::option::Option::Some(PythonConstruct::PYTHON_ENUM),
            "PYTHON_DECORATOR" => ::std::option::Option::Some(PythonConstruct::PYTHON_DECORATOR),
            "PYTHON_METHOD" => ::std::option::Option::Some(PythonConstruct::PYTHON_METHOD),
            "PYTHON_DEF" => ::std::option::Option::Some(PythonConstruct::PYTHON_DEF),
            "PYTHON_AWAIT" => ::std::option::Option::Some(PythonConstruct::PYTHON_AWAIT),
            "PYTHON_ASSIGN" => ::std::option::Option::Some(PythonConstruct::PYTHON_ASSIGN),
            "PYTHON_OPTIONAL" => ::std::option::Option::Some(PythonConstruct::PYTHON_OPTIONAL),
            "PYTHON_RETURN" => ::std::option::Option::Some(PythonConstruct::PYTHON_RETURN),
            "PYTHON_EXCEPT" => ::std::option::Option::Some(PythonConstruct::PYTHON_EXCEPT),
            "PYTHON_SELF" => ::std::option::Option::Some(PythonConstruct::PYTHON_SELF),
            "PYTHON_WHILE" => ::std::option::Option::Some(PythonConstruct::PYTHON_WHILE),
            "PYTHON_TRY" => ::std::option::Option::Some(PythonConstruct::PYTHON_TRY),
            "PYTHON_MATCH" => ::std::option::Option::Some(PythonConstruct::PYTHON_MATCH),
            "PYTHON_FOR" => ::std::option::Option::Some(PythonConstruct::PYTHON_FOR),
            "PYTHON_TUPLE" => ::std::option::Option::Some(PythonConstruct::PYTHON_TUPLE),
            "PYTHON_OPTIONAL_TYPE" => ::std::option::Option::Some(PythonConstruct::PYTHON_OPTIONAL_TYPE),
            "PYTHON_STR" => ::std::option::Option::Some(PythonConstruct::PYTHON_STR),
            "PYTHON_STRING" => ::std::option::Option::Some(PythonConstruct::PYTHON_STRING),
            "PYTHON_INT" => ::std::option::Option::Some(PythonConstruct::PYTHON_INT),
            "PYTHON_FLOAT" => ::std::option::Option::Some(PythonConstruct::PYTHON_FLOAT),
            "PYTHON_IDENTIFIER" => ::std::option::Option::Some(PythonConstruct::PYTHON_IDENTIFIER),
            "PYTHON_PROTOCOL" => ::std::option::Option::Some(PythonConstruct::PYTHON_PROTOCOL),
            "PYTHON_FINAL" => ::std::option::Option::Some(PythonConstruct::PYTHON_FINAL),
            "PYTHON_COMMENT" => ::std::option::Option::Some(PythonConstruct::PYTHON_COMMENT),
            "PYTHON_BLOCK_COMMENT" => ::std::option::Option::Some(PythonConstruct::PYTHON_BLOCK_COMMENT),
            "PYTHON_DOCSTRING" => ::std::option::Option::Some(PythonConstruct::PYTHON_DOCSTRING),
            "PYTHON_TYPE_COMMENT" => ::std::option::Option::Some(PythonConstruct::PYTHON_TYPE_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PythonConstruct] = &[
        PythonConstruct::PYTHON_UNKNOWN_CONSTRUCT,
        PythonConstruct::PYTHON_IMPORT,
        PythonConstruct::PYTHON_DOT,
        PythonConstruct::PYTHON_CLASS,
        PythonConstruct::PYTHON_ENUM,
        PythonConstruct::PYTHON_DECORATOR,
        PythonConstruct::PYTHON_METHOD,
        PythonConstruct::PYTHON_DEF,
        PythonConstruct::PYTHON_AWAIT,
        PythonConstruct::PYTHON_ASSIGN,
        PythonConstruct::PYTHON_OPTIONAL,
        PythonConstruct::PYTHON_RETURN,
        PythonConstruct::PYTHON_EXCEPT,
        PythonConstruct::PYTHON_SELF,
        PythonConstruct::PYTHON_WHILE,
        PythonConstruct::PYTHON_TRY,
        PythonConstruct::PYTHON_MATCH,
        PythonConstruct::PYTHON_FOR,
        PythonConstruct::PYTHON_TUPLE,
        PythonConstruct::PYTHON_OPTIONAL_TYPE,
        PythonConstruct::PYTHON_STR,
        PythonConstruct::PYTHON_STRING,
        PythonConstruct::PYTHON_INT,
        PythonConstruct::PYTHON_FLOAT,
        PythonConstruct::PYTHON_IDENTIFIER,
        PythonConstruct::PYTHON_PROTOCOL,
        PythonConstruct::PYTHON_FINAL,
        PythonConstruct::PYTHON_COMMENT,
        PythonConstruct::PYTHON_BLOCK_COMMENT,
        PythonConstruct::PYTHON_DOCSTRING,
        PythonConstruct::PYTHON_TYPE_COMMENT,
    ];
}

impl ::protobuf::EnumFull for PythonConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PythonConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            PythonConstruct::PYTHON_UNKNOWN_CONSTRUCT => 0,
            PythonConstruct::PYTHON_IMPORT => 1,
            PythonConstruct::PYTHON_DOT => 2,
            PythonConstruct::PYTHON_CLASS => 3,
            PythonConstruct::PYTHON_ENUM => 4,
            PythonConstruct::PYTHON_DECORATOR => 5,
            PythonConstruct::PYTHON_METHOD => 6,
            PythonConstruct::PYTHON_DEF => 7,
            PythonConstruct::PYTHON_AWAIT => 8,
            PythonConstruct::PYTHON_ASSIGN => 9,
            PythonConstruct::PYTHON_OPTIONAL => 10,
            PythonConstruct::PYTHON_RETURN => 11,
            PythonConstruct::PYTHON_EXCEPT => 12,
            PythonConstruct::PYTHON_SELF => 13,
            PythonConstruct::PYTHON_WHILE => 14,
            PythonConstruct::PYTHON_TRY => 15,
            PythonConstruct::PYTHON_MATCH => 16,
            PythonConstruct::PYTHON_FOR => 17,
            PythonConstruct::PYTHON_TUPLE => 18,
            PythonConstruct::PYTHON_OPTIONAL_TYPE => 19,
            PythonConstruct::PYTHON_STR => 20,
            PythonConstruct::PYTHON_STRING => 21,
            PythonConstruct::PYTHON_INT => 22,
            PythonConstruct::PYTHON_FLOAT => 23,
            PythonConstruct::PYTHON_IDENTIFIER => 24,
            PythonConstruct::PYTHON_PROTOCOL => 25,
            PythonConstruct::PYTHON_FINAL => 26,
            PythonConstruct::PYTHON_COMMENT => 27,
            PythonConstruct::PYTHON_BLOCK_COMMENT => 28,
            PythonConstruct::PYTHON_DOCSTRING => 29,
            PythonConstruct::PYTHON_TYPE_COMMENT => 30,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PythonConstruct {
    fn default() -> Self {
        PythonConstruct::PYTHON_UNKNOWN_CONSTRUCT
    }
}

impl PythonConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PythonConstruct>("PythonConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.TSConstruct)
pub enum TSConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_UNKNOWN_CONSTRUCT)
    TS_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_IMPORT)
    TS_IMPORT = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_NAMESPACE)
    TS_NAMESPACE = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_CLASS)
    TS_CLASS = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_ENUM)
    TS_ENUM = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_IMPL)
    TS_IMPL = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_METHOD)
    TS_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_FUNCTION)
    TS_FUNCTION = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_AWAIT)
    TS_AWAIT = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_LET)
    TS_LET = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_PROMISE)
    TS_PROMISE = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_RETURN)
    TS_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_CATCH)
    TS_CATCH = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_THIS)
    TS_THIS = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_WHILE)
    TS_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_TRY)
    TS_TRY = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_SWITCH)
    TS_SWITCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_FOR)
    TS_FOR = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_TUPLE)
    TS_TUPLE = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_OPTIONAL)
    TS_OPTIONAL = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_STRING_LITERAL)
    TS_STRING_LITERAL = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_STRING)
    TS_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_NUMBER)
    TS_NUMBER = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_BIGINT)
    TS_BIGINT = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_IDENTIFIER)
    TS_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_INTERFACE)
    TS_INTERFACE = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_READONLY)
    TS_READONLY = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_COMMENT)
    TS_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_BLOCK_COMMENT)
    TS_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_DOC_COMMENT)
    TS_DOC_COMMENT = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.TSConstruct.TS_JSX_COMMENT)
    TS_JSX_COMMENT = 42,
}

impl ::protobuf::Enum for TSConstruct {
    const NAME: &'static str = "TSConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TSConstruct> {
        match value {
            0 => ::std::option::Option::Some(TSConstruct::TS_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(TSConstruct::TS_IMPORT),
            2 => ::std::option::Option::Some(TSConstruct::TS_NAMESPACE),
            3 => ::std::option::Option::Some(TSConstruct::TS_CLASS),
            4 => ::std::option::Option::Some(TSConstruct::TS_ENUM),
            5 => ::std::option::Option::Some(TSConstruct::TS_IMPL),
            6 => ::std::option::Option::Some(TSConstruct::TS_METHOD),
            7 => ::std::option::Option::Some(TSConstruct::TS_FUNCTION),
            8 => ::std::option::Option::Some(TSConstruct::TS_AWAIT),
            9 => ::std::option::Option::Some(TSConstruct::TS_LET),
            10 => ::std::option::Option::Some(TSConstruct::TS_PROMISE),
            11 => ::std::option::Option::Some(TSConstruct::TS_RETURN),
            12 => ::std::option::Option::Some(TSConstruct::TS_CATCH),
            13 => ::std::option::Option::Some(TSConstruct::TS_THIS),
            14 => ::std::option::Option::Some(TSConstruct::TS_WHILE),
            15 => ::std::option::Option::Some(TSConstruct::TS_TRY),
            16 => ::std::option::Option::Some(TSConstruct::TS_SWITCH),
            17 => ::std::option::Option::Some(TSConstruct::TS_FOR),
            18 => ::std::option::Option::Some(TSConstruct::TS_TUPLE),
            19 => ::std::option::Option::Some(TSConstruct::TS_OPTIONAL),
            20 => ::std::option::Option::Some(TSConstruct::TS_STRING_LITERAL),
            21 => ::std::option::Option::Some(TSConstruct::TS_STRING),
            22 => ::std::option::Option::Some(TSConstruct::TS_NUMBER),
            23 => ::std::option::Option::Some(TSConstruct::TS_BIGINT),
            36 => ::std::option::Option::Some(TSConstruct::TS_IDENTIFIER),
            37 => ::std::option::Option::Some(TSConstruct::TS_INTERFACE),
            38 => ::std::option::Option::Some(TSConstruct::TS_READONLY),
            39 => ::std::option::Option::Some(TSConstruct::TS_COMMENT),
            40 => ::std::option::Option::Some(TSConstruct::TS_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(TSConstruct::TS_DOC_COMMENT),
            42 => ::std::option::Option::Some(TSConstruct::TS_JSX_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TSConstruct> {
        match str {
            "TS_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(TSConstruct::TS_UNKNOWN_CONSTRUCT),
            "TS_IMPORT" => ::std::option::Option::Some(TSConstruct::TS_IMPORT),
            "TS_NAMESPACE" => ::std::option::Option::Some(TSConstruct::TS_NAMESPACE),
            "TS_CLASS" => ::std::option::Option::Some(TSConstruct::TS_CLASS),
            "TS_ENUM" => ::std::option::Option::Some(TSConstruct::TS_ENUM),
            "TS_IMPL" => ::std::option::Option::Some(TSConstruct::TS_IMPL),
            "TS_METHOD" => ::std::option::Option::Some(TSConstruct::TS_METHOD),
            "TS_FUNCTION" => ::std::option::Option::Some(TSConstruct::TS_FUNCTION),
            "TS_AWAIT" => ::std::option::Option::Some(TSConstruct::TS_AWAIT),
            "TS_LET" => ::std::option::Option::Some(TSConstruct::TS_LET),
            "TS_PROMISE" => ::std::option::Option::Some(TSConstruct::TS_PROMISE),
            "TS_RETURN" => ::std::option::Option::Some(TSConstruct::TS_RETURN),
            "TS_CATCH" => ::std::option::Option::Some(TSConstruct::TS_CATCH),
            "TS_THIS" => ::std::option::Option::Some(TSConstruct::TS_THIS),
            "TS_WHILE" => ::std::option::Option::Some(TSConstruct::TS_WHILE),
            "TS_TRY" => ::std::option::Option::Some(TSConstruct::TS_TRY),
            "TS_SWITCH" => ::std::option::Option::Some(TSConstruct::TS_SWITCH),
            "TS_FOR" => ::std::option::Option::Some(TSConstruct::TS_FOR),
            "TS_TUPLE" => ::std::option::Option::Some(TSConstruct::TS_TUPLE),
            "TS_OPTIONAL" => ::std::option::Option::Some(TSConstruct::TS_OPTIONAL),
            "TS_STRING_LITERAL" => ::std::option::Option::Some(TSConstruct::TS_STRING_LITERAL),
            "TS_STRING" => ::std::option::Option::Some(TSConstruct::TS_STRING),
            "TS_NUMBER" => ::std::option::Option::Some(TSConstruct::TS_NUMBER),
            "TS_BIGINT" => ::std::option::Option::Some(TSConstruct::TS_BIGINT),
            "TS_IDENTIFIER" => ::std::option::Option::Some(TSConstruct::TS_IDENTIFIER),
            "TS_INTERFACE" => ::std::option::Option::Some(TSConstruct::TS_INTERFACE),
            "TS_READONLY" => ::std::option::Option::Some(TSConstruct::TS_READONLY),
            "TS_COMMENT" => ::std::option::Option::Some(TSConstruct::TS_COMMENT),
            "TS_BLOCK_COMMENT" => ::std::option::Option::Some(TSConstruct::TS_BLOCK_COMMENT),
            "TS_DOC_COMMENT" => ::std::option::Option::Some(TSConstruct::TS_DOC_COMMENT),
            "TS_JSX_COMMENT" => ::std::option::Option::Some(TSConstruct::TS_JSX_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TSConstruct] = &[
        TSConstruct::TS_UNKNOWN_CONSTRUCT,
        TSConstruct::TS_IMPORT,
        TSConstruct::TS_NAMESPACE,
        TSConstruct::TS_CLASS,
        TSConstruct::TS_ENUM,
        TSConstruct::TS_IMPL,
        TSConstruct::TS_METHOD,
        TSConstruct::TS_FUNCTION,
        TSConstruct::TS_AWAIT,
        TSConstruct::TS_LET,
        TSConstruct::TS_PROMISE,
        TSConstruct::TS_RETURN,
        TSConstruct::TS_CATCH,
        TSConstruct::TS_THIS,
        TSConstruct::TS_WHILE,
        TSConstruct::TS_TRY,
        TSConstruct::TS_SWITCH,
        TSConstruct::TS_FOR,
        TSConstruct::TS_TUPLE,
        TSConstruct::TS_OPTIONAL,
        TSConstruct::TS_STRING_LITERAL,
        TSConstruct::TS_STRING,
        TSConstruct::TS_NUMBER,
        TSConstruct::TS_BIGINT,
        TSConstruct::TS_IDENTIFIER,
        TSConstruct::TS_INTERFACE,
        TSConstruct::TS_READONLY,
        TSConstruct::TS_COMMENT,
        TSConstruct::TS_BLOCK_COMMENT,
        TSConstruct::TS_DOC_COMMENT,
        TSConstruct::TS_JSX_COMMENT,
    ];
}

impl ::protobuf::EnumFull for TSConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TSConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            TSConstruct::TS_UNKNOWN_CONSTRUCT => 0,
            TSConstruct::TS_IMPORT => 1,
            TSConstruct::TS_NAMESPACE => 2,
            TSConstruct::TS_CLASS => 3,
            TSConstruct::TS_ENUM => 4,
            TSConstruct::TS_IMPL => 5,
            TSConstruct::TS_METHOD => 6,
            TSConstruct::TS_FUNCTION => 7,
            TSConstruct::TS_AWAIT => 8,
            TSConstruct::TS_LET => 9,
            TSConstruct::TS_PROMISE => 10,
            TSConstruct::TS_RETURN => 11,
            TSConstruct::TS_CATCH => 12,
            TSConstruct::TS_THIS => 13,
            TSConstruct::TS_WHILE => 14,
            TSConstruct::TS_TRY => 15,
            TSConstruct::TS_SWITCH => 16,
            TSConstruct::TS_FOR => 17,
            TSConstruct::TS_TUPLE => 18,
            TSConstruct::TS_OPTIONAL => 19,
            TSConstruct::TS_STRING_LITERAL => 20,
            TSConstruct::TS_STRING => 21,
            TSConstruct::TS_NUMBER => 22,
            TSConstruct::TS_BIGINT => 23,
            TSConstruct::TS_IDENTIFIER => 24,
            TSConstruct::TS_INTERFACE => 25,
            TSConstruct::TS_READONLY => 26,
            TSConstruct::TS_COMMENT => 27,
            TSConstruct::TS_BLOCK_COMMENT => 28,
            TSConstruct::TS_DOC_COMMENT => 29,
            TSConstruct::TS_JSX_COMMENT => 30,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TSConstruct {
    fn default() -> Self {
        TSConstruct::TS_UNKNOWN_CONSTRUCT
    }
}

impl TSConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TSConstruct>("TSConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.JSConstruct)
pub enum JSConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_UNKNOWN_CONSTRUCT)
    JS_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_IMPORT)
    JS_IMPORT = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_DOT)
    JS_DOT = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_CLASS)
    JS_CLASS = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_OBJECT)
    JS_OBJECT = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_EXTENDS)
    JS_EXTENDS = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_METHOD)
    JS_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_FUNCTION)
    JS_FUNCTION = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_AWAIT)
    JS_AWAIT = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_LET)
    JS_LET = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_PROMISE)
    JS_PROMISE = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_RETURN)
    JS_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_CATCH)
    JS_CATCH = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_THIS)
    JS_THIS = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_WHILE)
    JS_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_TRY)
    JS_TRY = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_SWITCH)
    JS_SWITCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_FOR)
    JS_FOR = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_ARRAY)
    JS_ARRAY = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_NULLABLE)
    JS_NULLABLE = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_TEMPLATE_LITERAL)
    JS_TEMPLATE_LITERAL = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_STRING)
    JS_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_NUMBER)
    JS_NUMBER = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_BIGINT)
    JS_BIGINT = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_IDENTIFIER)
    JS_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_CONST)
    JS_CONST = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_COMMENT)
    JS_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_BLOCK_COMMENT)
    JS_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_DOC_COMMENT)
    JS_DOC_COMMENT = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JSConstruct.JS_JSX_COMMENT)
    JS_JSX_COMMENT = 42,
}

impl ::protobuf::Enum for JSConstruct {
    const NAME: &'static str = "JSConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<JSConstruct> {
        match value {
            0 => ::std::option::Option::Some(JSConstruct::JS_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(JSConstruct::JS_IMPORT),
            2 => ::std::option::Option::Some(JSConstruct::JS_DOT),
            3 => ::std::option::Option::Some(JSConstruct::JS_CLASS),
            4 => ::std::option::Option::Some(JSConstruct::JS_OBJECT),
            5 => ::std::option::Option::Some(JSConstruct::JS_EXTENDS),
            6 => ::std::option::Option::Some(JSConstruct::JS_METHOD),
            7 => ::std::option::Option::Some(JSConstruct::JS_FUNCTION),
            8 => ::std::option::Option::Some(JSConstruct::JS_AWAIT),
            9 => ::std::option::Option::Some(JSConstruct::JS_LET),
            10 => ::std::option::Option::Some(JSConstruct::JS_PROMISE),
            11 => ::std::option::Option::Some(JSConstruct::JS_RETURN),
            12 => ::std::option::Option::Some(JSConstruct::JS_CATCH),
            13 => ::std::option::Option::Some(JSConstruct::JS_THIS),
            14 => ::std::option::Option::Some(JSConstruct::JS_WHILE),
            15 => ::std::option::Option::Some(JSConstruct::JS_TRY),
            16 => ::std::option::Option::Some(JSConstruct::JS_SWITCH),
            17 => ::std::option::Option::Some(JSConstruct::JS_FOR),
            18 => ::std::option::Option::Some(JSConstruct::JS_ARRAY),
            19 => ::std::option::Option::Some(JSConstruct::JS_NULLABLE),
            20 => ::std::option::Option::Some(JSConstruct::JS_TEMPLATE_LITERAL),
            21 => ::std::option::Option::Some(JSConstruct::JS_STRING),
            22 => ::std::option::Option::Some(JSConstruct::JS_NUMBER),
            23 => ::std::option::Option::Some(JSConstruct::JS_BIGINT),
            36 => ::std::option::Option::Some(JSConstruct::JS_IDENTIFIER),
            38 => ::std::option::Option::Some(JSConstruct::JS_CONST),
            39 => ::std::option::Option::Some(JSConstruct::JS_COMMENT),
            40 => ::std::option::Option::Some(JSConstruct::JS_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(JSConstruct::JS_DOC_COMMENT),
            42 => ::std::option::Option::Some(JSConstruct::JS_JSX_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<JSConstruct> {
        match str {
            "JS_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(JSConstruct::JS_UNKNOWN_CONSTRUCT),
            "JS_IMPORT" => ::std::option::Option::Some(JSConstruct::JS_IMPORT),
            "JS_DOT" => ::std::option::Option::Some(JSConstruct::JS_DOT),
            "JS_CLASS" => ::std::option::Option::Some(JSConstruct::JS_CLASS),
            "JS_OBJECT" => ::std::option::Option::Some(JSConstruct::JS_OBJECT),
            "JS_EXTENDS" => ::std::option::Option::Some(JSConstruct::JS_EXTENDS),
            "JS_METHOD" => ::std::option::Option::Some(JSConstruct::JS_METHOD),
            "JS_FUNCTION" => ::std::option::Option::Some(JSConstruct::JS_FUNCTION),
            "JS_AWAIT" => ::std::option::Option::Some(JSConstruct::JS_AWAIT),
            "JS_LET" => ::std::option::Option::Some(JSConstruct::JS_LET),
            "JS_PROMISE" => ::std::option::Option::Some(JSConstruct::JS_PROMISE),
            "JS_RETURN" => ::std::option::Option::Some(JSConstruct::JS_RETURN),
            "JS_CATCH" => ::std::option::Option::Some(JSConstruct::JS_CATCH),
            "JS_THIS" => ::std::option::Option::Some(JSConstruct::JS_THIS),
            "JS_WHILE" => ::std::option::Option::Some(JSConstruct::JS_WHILE),
            "JS_TRY" => ::std::option::Option::Some(JSConstruct::JS_TRY),
            "JS_SWITCH" => ::std::option::Option::Some(JSConstruct::JS_SWITCH),
            "JS_FOR" => ::std::option::Option::Some(JSConstruct::JS_FOR),
            "JS_ARRAY" => ::std::option::Option::Some(JSConstruct::JS_ARRAY),
            "JS_NULLABLE" => ::std::option::Option::Some(JSConstruct::JS_NULLABLE),
            "JS_TEMPLATE_LITERAL" => ::std::option::Option::Some(JSConstruct::JS_TEMPLATE_LITERAL),
            "JS_STRING" => ::std::option::Option::Some(JSConstruct::JS_STRING),
            "JS_NUMBER" => ::std::option::Option::Some(JSConstruct::JS_NUMBER),
            "JS_BIGINT" => ::std::option::Option::Some(JSConstruct::JS_BIGINT),
            "JS_IDENTIFIER" => ::std::option::Option::Some(JSConstruct::JS_IDENTIFIER),
            "JS_CONST" => ::std::option::Option::Some(JSConstruct::JS_CONST),
            "JS_COMMENT" => ::std::option::Option::Some(JSConstruct::JS_COMMENT),
            "JS_BLOCK_COMMENT" => ::std::option::Option::Some(JSConstruct::JS_BLOCK_COMMENT),
            "JS_DOC_COMMENT" => ::std::option::Option::Some(JSConstruct::JS_DOC_COMMENT),
            "JS_JSX_COMMENT" => ::std::option::Option::Some(JSConstruct::JS_JSX_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [JSConstruct] = &[
        JSConstruct::JS_UNKNOWN_CONSTRUCT,
        JSConstruct::JS_IMPORT,
        JSConstruct::JS_DOT,
        JSConstruct::JS_CLASS,
        JSConstruct::JS_OBJECT,
        JSConstruct::JS_EXTENDS,
        JSConstruct::JS_METHOD,
        JSConstruct::JS_FUNCTION,
        JSConstruct::JS_AWAIT,
        JSConstruct::JS_LET,
        JSConstruct::JS_PROMISE,
        JSConstruct::JS_RETURN,
        JSConstruct::JS_CATCH,
        JSConstruct::JS_THIS,
        JSConstruct::JS_WHILE,
        JSConstruct::JS_TRY,
        JSConstruct::JS_SWITCH,
        JSConstruct::JS_FOR,
        JSConstruct::JS_ARRAY,
        JSConstruct::JS_NULLABLE,
        JSConstruct::JS_TEMPLATE_LITERAL,
        JSConstruct::JS_STRING,
        JSConstruct::JS_NUMBER,
        JSConstruct::JS_BIGINT,
        JSConstruct::JS_IDENTIFIER,
        JSConstruct::JS_CONST,
        JSConstruct::JS_COMMENT,
        JSConstruct::JS_BLOCK_COMMENT,
        JSConstruct::JS_DOC_COMMENT,
        JSConstruct::JS_JSX_COMMENT,
    ];
}

impl ::protobuf::EnumFull for JSConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("JSConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            JSConstruct::JS_UNKNOWN_CONSTRUCT => 0,
            JSConstruct::JS_IMPORT => 1,
            JSConstruct::JS_DOT => 2,
            JSConstruct::JS_CLASS => 3,
            JSConstruct::JS_OBJECT => 4,
            JSConstruct::JS_EXTENDS => 5,
            JSConstruct::JS_METHOD => 6,
            JSConstruct::JS_FUNCTION => 7,
            JSConstruct::JS_AWAIT => 8,
            JSConstruct::JS_LET => 9,
            JSConstruct::JS_PROMISE => 10,
            JSConstruct::JS_RETURN => 11,
            JSConstruct::JS_CATCH => 12,
            JSConstruct::JS_THIS => 13,
            JSConstruct::JS_WHILE => 14,
            JSConstruct::JS_TRY => 15,
            JSConstruct::JS_SWITCH => 16,
            JSConstruct::JS_FOR => 17,
            JSConstruct::JS_ARRAY => 18,
            JSConstruct::JS_NULLABLE => 19,
            JSConstruct::JS_TEMPLATE_LITERAL => 20,
            JSConstruct::JS_STRING => 21,
            JSConstruct::JS_NUMBER => 22,
            JSConstruct::JS_BIGINT => 23,
            JSConstruct::JS_IDENTIFIER => 24,
            JSConstruct::JS_CONST => 25,
            JSConstruct::JS_COMMENT => 26,
            JSConstruct::JS_BLOCK_COMMENT => 27,
            JSConstruct::JS_DOC_COMMENT => 28,
            JSConstruct::JS_JSX_COMMENT => 29,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for JSConstruct {
    fn default() -> Self {
        JSConstruct::JS_UNKNOWN_CONSTRUCT
    }
}

impl JSConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<JSConstruct>("JSConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.JavaConstruct)
pub enum JavaConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_UNKNOWN_CONSTRUCT)
    JAVA_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_IMPORT)
    JAVA_IMPORT = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_DOT)
    JAVA_DOT = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_CLASS)
    JAVA_CLASS = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_ENUM)
    JAVA_ENUM = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_IMPLEMENTS)
    JAVA_IMPLEMENTS = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_METHOD)
    JAVA_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_FUNCTION)
    JAVA_FUNCTION = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_AWAIT)
    JAVA_AWAIT = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_VAR)
    JAVA_VAR = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_OPTIONAL)
    JAVA_OPTIONAL = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_RETURN)
    JAVA_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_CATCH)
    JAVA_CATCH = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_THIS)
    JAVA_THIS = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_WHILE)
    JAVA_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_TRY)
    JAVA_TRY = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_SWITCH)
    JAVA_SWITCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_FOR)
    JAVA_FOR = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_TUPLE)
    JAVA_TUPLE = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_OPTIONAL_TYPE)
    JAVA_OPTIONAL_TYPE = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_CHAR_SEQUENCE)
    JAVA_CHAR_SEQUENCE = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_STRING)
    JAVA_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_BYTE)
    JAVA_BYTE = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_SHORT)
    JAVA_SHORT = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_INT)
    JAVA_INT = 24,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_LONG)
    JAVA_LONG = 25,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_BIGINTEGER)
    JAVA_BIGINTEGER = 26,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_IDENTIFIER)
    JAVA_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_INTERFACE)
    JAVA_INTERFACE = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_FINAL)
    JAVA_FINAL = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_COMMENT)
    JAVA_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_BLOCK_COMMENT)
    JAVA_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_DOC_COMMENT)
    JAVA_DOC_COMMENT = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.JavaConstruct.JAVA_ANNOTATION)
    JAVA_ANNOTATION = 42,
}

impl ::protobuf::Enum for JavaConstruct {
    const NAME: &'static str = "JavaConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<JavaConstruct> {
        match value {
            0 => ::std::option::Option::Some(JavaConstruct::JAVA_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(JavaConstruct::JAVA_IMPORT),
            2 => ::std::option::Option::Some(JavaConstruct::JAVA_DOT),
            3 => ::std::option::Option::Some(JavaConstruct::JAVA_CLASS),
            4 => ::std::option::Option::Some(JavaConstruct::JAVA_ENUM),
            5 => ::std::option::Option::Some(JavaConstruct::JAVA_IMPLEMENTS),
            6 => ::std::option::Option::Some(JavaConstruct::JAVA_METHOD),
            7 => ::std::option::Option::Some(JavaConstruct::JAVA_FUNCTION),
            8 => ::std::option::Option::Some(JavaConstruct::JAVA_AWAIT),
            9 => ::std::option::Option::Some(JavaConstruct::JAVA_VAR),
            10 => ::std::option::Option::Some(JavaConstruct::JAVA_OPTIONAL),
            11 => ::std::option::Option::Some(JavaConstruct::JAVA_RETURN),
            12 => ::std::option::Option::Some(JavaConstruct::JAVA_CATCH),
            13 => ::std::option::Option::Some(JavaConstruct::JAVA_THIS),
            14 => ::std::option::Option::Some(JavaConstruct::JAVA_WHILE),
            15 => ::std::option::Option::Some(JavaConstruct::JAVA_TRY),
            16 => ::std::option::Option::Some(JavaConstruct::JAVA_SWITCH),
            17 => ::std::option::Option::Some(JavaConstruct::JAVA_FOR),
            18 => ::std::option::Option::Some(JavaConstruct::JAVA_TUPLE),
            19 => ::std::option::Option::Some(JavaConstruct::JAVA_OPTIONAL_TYPE),
            20 => ::std::option::Option::Some(JavaConstruct::JAVA_CHAR_SEQUENCE),
            21 => ::std::option::Option::Some(JavaConstruct::JAVA_STRING),
            22 => ::std::option::Option::Some(JavaConstruct::JAVA_BYTE),
            23 => ::std::option::Option::Some(JavaConstruct::JAVA_SHORT),
            24 => ::std::option::Option::Some(JavaConstruct::JAVA_INT),
            25 => ::std::option::Option::Some(JavaConstruct::JAVA_LONG),
            26 => ::std::option::Option::Some(JavaConstruct::JAVA_BIGINTEGER),
            36 => ::std::option::Option::Some(JavaConstruct::JAVA_IDENTIFIER),
            37 => ::std::option::Option::Some(JavaConstruct::JAVA_INTERFACE),
            38 => ::std::option::Option::Some(JavaConstruct::JAVA_FINAL),
            39 => ::std::option::Option::Some(JavaConstruct::JAVA_COMMENT),
            40 => ::std::option::Option::Some(JavaConstruct::JAVA_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(JavaConstruct::JAVA_DOC_COMMENT),
            42 => ::std::option::Option::Some(JavaConstruct::JAVA_ANNOTATION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<JavaConstruct> {
        match str {
            "JAVA_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(JavaConstruct::JAVA_UNKNOWN_CONSTRUCT),
            "JAVA_IMPORT" => ::std::option::Option::Some(JavaConstruct::JAVA_IMPORT),
            "JAVA_DOT" => ::std::option::Option::Some(JavaConstruct::JAVA_DOT),
            "JAVA_CLASS" => ::std::option::Option::Some(JavaConstruct::JAVA_CLASS),
            "JAVA_ENUM" => ::std::option::Option::Some(JavaConstruct::JAVA_ENUM),
            "JAVA_IMPLEMENTS" => ::std::option::Option::Some(JavaConstruct::JAVA_IMPLEMENTS),
            "JAVA_METHOD" => ::std::option::Option::Some(JavaConstruct::JAVA_METHOD),
            "JAVA_FUNCTION" => ::std::option::Option::Some(JavaConstruct::JAVA_FUNCTION),
            "JAVA_AWAIT" => ::std::option::Option::Some(JavaConstruct::JAVA_AWAIT),
            "JAVA_VAR" => ::std::option::Option::Some(JavaConstruct::JAVA_VAR),
            "JAVA_OPTIONAL" => ::std::option::Option::Some(JavaConstruct::JAVA_OPTIONAL),
            "JAVA_RETURN" => ::std::option::Option::Some(JavaConstruct::JAVA_RETURN),
            "JAVA_CATCH" => ::std::option::Option::Some(JavaConstruct::JAVA_CATCH),
            "JAVA_THIS" => ::std::option::Option::Some(JavaConstruct::JAVA_THIS),
            "JAVA_WHILE" => ::std::option::Option::Some(JavaConstruct::JAVA_WHILE),
            "JAVA_TRY" => ::std::option::Option::Some(JavaConstruct::JAVA_TRY),
            "JAVA_SWITCH" => ::std::option::Option::Some(JavaConstruct::JAVA_SWITCH),
            "JAVA_FOR" => ::std::option::Option::Some(JavaConstruct::JAVA_FOR),
            "JAVA_TUPLE" => ::std::option::Option::Some(JavaConstruct::JAVA_TUPLE),
            "JAVA_OPTIONAL_TYPE" => ::std::option::Option::Some(JavaConstruct::JAVA_OPTIONAL_TYPE),
            "JAVA_CHAR_SEQUENCE" => ::std::option::Option::Some(JavaConstruct::JAVA_CHAR_SEQUENCE),
            "JAVA_STRING" => ::std::option::Option::Some(JavaConstruct::JAVA_STRING),
            "JAVA_BYTE" => ::std::option::Option::Some(JavaConstruct::JAVA_BYTE),
            "JAVA_SHORT" => ::std::option::Option::Some(JavaConstruct::JAVA_SHORT),
            "JAVA_INT" => ::std::option::Option::Some(JavaConstruct::JAVA_INT),
            "JAVA_LONG" => ::std::option::Option::Some(JavaConstruct::JAVA_LONG),
            "JAVA_BIGINTEGER" => ::std::option::Option::Some(JavaConstruct::JAVA_BIGINTEGER),
            "JAVA_IDENTIFIER" => ::std::option::Option::Some(JavaConstruct::JAVA_IDENTIFIER),
            "JAVA_INTERFACE" => ::std::option::Option::Some(JavaConstruct::JAVA_INTERFACE),
            "JAVA_FINAL" => ::std::option::Option::Some(JavaConstruct::JAVA_FINAL),
            "JAVA_COMMENT" => ::std::option::Option::Some(JavaConstruct::JAVA_COMMENT),
            "JAVA_BLOCK_COMMENT" => ::std::option::Option::Some(JavaConstruct::JAVA_BLOCK_COMMENT),
            "JAVA_DOC_COMMENT" => ::std::option::Option::Some(JavaConstruct::JAVA_DOC_COMMENT),
            "JAVA_ANNOTATION" => ::std::option::Option::Some(JavaConstruct::JAVA_ANNOTATION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [JavaConstruct] = &[
        JavaConstruct::JAVA_UNKNOWN_CONSTRUCT,
        JavaConstruct::JAVA_IMPORT,
        JavaConstruct::JAVA_DOT,
        JavaConstruct::JAVA_CLASS,
        JavaConstruct::JAVA_ENUM,
        JavaConstruct::JAVA_IMPLEMENTS,
        JavaConstruct::JAVA_METHOD,
        JavaConstruct::JAVA_FUNCTION,
        JavaConstruct::JAVA_AWAIT,
        JavaConstruct::JAVA_VAR,
        JavaConstruct::JAVA_OPTIONAL,
        JavaConstruct::JAVA_RETURN,
        JavaConstruct::JAVA_CATCH,
        JavaConstruct::JAVA_THIS,
        JavaConstruct::JAVA_WHILE,
        JavaConstruct::JAVA_TRY,
        JavaConstruct::JAVA_SWITCH,
        JavaConstruct::JAVA_FOR,
        JavaConstruct::JAVA_TUPLE,
        JavaConstruct::JAVA_OPTIONAL_TYPE,
        JavaConstruct::JAVA_CHAR_SEQUENCE,
        JavaConstruct::JAVA_STRING,
        JavaConstruct::JAVA_BYTE,
        JavaConstruct::JAVA_SHORT,
        JavaConstruct::JAVA_INT,
        JavaConstruct::JAVA_LONG,
        JavaConstruct::JAVA_BIGINTEGER,
        JavaConstruct::JAVA_IDENTIFIER,
        JavaConstruct::JAVA_INTERFACE,
        JavaConstruct::JAVA_FINAL,
        JavaConstruct::JAVA_COMMENT,
        JavaConstruct::JAVA_BLOCK_COMMENT,
        JavaConstruct::JAVA_DOC_COMMENT,
        JavaConstruct::JAVA_ANNOTATION,
    ];
}

impl ::protobuf::EnumFull for JavaConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("JavaConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            JavaConstruct::JAVA_UNKNOWN_CONSTRUCT => 0,
            JavaConstruct::JAVA_IMPORT => 1,
            JavaConstruct::JAVA_DOT => 2,
            JavaConstruct::JAVA_CLASS => 3,
            JavaConstruct::JAVA_ENUM => 4,
            JavaConstruct::JAVA_IMPLEMENTS => 5,
            JavaConstruct::JAVA_METHOD => 6,
            JavaConstruct::JAVA_FUNCTION => 7,
            JavaConstruct::JAVA_AWAIT => 8,
            JavaConstruct::JAVA_VAR => 9,
            JavaConstruct::JAVA_OPTIONAL => 10,
            JavaConstruct::JAVA_RETURN => 11,
            JavaConstruct::JAVA_CATCH => 12,
            JavaConstruct::JAVA_THIS => 13,
            JavaConstruct::JAVA_WHILE => 14,
            JavaConstruct::JAVA_TRY => 15,
            JavaConstruct::JAVA_SWITCH => 16,
            JavaConstruct::JAVA_FOR => 17,
            JavaConstruct::JAVA_TUPLE => 18,
            JavaConstruct::JAVA_OPTIONAL_TYPE => 19,
            JavaConstruct::JAVA_CHAR_SEQUENCE => 20,
            JavaConstruct::JAVA_STRING => 21,
            JavaConstruct::JAVA_BYTE => 22,
            JavaConstruct::JAVA_SHORT => 23,
            JavaConstruct::JAVA_INT => 24,
            JavaConstruct::JAVA_LONG => 25,
            JavaConstruct::JAVA_BIGINTEGER => 26,
            JavaConstruct::JAVA_IDENTIFIER => 27,
            JavaConstruct::JAVA_INTERFACE => 28,
            JavaConstruct::JAVA_FINAL => 29,
            JavaConstruct::JAVA_COMMENT => 30,
            JavaConstruct::JAVA_BLOCK_COMMENT => 31,
            JavaConstruct::JAVA_DOC_COMMENT => 32,
            JavaConstruct::JAVA_ANNOTATION => 33,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for JavaConstruct {
    fn default() -> Self {
        JavaConstruct::JAVA_UNKNOWN_CONSTRUCT
    }
}

impl JavaConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<JavaConstruct>("JavaConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.GoConstruct)
pub enum GoConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_UNKNOWN_CONSTRUCT)
    GO_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_IMPORT)
    GO_IMPORT = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_DOT)
    GO_DOT = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_STRUCT)
    GO_STRUCT = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_IOTA)
    GO_IOTA = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_IMPLEMENTS)
    GO_IMPLEMENTS = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_METHOD)
    GO_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_FUNC)
    GO_FUNC = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_GO)
    GO_GO = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_VAR)
    GO_VAR = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_ERROR)
    GO_ERROR = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_RETURN)
    GO_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_RECOVER)
    GO_RECOVER = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_RECEIVER)
    GO_RECEIVER = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_FOR)
    GO_FOR = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_DEFER)
    GO_DEFER = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_SWITCH)
    GO_SWITCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_RANGE)
    GO_RANGE = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_SLICE)
    GO_SLICE = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_POINTER)
    GO_POINTER = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_RUNE)
    GO_RUNE = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_STRING)
    GO_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_INT8)
    GO_INT8 = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_INT16)
    GO_INT16 = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_INT32)
    GO_INT32 = 24,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_INT64)
    GO_INT64 = 25,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_INT)
    GO_INT = 26,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_IDENTIFIER)
    GO_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_INTERFACE)
    GO_INTERFACE = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_CONST)
    GO_CONST = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_COMMENT)
    GO_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_BLOCK_COMMENT)
    GO_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_DOC_COMMENT)
    GO_DOC_COMMENT = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.GoConstruct.GO_BUILD_COMMENT)
    GO_BUILD_COMMENT = 42,
}

impl ::protobuf::Enum for GoConstruct {
    const NAME: &'static str = "GoConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GoConstruct> {
        match value {
            0 => ::std::option::Option::Some(GoConstruct::GO_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(GoConstruct::GO_IMPORT),
            2 => ::std::option::Option::Some(GoConstruct::GO_DOT),
            3 => ::std::option::Option::Some(GoConstruct::GO_STRUCT),
            4 => ::std::option::Option::Some(GoConstruct::GO_IOTA),
            5 => ::std::option::Option::Some(GoConstruct::GO_IMPLEMENTS),
            6 => ::std::option::Option::Some(GoConstruct::GO_METHOD),
            7 => ::std::option::Option::Some(GoConstruct::GO_FUNC),
            8 => ::std::option::Option::Some(GoConstruct::GO_GO),
            9 => ::std::option::Option::Some(GoConstruct::GO_VAR),
            10 => ::std::option::Option::Some(GoConstruct::GO_ERROR),
            11 => ::std::option::Option::Some(GoConstruct::GO_RETURN),
            12 => ::std::option::Option::Some(GoConstruct::GO_RECOVER),
            13 => ::std::option::Option::Some(GoConstruct::GO_RECEIVER),
            14 => ::std::option::Option::Some(GoConstruct::GO_FOR),
            15 => ::std::option::Option::Some(GoConstruct::GO_DEFER),
            16 => ::std::option::Option::Some(GoConstruct::GO_SWITCH),
            17 => ::std::option::Option::Some(GoConstruct::GO_RANGE),
            18 => ::std::option::Option::Some(GoConstruct::GO_SLICE),
            19 => ::std::option::Option::Some(GoConstruct::GO_POINTER),
            20 => ::std::option::Option::Some(GoConstruct::GO_RUNE),
            21 => ::std::option::Option::Some(GoConstruct::GO_STRING),
            22 => ::std::option::Option::Some(GoConstruct::GO_INT8),
            23 => ::std::option::Option::Some(GoConstruct::GO_INT16),
            24 => ::std::option::Option::Some(GoConstruct::GO_INT32),
            25 => ::std::option::Option::Some(GoConstruct::GO_INT64),
            26 => ::std::option::Option::Some(GoConstruct::GO_INT),
            36 => ::std::option::Option::Some(GoConstruct::GO_IDENTIFIER),
            37 => ::std::option::Option::Some(GoConstruct::GO_INTERFACE),
            38 => ::std::option::Option::Some(GoConstruct::GO_CONST),
            39 => ::std::option::Option::Some(GoConstruct::GO_COMMENT),
            40 => ::std::option::Option::Some(GoConstruct::GO_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(GoConstruct::GO_DOC_COMMENT),
            42 => ::std::option::Option::Some(GoConstruct::GO_BUILD_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GoConstruct> {
        match str {
            "GO_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(GoConstruct::GO_UNKNOWN_CONSTRUCT),
            "GO_IMPORT" => ::std::option::Option::Some(GoConstruct::GO_IMPORT),
            "GO_DOT" => ::std::option::Option::Some(GoConstruct::GO_DOT),
            "GO_STRUCT" => ::std::option::Option::Some(GoConstruct::GO_STRUCT),
            "GO_IOTA" => ::std::option::Option::Some(GoConstruct::GO_IOTA),
            "GO_IMPLEMENTS" => ::std::option::Option::Some(GoConstruct::GO_IMPLEMENTS),
            "GO_METHOD" => ::std::option::Option::Some(GoConstruct::GO_METHOD),
            "GO_FUNC" => ::std::option::Option::Some(GoConstruct::GO_FUNC),
            "GO_GO" => ::std::option::Option::Some(GoConstruct::GO_GO),
            "GO_VAR" => ::std::option::Option::Some(GoConstruct::GO_VAR),
            "GO_ERROR" => ::std::option::Option::Some(GoConstruct::GO_ERROR),
            "GO_RETURN" => ::std::option::Option::Some(GoConstruct::GO_RETURN),
            "GO_RECOVER" => ::std::option::Option::Some(GoConstruct::GO_RECOVER),
            "GO_RECEIVER" => ::std::option::Option::Some(GoConstruct::GO_RECEIVER),
            "GO_FOR" => ::std::option::Option::Some(GoConstruct::GO_FOR),
            "GO_DEFER" => ::std::option::Option::Some(GoConstruct::GO_DEFER),
            "GO_SWITCH" => ::std::option::Option::Some(GoConstruct::GO_SWITCH),
            "GO_RANGE" => ::std::option::Option::Some(GoConstruct::GO_RANGE),
            "GO_SLICE" => ::std::option::Option::Some(GoConstruct::GO_SLICE),
            "GO_POINTER" => ::std::option::Option::Some(GoConstruct::GO_POINTER),
            "GO_RUNE" => ::std::option::Option::Some(GoConstruct::GO_RUNE),
            "GO_STRING" => ::std::option::Option::Some(GoConstruct::GO_STRING),
            "GO_INT8" => ::std::option::Option::Some(GoConstruct::GO_INT8),
            "GO_INT16" => ::std::option::Option::Some(GoConstruct::GO_INT16),
            "GO_INT32" => ::std::option::Option::Some(GoConstruct::GO_INT32),
            "GO_INT64" => ::std::option::Option::Some(GoConstruct::GO_INT64),
            "GO_INT" => ::std::option::Option::Some(GoConstruct::GO_INT),
            "GO_IDENTIFIER" => ::std::option::Option::Some(GoConstruct::GO_IDENTIFIER),
            "GO_INTERFACE" => ::std::option::Option::Some(GoConstruct::GO_INTERFACE),
            "GO_CONST" => ::std::option::Option::Some(GoConstruct::GO_CONST),
            "GO_COMMENT" => ::std::option::Option::Some(GoConstruct::GO_COMMENT),
            "GO_BLOCK_COMMENT" => ::std::option::Option::Some(GoConstruct::GO_BLOCK_COMMENT),
            "GO_DOC_COMMENT" => ::std::option::Option::Some(GoConstruct::GO_DOC_COMMENT),
            "GO_BUILD_COMMENT" => ::std::option::Option::Some(GoConstruct::GO_BUILD_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GoConstruct] = &[
        GoConstruct::GO_UNKNOWN_CONSTRUCT,
        GoConstruct::GO_IMPORT,
        GoConstruct::GO_DOT,
        GoConstruct::GO_STRUCT,
        GoConstruct::GO_IOTA,
        GoConstruct::GO_IMPLEMENTS,
        GoConstruct::GO_METHOD,
        GoConstruct::GO_FUNC,
        GoConstruct::GO_GO,
        GoConstruct::GO_VAR,
        GoConstruct::GO_ERROR,
        GoConstruct::GO_RETURN,
        GoConstruct::GO_RECOVER,
        GoConstruct::GO_RECEIVER,
        GoConstruct::GO_FOR,
        GoConstruct::GO_DEFER,
        GoConstruct::GO_SWITCH,
        GoConstruct::GO_RANGE,
        GoConstruct::GO_SLICE,
        GoConstruct::GO_POINTER,
        GoConstruct::GO_RUNE,
        GoConstruct::GO_STRING,
        GoConstruct::GO_INT8,
        GoConstruct::GO_INT16,
        GoConstruct::GO_INT32,
        GoConstruct::GO_INT64,
        GoConstruct::GO_INT,
        GoConstruct::GO_IDENTIFIER,
        GoConstruct::GO_INTERFACE,
        GoConstruct::GO_CONST,
        GoConstruct::GO_COMMENT,
        GoConstruct::GO_BLOCK_COMMENT,
        GoConstruct::GO_DOC_COMMENT,
        GoConstruct::GO_BUILD_COMMENT,
    ];
}

impl ::protobuf::EnumFull for GoConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GoConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            GoConstruct::GO_UNKNOWN_CONSTRUCT => 0,
            GoConstruct::GO_IMPORT => 1,
            GoConstruct::GO_DOT => 2,
            GoConstruct::GO_STRUCT => 3,
            GoConstruct::GO_IOTA => 4,
            GoConstruct::GO_IMPLEMENTS => 5,
            GoConstruct::GO_METHOD => 6,
            GoConstruct::GO_FUNC => 7,
            GoConstruct::GO_GO => 8,
            GoConstruct::GO_VAR => 9,
            GoConstruct::GO_ERROR => 10,
            GoConstruct::GO_RETURN => 11,
            GoConstruct::GO_RECOVER => 12,
            GoConstruct::GO_RECEIVER => 13,
            GoConstruct::GO_FOR => 14,
            GoConstruct::GO_DEFER => 15,
            GoConstruct::GO_SWITCH => 16,
            GoConstruct::GO_RANGE => 17,
            GoConstruct::GO_SLICE => 18,
            GoConstruct::GO_POINTER => 19,
            GoConstruct::GO_RUNE => 20,
            GoConstruct::GO_STRING => 21,
            GoConstruct::GO_INT8 => 22,
            GoConstruct::GO_INT16 => 23,
            GoConstruct::GO_INT32 => 24,
            GoConstruct::GO_INT64 => 25,
            GoConstruct::GO_INT => 26,
            GoConstruct::GO_IDENTIFIER => 27,
            GoConstruct::GO_INTERFACE => 28,
            GoConstruct::GO_CONST => 29,
            GoConstruct::GO_COMMENT => 30,
            GoConstruct::GO_BLOCK_COMMENT => 31,
            GoConstruct::GO_DOC_COMMENT => 32,
            GoConstruct::GO_BUILD_COMMENT => 33,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GoConstruct {
    fn default() -> Self {
        GoConstruct::GO_UNKNOWN_CONSTRUCT
    }
}

impl GoConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GoConstruct>("GoConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.RubyConstruct)
pub enum RubyConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_UNKNOWN_CONSTRUCT)
    RUBY_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_REQUIRE)
    RUBY_REQUIRE = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_SCOPE)
    RUBY_SCOPE = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_CLASS)
    RUBY_CLASS = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_MODULE)
    RUBY_MODULE = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_INCLUDE)
    RUBY_INCLUDE = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_METHOD)
    RUBY_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_DEF)
    RUBY_DEF = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_ASYNC)
    RUBY_ASYNC = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_VAR)
    RUBY_VAR = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_MAYBE)
    RUBY_MAYBE = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_RETURN)
    RUBY_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_RESCUE)
    RUBY_RESCUE = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_SELF)
    RUBY_SELF = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_WHILE)
    RUBY_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_BEGIN)
    RUBY_BEGIN = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_CASE)
    RUBY_CASE = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_EACH)
    RUBY_EACH = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_ARRAY)
    RUBY_ARRAY = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_NILABLE)
    RUBY_NILABLE = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_SYMBOL)
    RUBY_SYMBOL = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_STRING)
    RUBY_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_INTEGER)
    RUBY_INTEGER = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_FLOAT)
    RUBY_FLOAT = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_IDENTIFIER)
    RUBY_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_MIXIN)
    RUBY_MIXIN = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_FROZEN)
    RUBY_FROZEN = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_COMMENT)
    RUBY_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_BEGIN_END)
    RUBY_BEGIN_END = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_RDOC)
    RUBY_RDOC = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.RubyConstruct.RUBY_MAGIC_COMMENT)
    RUBY_MAGIC_COMMENT = 42,
}

impl ::protobuf::Enum for RubyConstruct {
    const NAME: &'static str = "RubyConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RubyConstruct> {
        match value {
            0 => ::std::option::Option::Some(RubyConstruct::RUBY_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(RubyConstruct::RUBY_REQUIRE),
            2 => ::std::option::Option::Some(RubyConstruct::RUBY_SCOPE),
            3 => ::std::option::Option::Some(RubyConstruct::RUBY_CLASS),
            4 => ::std::option::Option::Some(RubyConstruct::RUBY_MODULE),
            5 => ::std::option::Option::Some(RubyConstruct::RUBY_INCLUDE),
            6 => ::std::option::Option::Some(RubyConstruct::RUBY_METHOD),
            7 => ::std::option::Option::Some(RubyConstruct::RUBY_DEF),
            8 => ::std::option::Option::Some(RubyConstruct::RUBY_ASYNC),
            9 => ::std::option::Option::Some(RubyConstruct::RUBY_VAR),
            10 => ::std::option::Option::Some(RubyConstruct::RUBY_MAYBE),
            11 => ::std::option::Option::Some(RubyConstruct::RUBY_RETURN),
            12 => ::std::option::Option::Some(RubyConstruct::RUBY_RESCUE),
            13 => ::std::option::Option::Some(RubyConstruct::RUBY_SELF),
            14 => ::std::option::Option::Some(RubyConstruct::RUBY_WHILE),
            15 => ::std::option::Option::Some(RubyConstruct::RUBY_BEGIN),
            16 => ::std::option::Option::Some(RubyConstruct::RUBY_CASE),
            17 => ::std::option::Option::Some(RubyConstruct::RUBY_EACH),
            18 => ::std::option::Option::Some(RubyConstruct::RUBY_ARRAY),
            19 => ::std::option::Option::Some(RubyConstruct::RUBY_NILABLE),
            20 => ::std::option::Option::Some(RubyConstruct::RUBY_SYMBOL),
            21 => ::std::option::Option::Some(RubyConstruct::RUBY_STRING),
            22 => ::std::option::Option::Some(RubyConstruct::RUBY_INTEGER),
            23 => ::std::option::Option::Some(RubyConstruct::RUBY_FLOAT),
            36 => ::std::option::Option::Some(RubyConstruct::RUBY_IDENTIFIER),
            37 => ::std::option::Option::Some(RubyConstruct::RUBY_MIXIN),
            38 => ::std::option::Option::Some(RubyConstruct::RUBY_FROZEN),
            39 => ::std::option::Option::Some(RubyConstruct::RUBY_COMMENT),
            40 => ::std::option::Option::Some(RubyConstruct::RUBY_BEGIN_END),
            41 => ::std::option::Option::Some(RubyConstruct::RUBY_RDOC),
            42 => ::std::option::Option::Some(RubyConstruct::RUBY_MAGIC_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RubyConstruct> {
        match str {
            "RUBY_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(RubyConstruct::RUBY_UNKNOWN_CONSTRUCT),
            "RUBY_REQUIRE" => ::std::option::Option::Some(RubyConstruct::RUBY_REQUIRE),
            "RUBY_SCOPE" => ::std::option::Option::Some(RubyConstruct::RUBY_SCOPE),
            "RUBY_CLASS" => ::std::option::Option::Some(RubyConstruct::RUBY_CLASS),
            "RUBY_MODULE" => ::std::option::Option::Some(RubyConstruct::RUBY_MODULE),
            "RUBY_INCLUDE" => ::std::option::Option::Some(RubyConstruct::RUBY_INCLUDE),
            "RUBY_METHOD" => ::std::option::Option::Some(RubyConstruct::RUBY_METHOD),
            "RUBY_DEF" => ::std::option::Option::Some(RubyConstruct::RUBY_DEF),
            "RUBY_ASYNC" => ::std::option::Option::Some(RubyConstruct::RUBY_ASYNC),
            "RUBY_VAR" => ::std::option::Option::Some(RubyConstruct::RUBY_VAR),
            "RUBY_MAYBE" => ::std::option::Option::Some(RubyConstruct::RUBY_MAYBE),
            "RUBY_RETURN" => ::std::option::Option::Some(RubyConstruct::RUBY_RETURN),
            "RUBY_RESCUE" => ::std::option::Option::Some(RubyConstruct::RUBY_RESCUE),
            "RUBY_SELF" => ::std::option::Option::Some(RubyConstruct::RUBY_SELF),
            "RUBY_WHILE" => ::std::option::Option::Some(RubyConstruct::RUBY_WHILE),
            "RUBY_BEGIN" => ::std::option::Option::Some(RubyConstruct::RUBY_BEGIN),
            "RUBY_CASE" => ::std::option::Option::Some(RubyConstruct::RUBY_CASE),
            "RUBY_EACH" => ::std::option::Option::Some(RubyConstruct::RUBY_EACH),
            "RUBY_ARRAY" => ::std::option::Option::Some(RubyConstruct::RUBY_ARRAY),
            "RUBY_NILABLE" => ::std::option::Option::Some(RubyConstruct::RUBY_NILABLE),
            "RUBY_SYMBOL" => ::std::option::Option::Some(RubyConstruct::RUBY_SYMBOL),
            "RUBY_STRING" => ::std::option::Option::Some(RubyConstruct::RUBY_STRING),
            "RUBY_INTEGER" => ::std::option::Option::Some(RubyConstruct::RUBY_INTEGER),
            "RUBY_FLOAT" => ::std::option::Option::Some(RubyConstruct::RUBY_FLOAT),
            "RUBY_IDENTIFIER" => ::std::option::Option::Some(RubyConstruct::RUBY_IDENTIFIER),
            "RUBY_MIXIN" => ::std::option::Option::Some(RubyConstruct::RUBY_MIXIN),
            "RUBY_FROZEN" => ::std::option::Option::Some(RubyConstruct::RUBY_FROZEN),
            "RUBY_COMMENT" => ::std::option::Option::Some(RubyConstruct::RUBY_COMMENT),
            "RUBY_BEGIN_END" => ::std::option::Option::Some(RubyConstruct::RUBY_BEGIN_END),
            "RUBY_RDOC" => ::std::option::Option::Some(RubyConstruct::RUBY_RDOC),
            "RUBY_MAGIC_COMMENT" => ::std::option::Option::Some(RubyConstruct::RUBY_MAGIC_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RubyConstruct] = &[
        RubyConstruct::RUBY_UNKNOWN_CONSTRUCT,
        RubyConstruct::RUBY_REQUIRE,
        RubyConstruct::RUBY_SCOPE,
        RubyConstruct::RUBY_CLASS,
        RubyConstruct::RUBY_MODULE,
        RubyConstruct::RUBY_INCLUDE,
        RubyConstruct::RUBY_METHOD,
        RubyConstruct::RUBY_DEF,
        RubyConstruct::RUBY_ASYNC,
        RubyConstruct::RUBY_VAR,
        RubyConstruct::RUBY_MAYBE,
        RubyConstruct::RUBY_RETURN,
        RubyConstruct::RUBY_RESCUE,
        RubyConstruct::RUBY_SELF,
        RubyConstruct::RUBY_WHILE,
        RubyConstruct::RUBY_BEGIN,
        RubyConstruct::RUBY_CASE,
        RubyConstruct::RUBY_EACH,
        RubyConstruct::RUBY_ARRAY,
        RubyConstruct::RUBY_NILABLE,
        RubyConstruct::RUBY_SYMBOL,
        RubyConstruct::RUBY_STRING,
        RubyConstruct::RUBY_INTEGER,
        RubyConstruct::RUBY_FLOAT,
        RubyConstruct::RUBY_IDENTIFIER,
        RubyConstruct::RUBY_MIXIN,
        RubyConstruct::RUBY_FROZEN,
        RubyConstruct::RUBY_COMMENT,
        RubyConstruct::RUBY_BEGIN_END,
        RubyConstruct::RUBY_RDOC,
        RubyConstruct::RUBY_MAGIC_COMMENT,
    ];
}

impl ::protobuf::EnumFull for RubyConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RubyConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            RubyConstruct::RUBY_UNKNOWN_CONSTRUCT => 0,
            RubyConstruct::RUBY_REQUIRE => 1,
            RubyConstruct::RUBY_SCOPE => 2,
            RubyConstruct::RUBY_CLASS => 3,
            RubyConstruct::RUBY_MODULE => 4,
            RubyConstruct::RUBY_INCLUDE => 5,
            RubyConstruct::RUBY_METHOD => 6,
            RubyConstruct::RUBY_DEF => 7,
            RubyConstruct::RUBY_ASYNC => 8,
            RubyConstruct::RUBY_VAR => 9,
            RubyConstruct::RUBY_MAYBE => 10,
            RubyConstruct::RUBY_RETURN => 11,
            RubyConstruct::RUBY_RESCUE => 12,
            RubyConstruct::RUBY_SELF => 13,
            RubyConstruct::RUBY_WHILE => 14,
            RubyConstruct::RUBY_BEGIN => 15,
            RubyConstruct::RUBY_CASE => 16,
            RubyConstruct::RUBY_EACH => 17,
            RubyConstruct::RUBY_ARRAY => 18,
            RubyConstruct::RUBY_NILABLE => 19,
            RubyConstruct::RUBY_SYMBOL => 20,
            RubyConstruct::RUBY_STRING => 21,
            RubyConstruct::RUBY_INTEGER => 22,
            RubyConstruct::RUBY_FLOAT => 23,
            RubyConstruct::RUBY_IDENTIFIER => 24,
            RubyConstruct::RUBY_MIXIN => 25,
            RubyConstruct::RUBY_FROZEN => 26,
            RubyConstruct::RUBY_COMMENT => 27,
            RubyConstruct::RUBY_BEGIN_END => 28,
            RubyConstruct::RUBY_RDOC => 29,
            RubyConstruct::RUBY_MAGIC_COMMENT => 30,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RubyConstruct {
    fn default() -> Self {
        RubyConstruct::RUBY_UNKNOWN_CONSTRUCT
    }
}

impl RubyConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RubyConstruct>("RubyConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.CPPConstruct)
pub enum CPPConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_UNKNOWN_CONSTRUCT)
    CPP_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_INCLUDE)
    CPP_INCLUDE = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_SCOPE)
    CPP_SCOPE = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_STRUCT)
    CPP_STRUCT = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_ENUM)
    CPP_ENUM = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_INHERITANCE)
    CPP_INHERITANCE = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_METHOD)
    CPP_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_FUNCTION)
    CPP_FUNCTION = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_CO_AWAIT)
    CPP_CO_AWAIT = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_AUTO)
    CPP_AUTO = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_EXPECTED)
    CPP_EXPECTED = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_RETURN)
    CPP_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_CATCH)
    CPP_CATCH = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_THIS)
    CPP_THIS = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_WHILE)
    CPP_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_TRY)
    CPP_TRY = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_SWITCH)
    CPP_SWITCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_FOR)
    CPP_FOR = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_TUPLE)
    CPP_TUPLE = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_OPTIONAL)
    CPP_OPTIONAL = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_STRING_VIEW)
    CPP_STRING_VIEW = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_STRING)
    CPP_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_INT8)
    CPP_INT8 = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_INT16)
    CPP_INT16 = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_INT32)
    CPP_INT32 = 24,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_INT64)
    CPP_INT64 = 25,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_INT128)
    CPP_INT128 = 26,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_IDENTIFIER)
    CPP_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_ABSTRACT)
    CPP_ABSTRACT = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_CONST)
    CPP_CONST = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_COMMENT)
    CPP_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_BLOCK_COMMENT)
    CPP_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_DOC_COMMENT)
    CPP_DOC_COMMENT = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CPPConstruct.CPP_PRAGMA)
    CPP_PRAGMA = 42,
}

impl ::protobuf::Enum for CPPConstruct {
    const NAME: &'static str = "CPPConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CPPConstruct> {
        match value {
            0 => ::std::option::Option::Some(CPPConstruct::CPP_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(CPPConstruct::CPP_INCLUDE),
            2 => ::std::option::Option::Some(CPPConstruct::CPP_SCOPE),
            3 => ::std::option::Option::Some(CPPConstruct::CPP_STRUCT),
            4 => ::std::option::Option::Some(CPPConstruct::CPP_ENUM),
            5 => ::std::option::Option::Some(CPPConstruct::CPP_INHERITANCE),
            6 => ::std::option::Option::Some(CPPConstruct::CPP_METHOD),
            7 => ::std::option::Option::Some(CPPConstruct::CPP_FUNCTION),
            8 => ::std::option::Option::Some(CPPConstruct::CPP_CO_AWAIT),
            9 => ::std::option::Option::Some(CPPConstruct::CPP_AUTO),
            10 => ::std::option::Option::Some(CPPConstruct::CPP_EXPECTED),
            11 => ::std::option::Option::Some(CPPConstruct::CPP_RETURN),
            12 => ::std::option::Option::Some(CPPConstruct::CPP_CATCH),
            13 => ::std::option::Option::Some(CPPConstruct::CPP_THIS),
            14 => ::std::option::Option::Some(CPPConstruct::CPP_WHILE),
            15 => ::std::option::Option::Some(CPPConstruct::CPP_TRY),
            16 => ::std::option::Option::Some(CPPConstruct::CPP_SWITCH),
            17 => ::std::option::Option::Some(CPPConstruct::CPP_FOR),
            18 => ::std::option::Option::Some(CPPConstruct::CPP_TUPLE),
            19 => ::std::option::Option::Some(CPPConstruct::CPP_OPTIONAL),
            20 => ::std::option::Option::Some(CPPConstruct::CPP_STRING_VIEW),
            21 => ::std::option::Option::Some(CPPConstruct::CPP_STRING),
            22 => ::std::option::Option::Some(CPPConstruct::CPP_INT8),
            23 => ::std::option::Option::Some(CPPConstruct::CPP_INT16),
            24 => ::std::option::Option::Some(CPPConstruct::CPP_INT32),
            25 => ::std::option::Option::Some(CPPConstruct::CPP_INT64),
            26 => ::std::option::Option::Some(CPPConstruct::CPP_INT128),
            36 => ::std::option::Option::Some(CPPConstruct::CPP_IDENTIFIER),
            37 => ::std::option::Option::Some(CPPConstruct::CPP_ABSTRACT),
            38 => ::std::option::Option::Some(CPPConstruct::CPP_CONST),
            39 => ::std::option::Option::Some(CPPConstruct::CPP_COMMENT),
            40 => ::std::option::Option::Some(CPPConstruct::CPP_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(CPPConstruct::CPP_DOC_COMMENT),
            42 => ::std::option::Option::Some(CPPConstruct::CPP_PRAGMA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CPPConstruct> {
        match str {
            "CPP_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(CPPConstruct::CPP_UNKNOWN_CONSTRUCT),
            "CPP_INCLUDE" => ::std::option::Option::Some(CPPConstruct::CPP_INCLUDE),
            "CPP_SCOPE" => ::std::option::Option::Some(CPPConstruct::CPP_SCOPE),
            "CPP_STRUCT" => ::std::option::Option::Some(CPPConstruct::CPP_STRUCT),
            "CPP_ENUM" => ::std::option::Option::Some(CPPConstruct::CPP_ENUM),
            "CPP_INHERITANCE" => ::std::option::Option::Some(CPPConstruct::CPP_INHERITANCE),
            "CPP_METHOD" => ::std::option::Option::Some(CPPConstruct::CPP_METHOD),
            "CPP_FUNCTION" => ::std::option::Option::Some(CPPConstruct::CPP_FUNCTION),
            "CPP_CO_AWAIT" => ::std::option::Option::Some(CPPConstruct::CPP_CO_AWAIT),
            "CPP_AUTO" => ::std::option::Option::Some(CPPConstruct::CPP_AUTO),
            "CPP_EXPECTED" => ::std::option::Option::Some(CPPConstruct::CPP_EXPECTED),
            "CPP_RETURN" => ::std::option::Option::Some(CPPConstruct::CPP_RETURN),
            "CPP_CATCH" => ::std::option::Option::Some(CPPConstruct::CPP_CATCH),
            "CPP_THIS" => ::std::option::Option::Some(CPPConstruct::CPP_THIS),
            "CPP_WHILE" => ::std::option::Option::Some(CPPConstruct::CPP_WHILE),
            "CPP_TRY" => ::std::option::Option::Some(CPPConstruct::CPP_TRY),
            "CPP_SWITCH" => ::std::option::Option::Some(CPPConstruct::CPP_SWITCH),
            "CPP_FOR" => ::std::option::Option::Some(CPPConstruct::CPP_FOR),
            "CPP_TUPLE" => ::std::option::Option::Some(CPPConstruct::CPP_TUPLE),
            "CPP_OPTIONAL" => ::std::option::Option::Some(CPPConstruct::CPP_OPTIONAL),
            "CPP_STRING_VIEW" => ::std::option::Option::Some(CPPConstruct::CPP_STRING_VIEW),
            "CPP_STRING" => ::std::option::Option::Some(CPPConstruct::CPP_STRING),
            "CPP_INT8" => ::std::option::Option::Some(CPPConstruct::CPP_INT8),
            "CPP_INT16" => ::std::option::Option::Some(CPPConstruct::CPP_INT16),
            "CPP_INT32" => ::std::option::Option::Some(CPPConstruct::CPP_INT32),
            "CPP_INT64" => ::std::option::Option::Some(CPPConstruct::CPP_INT64),
            "CPP_INT128" => ::std::option::Option::Some(CPPConstruct::CPP_INT128),
            "CPP_IDENTIFIER" => ::std::option::Option::Some(CPPConstruct::CPP_IDENTIFIER),
            "CPP_ABSTRACT" => ::std::option::Option::Some(CPPConstruct::CPP_ABSTRACT),
            "CPP_CONST" => ::std::option::Option::Some(CPPConstruct::CPP_CONST),
            "CPP_COMMENT" => ::std::option::Option::Some(CPPConstruct::CPP_COMMENT),
            "CPP_BLOCK_COMMENT" => ::std::option::Option::Some(CPPConstruct::CPP_BLOCK_COMMENT),
            "CPP_DOC_COMMENT" => ::std::option::Option::Some(CPPConstruct::CPP_DOC_COMMENT),
            "CPP_PRAGMA" => ::std::option::Option::Some(CPPConstruct::CPP_PRAGMA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CPPConstruct] = &[
        CPPConstruct::CPP_UNKNOWN_CONSTRUCT,
        CPPConstruct::CPP_INCLUDE,
        CPPConstruct::CPP_SCOPE,
        CPPConstruct::CPP_STRUCT,
        CPPConstruct::CPP_ENUM,
        CPPConstruct::CPP_INHERITANCE,
        CPPConstruct::CPP_METHOD,
        CPPConstruct::CPP_FUNCTION,
        CPPConstruct::CPP_CO_AWAIT,
        CPPConstruct::CPP_AUTO,
        CPPConstruct::CPP_EXPECTED,
        CPPConstruct::CPP_RETURN,
        CPPConstruct::CPP_CATCH,
        CPPConstruct::CPP_THIS,
        CPPConstruct::CPP_WHILE,
        CPPConstruct::CPP_TRY,
        CPPConstruct::CPP_SWITCH,
        CPPConstruct::CPP_FOR,
        CPPConstruct::CPP_TUPLE,
        CPPConstruct::CPP_OPTIONAL,
        CPPConstruct::CPP_STRING_VIEW,
        CPPConstruct::CPP_STRING,
        CPPConstruct::CPP_INT8,
        CPPConstruct::CPP_INT16,
        CPPConstruct::CPP_INT32,
        CPPConstruct::CPP_INT64,
        CPPConstruct::CPP_INT128,
        CPPConstruct::CPP_IDENTIFIER,
        CPPConstruct::CPP_ABSTRACT,
        CPPConstruct::CPP_CONST,
        CPPConstruct::CPP_COMMENT,
        CPPConstruct::CPP_BLOCK_COMMENT,
        CPPConstruct::CPP_DOC_COMMENT,
        CPPConstruct::CPP_PRAGMA,
    ];
}

impl ::protobuf::EnumFull for CPPConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CPPConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CPPConstruct::CPP_UNKNOWN_CONSTRUCT => 0,
            CPPConstruct::CPP_INCLUDE => 1,
            CPPConstruct::CPP_SCOPE => 2,
            CPPConstruct::CPP_STRUCT => 3,
            CPPConstruct::CPP_ENUM => 4,
            CPPConstruct::CPP_INHERITANCE => 5,
            CPPConstruct::CPP_METHOD => 6,
            CPPConstruct::CPP_FUNCTION => 7,
            CPPConstruct::CPP_CO_AWAIT => 8,
            CPPConstruct::CPP_AUTO => 9,
            CPPConstruct::CPP_EXPECTED => 10,
            CPPConstruct::CPP_RETURN => 11,
            CPPConstruct::CPP_CATCH => 12,
            CPPConstruct::CPP_THIS => 13,
            CPPConstruct::CPP_WHILE => 14,
            CPPConstruct::CPP_TRY => 15,
            CPPConstruct::CPP_SWITCH => 16,
            CPPConstruct::CPP_FOR => 17,
            CPPConstruct::CPP_TUPLE => 18,
            CPPConstruct::CPP_OPTIONAL => 19,
            CPPConstruct::CPP_STRING_VIEW => 20,
            CPPConstruct::CPP_STRING => 21,
            CPPConstruct::CPP_INT8 => 22,
            CPPConstruct::CPP_INT16 => 23,
            CPPConstruct::CPP_INT32 => 24,
            CPPConstruct::CPP_INT64 => 25,
            CPPConstruct::CPP_INT128 => 26,
            CPPConstruct::CPP_IDENTIFIER => 27,
            CPPConstruct::CPP_ABSTRACT => 28,
            CPPConstruct::CPP_CONST => 29,
            CPPConstruct::CPP_COMMENT => 30,
            CPPConstruct::CPP_BLOCK_COMMENT => 31,
            CPPConstruct::CPP_DOC_COMMENT => 32,
            CPPConstruct::CPP_PRAGMA => 33,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CPPConstruct {
    fn default() -> Self {
        CPPConstruct::CPP_UNKNOWN_CONSTRUCT
    }
}

impl CPPConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CPPConstruct>("CPPConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.CSharpConstruct)
pub enum CSharpConstruct {
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_UNKNOWN_CONSTRUCT)
    CSHARP_UNKNOWN_CONSTRUCT = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_USING)
    CSHARP_USING = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_DOT)
    CSHARP_DOT = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_CLASS)
    CSHARP_CLASS = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_ENUM)
    CSHARP_ENUM = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_IMPLEMENTS)
    CSHARP_IMPLEMENTS = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_METHOD)
    CSHARP_METHOD = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_FUNCTION)
    CSHARP_FUNCTION = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_AWAIT)
    CSHARP_AWAIT = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_VAR)
    CSHARP_VAR = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_TASK)
    CSHARP_TASK = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_RETURN)
    CSHARP_RETURN = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_CATCH)
    CSHARP_CATCH = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_THIS)
    CSHARP_THIS = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_WHILE)
    CSHARP_WHILE = 14,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_TRY)
    CSHARP_TRY = 15,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_SWITCH)
    CSHARP_SWITCH = 16,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_FOREACH)
    CSHARP_FOREACH = 17,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_TUPLE)
    CSHARP_TUPLE = 18,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_NULLABLE)
    CSHARP_NULLABLE = 19,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_SPAN)
    CSHARP_SPAN = 20,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_STRING)
    CSHARP_STRING = 21,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_SBYTE)
    CSHARP_SBYTE = 22,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_SHORT)
    CSHARP_SHORT = 23,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_INT)
    CSHARP_INT = 24,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_LONG)
    CSHARP_LONG = 25,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_BIGINTEGER)
    CSHARP_BIGINTEGER = 26,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_IDENTIFIER)
    CSHARP_IDENTIFIER = 36,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_INTERFACE)
    CSHARP_INTERFACE = 37,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_READONLY)
    CSHARP_READONLY = 38,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_COMMENT)
    CSHARP_COMMENT = 39,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_BLOCK_COMMENT)
    CSHARP_BLOCK_COMMENT = 40,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_XML_DOC)
    CSHARP_XML_DOC = 41,
    // @@protoc_insertion_point(enum_value:kymera_mappings.CSharpConstruct.CSHARP_PRAGMA)
    CSHARP_PRAGMA = 42,
}

impl ::protobuf::Enum for CSharpConstruct {
    const NAME: &'static str = "CSharpConstruct";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CSharpConstruct> {
        match value {
            0 => ::std::option::Option::Some(CSharpConstruct::CSHARP_UNKNOWN_CONSTRUCT),
            1 => ::std::option::Option::Some(CSharpConstruct::CSHARP_USING),
            2 => ::std::option::Option::Some(CSharpConstruct::CSHARP_DOT),
            3 => ::std::option::Option::Some(CSharpConstruct::CSHARP_CLASS),
            4 => ::std::option::Option::Some(CSharpConstruct::CSHARP_ENUM),
            5 => ::std::option::Option::Some(CSharpConstruct::CSHARP_IMPLEMENTS),
            6 => ::std::option::Option::Some(CSharpConstruct::CSHARP_METHOD),
            7 => ::std::option::Option::Some(CSharpConstruct::CSHARP_FUNCTION),
            8 => ::std::option::Option::Some(CSharpConstruct::CSHARP_AWAIT),
            9 => ::std::option::Option::Some(CSharpConstruct::CSHARP_VAR),
            10 => ::std::option::Option::Some(CSharpConstruct::CSHARP_TASK),
            11 => ::std::option::Option::Some(CSharpConstruct::CSHARP_RETURN),
            12 => ::std::option::Option::Some(CSharpConstruct::CSHARP_CATCH),
            13 => ::std::option::Option::Some(CSharpConstruct::CSHARP_THIS),
            14 => ::std::option::Option::Some(CSharpConstruct::CSHARP_WHILE),
            15 => ::std::option::Option::Some(CSharpConstruct::CSHARP_TRY),
            16 => ::std::option::Option::Some(CSharpConstruct::CSHARP_SWITCH),
            17 => ::std::option::Option::Some(CSharpConstruct::CSHARP_FOREACH),
            18 => ::std::option::Option::Some(CSharpConstruct::CSHARP_TUPLE),
            19 => ::std::option::Option::Some(CSharpConstruct::CSHARP_NULLABLE),
            20 => ::std::option::Option::Some(CSharpConstruct::CSHARP_SPAN),
            21 => ::std::option::Option::Some(CSharpConstruct::CSHARP_STRING),
            22 => ::std::option::Option::Some(CSharpConstruct::CSHARP_SBYTE),
            23 => ::std::option::Option::Some(CSharpConstruct::CSHARP_SHORT),
            24 => ::std::option::Option::Some(CSharpConstruct::CSHARP_INT),
            25 => ::std::option::Option::Some(CSharpConstruct::CSHARP_LONG),
            26 => ::std::option::Option::Some(CSharpConstruct::CSHARP_BIGINTEGER),
            36 => ::std::option::Option::Some(CSharpConstruct::CSHARP_IDENTIFIER),
            37 => ::std::option::Option::Some(CSharpConstruct::CSHARP_INTERFACE),
            38 => ::std::option::Option::Some(CSharpConstruct::CSHARP_READONLY),
            39 => ::std::option::Option::Some(CSharpConstruct::CSHARP_COMMENT),
            40 => ::std::option::Option::Some(CSharpConstruct::CSHARP_BLOCK_COMMENT),
            41 => ::std::option::Option::Some(CSharpConstruct::CSHARP_XML_DOC),
            42 => ::std::option::Option::Some(CSharpConstruct::CSHARP_PRAGMA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CSharpConstruct> {
        match str {
            "CSHARP_UNKNOWN_CONSTRUCT" => ::std::option::Option::Some(CSharpConstruct::CSHARP_UNKNOWN_CONSTRUCT),
            "CSHARP_USING" => ::std::option::Option::Some(CSharpConstruct::CSHARP_USING),
            "CSHARP_DOT" => ::std::option::Option::Some(CSharpConstruct::CSHARP_DOT),
            "CSHARP_CLASS" => ::std::option::Option::Some(CSharpConstruct::CSHARP_CLASS),
            "CSHARP_ENUM" => ::std::option::Option::Some(CSharpConstruct::CSHARP_ENUM),
            "CSHARP_IMPLEMENTS" => ::std::option::Option::Some(CSharpConstruct::CSHARP_IMPLEMENTS),
            "CSHARP_METHOD" => ::std::option::Option::Some(CSharpConstruct::CSHARP_METHOD),
            "CSHARP_FUNCTION" => ::std::option::Option::Some(CSharpConstruct::CSHARP_FUNCTION),
            "CSHARP_AWAIT" => ::std::option::Option::Some(CSharpConstruct::CSHARP_AWAIT),
            "CSHARP_VAR" => ::std::option::Option::Some(CSharpConstruct::CSHARP_VAR),
            "CSHARP_TASK" => ::std::option::Option::Some(CSharpConstruct::CSHARP_TASK),
            "CSHARP_RETURN" => ::std::option::Option::Some(CSharpConstruct::CSHARP_RETURN),
            "CSHARP_CATCH" => ::std::option::Option::Some(CSharpConstruct::CSHARP_CATCH),
            "CSHARP_THIS" => ::std::option::Option::Some(CSharpConstruct::CSHARP_THIS),
            "CSHARP_WHILE" => ::std::option::Option::Some(CSharpConstruct::CSHARP_WHILE),
            "CSHARP_TRY" => ::std::option::Option::Some(CSharpConstruct::CSHARP_TRY),
            "CSHARP_SWITCH" => ::std::option::Option::Some(CSharpConstruct::CSHARP_SWITCH),
            "CSHARP_FOREACH" => ::std::option::Option::Some(CSharpConstruct::CSHARP_FOREACH),
            "CSHARP_TUPLE" => ::std::option::Option::Some(CSharpConstruct::CSHARP_TUPLE),
            "CSHARP_NULLABLE" => ::std::option::Option::Some(CSharpConstruct::CSHARP_NULLABLE),
            "CSHARP_SPAN" => ::std::option::Option::Some(CSharpConstruct::CSHARP_SPAN),
            "CSHARP_STRING" => ::std::option::Option::Some(CSharpConstruct::CSHARP_STRING),
            "CSHARP_SBYTE" => ::std::option::Option::Some(CSharpConstruct::CSHARP_SBYTE),
            "CSHARP_SHORT" => ::std::option::Option::Some(CSharpConstruct::CSHARP_SHORT),
            "CSHARP_INT" => ::std::option::Option::Some(CSharpConstruct::CSHARP_INT),
            "CSHARP_LONG" => ::std::option::Option::Some(CSharpConstruct::CSHARP_LONG),
            "CSHARP_BIGINTEGER" => ::std::option::Option::Some(CSharpConstruct::CSHARP_BIGINTEGER),
            "CSHARP_IDENTIFIER" => ::std::option::Option::Some(CSharpConstruct::CSHARP_IDENTIFIER),
            "CSHARP_INTERFACE" => ::std::option::Option::Some(CSharpConstruct::CSHARP_INTERFACE),
            "CSHARP_READONLY" => ::std::option::Option::Some(CSharpConstruct::CSHARP_READONLY),
            "CSHARP_COMMENT" => ::std::option::Option::Some(CSharpConstruct::CSHARP_COMMENT),
            "CSHARP_BLOCK_COMMENT" => ::std::option::Option::Some(CSharpConstruct::CSHARP_BLOCK_COMMENT),
            "CSHARP_XML_DOC" => ::std::option::Option::Some(CSharpConstruct::CSHARP_XML_DOC),
            "CSHARP_PRAGMA" => ::std::option::Option::Some(CSharpConstruct::CSHARP_PRAGMA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CSharpConstruct] = &[
        CSharpConstruct::CSHARP_UNKNOWN_CONSTRUCT,
        CSharpConstruct::CSHARP_USING,
        CSharpConstruct::CSHARP_DOT,
        CSharpConstruct::CSHARP_CLASS,
        CSharpConstruct::CSHARP_ENUM,
        CSharpConstruct::CSHARP_IMPLEMENTS,
        CSharpConstruct::CSHARP_METHOD,
        CSharpConstruct::CSHARP_FUNCTION,
        CSharpConstruct::CSHARP_AWAIT,
        CSharpConstruct::CSHARP_VAR,
        CSharpConstruct::CSHARP_TASK,
        CSharpConstruct::CSHARP_RETURN,
        CSharpConstruct::CSHARP_CATCH,
        CSharpConstruct::CSHARP_THIS,
        CSharpConstruct::CSHARP_WHILE,
        CSharpConstruct::CSHARP_TRY,
        CSharpConstruct::CSHARP_SWITCH,
        CSharpConstruct::CSHARP_FOREACH,
        CSharpConstruct::CSHARP_TUPLE,
        CSharpConstruct::CSHARP_NULLABLE,
        CSharpConstruct::CSHARP_SPAN,
        CSharpConstruct::CSHARP_STRING,
        CSharpConstruct::CSHARP_SBYTE,
        CSharpConstruct::CSHARP_SHORT,
        CSharpConstruct::CSHARP_INT,
        CSharpConstruct::CSHARP_LONG,
        CSharpConstruct::CSHARP_BIGINTEGER,
        CSharpConstruct::CSHARP_IDENTIFIER,
        CSharpConstruct::CSHARP_INTERFACE,
        CSharpConstruct::CSHARP_READONLY,
        CSharpConstruct::CSHARP_COMMENT,
        CSharpConstruct::CSHARP_BLOCK_COMMENT,
        CSharpConstruct::CSHARP_XML_DOC,
        CSharpConstruct::CSHARP_PRAGMA,
    ];
}

impl ::protobuf::EnumFull for CSharpConstruct {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CSharpConstruct").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CSharpConstruct::CSHARP_UNKNOWN_CONSTRUCT => 0,
            CSharpConstruct::CSHARP_USING => 1,
            CSharpConstruct::CSHARP_DOT => 2,
            CSharpConstruct::CSHARP_CLASS => 3,
            CSharpConstruct::CSHARP_ENUM => 4,
            CSharpConstruct::CSHARP_IMPLEMENTS => 5,
            CSharpConstruct::CSHARP_METHOD => 6,
            CSharpConstruct::CSHARP_FUNCTION => 7,
            CSharpConstruct::CSHARP_AWAIT => 8,
            CSharpConstruct::CSHARP_VAR => 9,
            CSharpConstruct::CSHARP_TASK => 10,
            CSharpConstruct::CSHARP_RETURN => 11,
            CSharpConstruct::CSHARP_CATCH => 12,
            CSharpConstruct::CSHARP_THIS => 13,
            CSharpConstruct::CSHARP_WHILE => 14,
            CSharpConstruct::CSHARP_TRY => 15,
            CSharpConstruct::CSHARP_SWITCH => 16,
            CSharpConstruct::CSHARP_FOREACH => 17,
            CSharpConstruct::CSHARP_TUPLE => 18,
            CSharpConstruct::CSHARP_NULLABLE => 19,
            CSharpConstruct::CSHARP_SPAN => 20,
            CSharpConstruct::CSHARP_STRING => 21,
            CSharpConstruct::CSHARP_SBYTE => 22,
            CSharpConstruct::CSHARP_SHORT => 23,
            CSharpConstruct::CSHARP_INT => 24,
            CSharpConstruct::CSHARP_LONG => 25,
            CSharpConstruct::CSHARP_BIGINTEGER => 26,
            CSharpConstruct::CSHARP_IDENTIFIER => 27,
            CSharpConstruct::CSHARP_INTERFACE => 28,
            CSharpConstruct::CSHARP_READONLY => 29,
            CSharpConstruct::CSHARP_COMMENT => 30,
            CSharpConstruct::CSHARP_BLOCK_COMMENT => 31,
            CSharpConstruct::CSHARP_XML_DOC => 32,
            CSharpConstruct::CSHARP_PRAGMA => 33,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CSharpConstruct {
    fn default() -> Self {
        CSharpConstruct::CSHARP_UNKNOWN_CONSTRUCT
    }
}

impl CSharpConstruct {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CSharpConstruct>("CSharpConstruct")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:kymera_mappings.NumericType)
pub enum NumericType {
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.NUMERIC_UNKNOWN)
    NUMERIC_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.INT8)
    INT8 = 1,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.INT16)
    INT16 = 2,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.INT32)
    INT32 = 3,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.INT64)
    INT64 = 4,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.INT128)
    INT128 = 5,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.INT_ARCH)
    INT_ARCH = 6,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.UINT8)
    UINT8 = 7,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.UINT16)
    UINT16 = 8,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.UINT32)
    UINT32 = 9,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.UINT64)
    UINT64 = 10,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.UINT128)
    UINT128 = 11,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.UINT_ARCH)
    UINT_ARCH = 12,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.FLOAT32)
    FLOAT32 = 13,
    // @@protoc_insertion_point(enum_value:kymera_mappings.NumericType.FLOAT64)
    FLOAT64 = 14,
}

impl ::protobuf::Enum for NumericType {
    const NAME: &'static str = "NumericType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NumericType> {
        match value {
            0 => ::std::option::Option::Some(NumericType::NUMERIC_UNKNOWN),
            1 => ::std::option::Option::Some(NumericType::INT8),
            2 => ::std::option::Option::Some(NumericType::INT16),
            3 => ::std::option::Option::Some(NumericType::INT32),
            4 => ::std::option::Option::Some(NumericType::INT64),
            5 => ::std::option::Option::Some(NumericType::INT128),
            6 => ::std::option::Option::Some(NumericType::INT_ARCH),
            7 => ::std::option::Option::Some(NumericType::UINT8),
            8 => ::std::option::Option::Some(NumericType::UINT16),
            9 => ::std::option::Option::Some(NumericType::UINT32),
            10 => ::std::option::Option::Some(NumericType::UINT64),
            11 => ::std::option::Option::Some(NumericType::UINT128),
            12 => ::std::option::Option::Some(NumericType::UINT_ARCH),
            13 => ::std::option::Option::Some(NumericType::FLOAT32),
            14 => ::std::option::Option::Some(NumericType::FLOAT64),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NumericType> {
        match str {
            "NUMERIC_UNKNOWN" => ::std::option::Option::Some(NumericType::NUMERIC_UNKNOWN),
            "INT8" => ::std::option::Option::Some(NumericType::INT8),
            "INT16" => ::std::option::Option::Some(NumericType::INT16),
            "INT32" => ::std::option::Option::Some(NumericType::INT32),
            "INT64" => ::std::option::Option::Some(NumericType::INT64),
            "INT128" => ::std::option::Option::Some(NumericType::INT128),
            "INT_ARCH" => ::std::option::Option::Some(NumericType::INT_ARCH),
            "UINT8" => ::std::option::Option::Some(NumericType::UINT8),
            "UINT16" => ::std::option::Option::Some(NumericType::UINT16),
            "UINT32" => ::std::option::Option::Some(NumericType::UINT32),
            "UINT64" => ::std::option::Option::Some(NumericType::UINT64),
            "UINT128" => ::std::option::Option::Some(NumericType::UINT128),
            "UINT_ARCH" => ::std::option::Option::Some(NumericType::UINT_ARCH),
            "FLOAT32" => ::std::option::Option::Some(NumericType::FLOAT32),
            "FLOAT64" => ::std::option::Option::Some(NumericType::FLOAT64),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NumericType] = &[
        NumericType::NUMERIC_UNKNOWN,
        NumericType::INT8,
        NumericType::INT16,
        NumericType::INT32,
        NumericType::INT64,
        NumericType::INT128,
        NumericType::INT_ARCH,
        NumericType::UINT8,
        NumericType::UINT16,
        NumericType::UINT32,
        NumericType::UINT64,
        NumericType::UINT128,
        NumericType::UINT_ARCH,
        NumericType::FLOAT32,
        NumericType::FLOAT64,
    ];
}

impl ::protobuf::EnumFull for NumericType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NumericType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NumericType {
    fn default() -> Self {
        NumericType::NUMERIC_UNKNOWN
    }
}

impl NumericType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NumericType>("NumericType")
    }
}

/// Extension fields
pub mod exts {

    pub const example: ::protobuf::ext::ExtFieldOptional<::protobuf::descriptor::EnumValueOptions, super::ExampleOption> = ::protobuf::ext::ExtFieldOptional::new(50001, ::protobuf::descriptor::field_descriptor_proto::Type::TYPE_MESSAGE);
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15kymera_mappings.proto\x12\x0fkymera_mappings\x1a\x20google/protobu\
    f/descriptor.proto\"\x87\x02\n\nTestConfig\x12\x1b\n\ttest_name\x18\x01\
    \x20\x01(\tR\x08testName\x12\x1d\n\ntest_cases\x18\x02\x20\x03(\tR\ttest\
    Cases\x12[\n\x10expected_results\x18\x03\x20\x03(\x0b20.kymera_mappings.\
    TestConfig.ExpectedResultsEntryR\x0fexpectedResults\x12\x1c\n\tautomated\
    \x18\x04\x20\x01(\x08R\tautomated\x1aB\n\x14ExpectedResultsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"\xe1\x03\n\x0bTestExample\x12\x1b\n\ttest_case\
    \x18\x01\x20\x01(\tR\x08testCase\x12@\n\x06inputs\x18\x02\x20\x03(\x0b2(\
    .kymera_mappings.TestExample.InputsEntryR\x06inputs\x12\\\n\x10expected_\
    outputs\x18\x03\x20\x03(\x0b21.kymera_mappings.TestExample.ExpectedOutpu\
    tsEntryR\x0fexpectedOutputs\x12)\n\x10validation_steps\x18\x04\x20\x03(\
    \tR\x0fvalidationSteps\x12<\n\x0btest_config\x18\x05\x20\x01(\x0b2\x1b.k\
    ymera_mappings.TestConfigR\ntestConfig\x12-\n\x12testing_guidelines\x18\
    \x06\x20\x03(\tR\x11testingGuidelines\x1a9\n\x0bInputsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1aB\n\x14ExpectedOutputsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\"\x8f\x02\n\x0bBaseMapping\x12)\n\x10source_construct\x18\x01\
    \x20\x01(\tR\x0fsourceConstruct\x12)\n\x10target_construct\x18\x02\x20\
    \x01(\tR\x0ftargetConstruct\x12%\n\x0edirect_mapping\x18\x03\x20\x01(\
    \x08R\rdirectMapping\x12F\n\x08examples\x18\x04\x20\x03(\x0b2*.kymera_ma\
    ppings.BaseMapping.ExamplesEntryR\x08examples\x1a;\n\rExamplesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"\x9b\x03\n\rExampleOption\x12H\n\x08example\
    s\x18\x01\x20\x03(\x0b2,.kymera_mappings.ExampleOption.ExamplesEntryR\
    \x08examples\x12\x14\n\x05notes\x18\x02\x20\x03(\tR\x05notes\x12?\n\x0cb\
    ase_mapping\x18\x03\x20\x01(\x0b2\x1c.kymera_mappings.BaseMappingR\x0bba\
    seMapping\x12#\n\rtype_examples\x18\x04\x20\x03(\tR\x0ctypeExamples\x12%\
    \n\x0eerror_examples\x18\x05\x20\x03(\tR\rerrorExamples\x12!\n\x0cffi_ex\
    amples\x18\x06\x20\x03(\tR\x0bffiExamples\x12A\n\rtest_examples\x18\x07\
    \x20\x03(\x0b2\x1c.kymera_mappings.TestExampleR\x0ctestExamples\x1a7\n\r\
    ExamplesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value\"\xb6\x14\n\x0bAIASystemV2\x1a\xc1\x0c\
    \n\x0cCoreAIEngine\x1a\xdf\x04\n\x11ModelArchitecture\x12\x1f\n\x0bengin\
    e_type\x18\x01\x20\x01(\tR\nengineType\x12#\n\rmodel_version\x18\x02\x20\
    \x01(\rR\x0cmodelVersion\x12+\n\x11architecture_name\x18\x03\x20\x01(\tR\
    \x10architectureName\x12k\n\nparameters\x18\x04\x20\x03(\x0b2K.kymera_ma\
    ppings.AIASystemV2.CoreAIEngine.ModelArchitecture.ParametersEntryR\npara\
    meters\x12\"\n\x0ccapabilities\x18\x05\x20\x03(\tR\x0ccapabilities\x12#\
    \n\rquantum_ready\x18\x06\x20\x01(\x08R\x0cquantumReady\x12)\n\x10extens\
    ion_points\x18\x07\x20\x03(\tR\x0fextensionPoints\x12u\n\x0ecustom_confi\
    gs\x18\x08\x20\x03(\x0b2N.kymera_mappings.AIASystemV2.CoreAIEngine.Model\
    Architecture.CustomConfigsEntryR\rcustomConfigs\x1a=\n\x0fParametersEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x02R\x05value:\x028\x01\x1a@\n\x12CustomConfigsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a\xad\x03\n\x12DistributedCompute\x12/\n\x13distr\
    ibuted_enabled\x18\x01\x20\x01(\x08R\x12distributedEnabled\x12#\n\rcompu\
    te_nodes\x18\x02\x20\x03(\tR\x0ccomputeNodes\x12\x7f\n\x11node_capabilit\
    ies\x18\x03\x20\x03(\x0b2R.kymera_mappings.AIASystemV2.CoreAIEngine.Dist\
    ributedCompute.NodeCapabilitiesEntryR\x10nodeCapabilities\x12$\n\x0emin_\
    node_count\x18\x04\x20\x01(\rR\x0cminNodeCount\x12$\n\x0emax_node_count\
    \x18\x05\x20\x01(\rR\x0cmaxNodeCount\x12/\n\x13fallback_strategies\x18\
    \x06\x20\x03(\tR\x12fallbackStrategies\x1aC\n\x15NodeCapabilitiesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\x9e\x04\n\x12OptimizationEngine\x12d\
    \n\x05level\x18\x01\x20\x01(\x0e2N.kymera_mappings.AIASystemV2.CoreAIEng\
    ine.OptimizationEngine.OptimizationLevelR\x05level\x121\n\x14optimizatio\
    n_targets\x18\x02\x20\x03(\tR\x13optimizationTargets\x12\x85\x01\n\x13pe\
    rformance_metrics\x18\x03\x20\x03(\x0b2T.kymera_mappings.AIASystemV2.Cor\
    eAIEngine.OptimizationEngine.PerformanceMetricsEntryR\x12performanceMetr\
    ics\x12\x1f\n\x0bauto_tuning\x18\x04\x20\x01(\x08R\nautoTuning\x12)\n\
    \x10constraint_rules\x18\x05\x20\x03(\tR\x0fconstraintRules\x1aE\n\x17Pe\
    rformanceMetricsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01\"T\n\x11Optimiz\
    ationLevel\x12\t\n\x05BASIC\x10\0\x12\x10\n\x0cINTERMEDIATE\x10\x01\x12\
    \x0c\n\x08ADVANCED\x10\x02\x12\x14\n\x10QUANTUM_ENHANCED\x10\x03\x1a\xe2\
    \x07\n\x12AdvancedGeneration\x1a\xd0\x04\n\rCodeSynthesis\x12-\n\x12synt\
    hesis_patterns\x18\x01\x20\x03(\tR\x11synthesisPatterns\x12\x92\x01\n\
    \x17pattern_implementations\x18\x02\x20\x03(\x0b2Y.kymera_mappings.AIASy\
    stemV2.AdvancedGeneration.CodeSynthesis.PatternImplementationsEntryR\x16\
    patternImplementations\x125\n\x16incremental_generation\x18\x03\x20\x01(\
    \x08R\x15incrementalGeneration\x12)\n\x10validation_rules\x18\x04\x20\
    \x03(\tR\x0fvalidationRules\x12\x86\x01\n\x13generation_contexts\x18\x05\
    \x20\x03(\x0b2U.kymera_mappings.AIASystemV2.AdvancedGeneration.CodeSynth\
    esis.GenerationContextsEntryR\x12generationContexts\x1aI\n\x1bPatternImp\
    lementationsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aE\n\x17GenerationCon\
    textsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xf8\x02\n\x11SecurityAwaren\
    ess\x12+\n\x11security_patterns\x18\x01\x20\x03(\tR\x10securityPatterns\
    \x12\x8d\x01\n\x14vulnerability_checks\x18\x02\x20\x03(\x0b2Z.kymera_map\
    pings.AIASystemV2.AdvancedGeneration.SecurityAwareness.VulnerabilityChec\
    ksEntryR\x13vulnerabilityChecks\x12)\n\x10runtime_scanning\x18\x03\x20\
    \x01(\x08R\x0fruntimeScanning\x123\n\x15mitigation_strategies\x18\x04\
    \x20\x03(\tR\x14mitigationStrategies\x1aF\n\x18VulnerabilityChecksEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"\xf0\x0f\n\x15QuantumEnhancedSystem\x1a\
    \x9b\t\n\x10QuantumProcessor\x1a\xbf\x04\n\x0cArchitecture\x12%\n\x0epro\
    cessor_type\x18\x01\x20\x01(\tR\rprocessorType\x12\x1f\n\x0bqubit_count\
    \x18\x02\x20\x01(\rR\nqubitCount\x12*\n\x11coherence_time_us\x18\x03\x20\
    \x01(\x01R\x0fcoherenceTimeUs\x12u\n\x0berror_rates\x18\x04\x20\x03(\x0b\
    2T.kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.E\
    rrorRatesEntryR\nerrorRates\x12)\n\x10error_correction\x18\x05\x20\x01(\
    \x08R\x0ferrorCorrection\x12-\n\x12quantum_operations\x18\x06\x20\x03(\t\
    R\x11quantumOperations\x12n\n\x08topology\x18\x07\x20\x03(\x0b2R.kymera_\
    mappings.QuantumEnhancedSystem.QuantumProcessor.Architecture.TopologyEnt\
    ryR\x08topology\x1a=\n\x0fErrorRatesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\
    \x01\x1a;\n\rTopologyEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value:\x028\x01\x1a\xc4\x04\n\
    \x0fQuantumCompiler\x12/\n\x13optimization_passes\x18\x01\x20\x03(\tR\
    \x12optimizationPasses\x12\x8a\x01\n\x11compilation_rules\x18\x02\x20\
    \x03(\x0b2].kymera_mappings.QuantumEnhancedSystem.QuantumProcessor.Quant\
    umCompiler.CompilationRulesEntryR\x10compilationRules\x121\n\x14circuit_\
    optimization\x18\x03\x20\x01(\x08R\x13circuitOptimization\x12-\n\x12mapp\
    ing_strategies\x18\x04\x20\x03(\tR\x11mappingStrategies\x12\x87\x01\n\
    \x10error_mitigation\x18\x05\x20\x03(\x0b2\\.kymera_mappings.QuantumEnha\
    ncedSystem.QuantumProcessor.QuantumCompiler.ErrorMitigationEntryR\x0ferr\
    orMitigation\x1aC\n\x15CompilationRulesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1aB\n\x14ErrorMitigationEntry\x12\x10\n\x03key\x18\x01\x20\x01(\t\
    R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \xb8\x06\n\x10HybridAlgorithms\x1a\x94\x03\n\x19QuantumClassicalInterfac\
    e\x123\n\x15classical_subroutines\x18\x01\x20\x03(\tR\x14classicalSubrou\
    tines\x12\x9a\x01\n\x13quantum_subroutines\x18\x02\x20\x03(\x0b2i.kymera\
    _mappings.QuantumEnhancedSystem.HybridAlgorithms.QuantumClassicalInterfa\
    ce.QuantumSubroutinesEntryR\x12quantumSubroutines\x12-\n\x12adaptive_exe\
    cution\x18\x03\x20\x01(\x08R\x11adaptiveExecution\x12/\n\x13feedback_mec\
    hanisms\x18\x04\x20\x03(\tR\x12feedbackMechanisms\x1aE\n\x17QuantumSubro\
    utinesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x8c\x03\n\x16OptimizationS\
    trategies\x125\n\x16variational_algorithms\x18\x01\x20\x03(\tR\x15variat\
    ionalAlgorithms\x12\x97\x01\n\x13optimization_params\x18\x02\x20\x03(\
    \x0b2f.kymera_mappings.QuantumEnhancedSystem.HybridAlgorithms.Optimizati\
    onStrategies.OptimizationParamsEntryR\x12optimizationParams\x12'\n\x0fno\
    ise_resilient\x18\x03\x20\x01(\x08R\x0enoiseResilient\x121\n\x14converge\
    nce_criteria\x18\x04\x20\x03(\tR\x13convergenceCriteria\x1aE\n\x17Optimi\
    zationParamsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xcf\x12\n\x18NeuralAr\
    chitectureSystem\x1a\xc1\x0c\n\x10AdvancedNetworks\x1a\xc1\x04\n\x10Laye\
    rDefinitions\x12\x1f\n\x0blayer_types\x18\x01\x20\x03(\tR\nlayerTypes\
    \x12\x82\x01\n\rlayer_configs\x18\x02\x20\x03(\x0b2].kymera_mappings.Neu\
    ralArchitectureSystem.AdvancedNetworks.LayerDefinitions.LayerConfigsEntr\
    yR\x0clayerConfigs\x121\n\x14dynamic_architecture\x18\x03\x20\x01(\x08R\
    \x13dynamicArchitecture\x121\n\x14activation_functions\x18\x04\x20\x03(\
    \tR\x13activationFunctions\x12\x97\x01\n\x14initialization_rules\x18\x05\
    \x20\x03(\x0b2d.kymera_mappings.NeuralArchitectureSystem.AdvancedNetwork\
    s.LayerDefinitions.InitializationRulesEntryR\x13initializationRules\x1a?\
    \n\x11LayerConfigsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aF\n\x18Initial\
    izationRulesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xce\x04\n\x0eTraini\
    ngSystem\x12/\n\x13training_algorithms\x18\x01\x20\x03(\tR\x12trainingAl\
    gorithms\x12\x92\x01\n\x13learning_parameters\x18\x02\x20\x03(\x0b2a.kym\
    era_mappings.NeuralArchitectureSystem.AdvancedNetworks.TrainingSystem.Le\
    arningParametersEntryR\x12learningParameters\x121\n\x14distributed_train\
    ing\x18\x03\x20\x01(\x08R\x13distributedTraining\x121\n\x14optimization_\
    methods\x18\x04\x20\x03(\tR\x13optimizationMethods\x12\x85\x01\n\x0eregu\
    larization\x18\x05\x20\x03(\x0b2].kymera_mappings.NeuralArchitectureSyst\
    em.AdvancedNetworks.TrainingSystem.RegularizationEntryR\x0eregularizatio\
    n\x1aE\n\x17LearningParametersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01\x1aA\
    \n\x13RegularizationEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x97\x03\n\
    \x0cMetaLearning\x12+\n\x11meta_optimization\x18\x01\x20\x01(\x08R\x10me\
    taOptimization\x123\n\x15adaptation_strategies\x18\x02\x20\x03(\tR\x14ad\
    aptationStrategies\x12\x8a\x01\n\x11transfer_learning\x18\x03\x20\x03(\
    \x0b2].kymera_mappings.NeuralArchitectureSystem.AdvancedNetworks.MetaLea\
    rning.TransferLearningEntryR\x10transferLearning\x12*\n\x11few_shot_lear\
    ning\x18\x04\x20\x01(\x08R\x0ffewShotLearning\x12'\n\x0fmeta_parameters\
    \x18\x05\x20\x03(\tR\x0emetaParameters\x1aC\n\x15TransferLearningEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\xee\x05\n\x06AutoML\x1a\xe3\x02\n\
    \x12ArchitectureSearch\x12!\n\x0csearch_space\x18\x01\x20\x03(\tR\x0bsea\
    rchSpace\x12\x86\x01\n\x11search_strategies\x18\x02\x20\x03(\x0b2Y.kymer\
    a_mappings.NeuralArchitectureSystem.AutoML.ArchitectureSearch.SearchStra\
    tegiesEntryR\x10searchStrategies\x12-\n\x12progressive_search\x18\x03\
    \x20\x01(\x08R\x11progressiveSearch\x12-\n\x12evaluation_metrics\x18\x04\
    \x20\x03(\tR\x11evaluationMetrics\x1aC\n\x15SearchStrategiesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\xfd\x02\n\x1aHyperparameterOptimization\
    \x12+\n\x11tuning_algorithms\x18\x01\x20\x03(\tR\x10tuningAlgorithms\x12\
    \x8b\x01\n\x10parameter_ranges\x18\x02\x20\x03(\x0b2`.kymera_mappings.Ne\
    uralArchitectureSystem.AutoML.HyperparameterOptimization.ParameterRanges\
    EntryR\x0fparameterRanges\x123\n\x15bayesian_optimization\x18\x03\x20\
    \x01(\x08R\x14bayesianOptimization\x12+\n\x11stopping_criteria\x18\x04\
    \x20\x03(\tR\x10stoppingCriteria\x1aB\n\x14ParameterRangesEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"\xa6\x12\n\x1aHardwareAccelerationSystem\x1a\x9a\
    \x06\n\x0fGPUAcceleration\x1a\xa2\x03\n\x0fCUDAIntegration\x12!\n\x0ccud\
    a_version\x18\x01\x20\x01(\rR\x0bcudaVersion\x12+\n\x11cuda_capabilities\
    \x18\x02\x20\x03(\tR\x10cudaCapabilities\x12\x97\x01\n\x14kernel_optimiz\
    ations\x18\x03\x20\x03(\x0b2d.kymera_mappings.HardwareAccelerationSystem\
    .GPUAcceleration.CUDAIntegration.KernelOptimizationsEntryR\x13kernelOpti\
    mizations\x120\n\x14tensor_cores_enabled\x18\x04\x20\x01(\x08R\x12tensor\
    CoresEnabled\x12+\n\x11memory_strategies\x18\x05\x20\x03(\tR\x10memorySt\
    rategies\x1aF\n\x18KernelOptimizationsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\x1a\xe1\x02\n\x0bROCmSupport\x12!\n\x0crocm_version\x18\x01\x20\x01\
    (\rR\x0brocmVersion\x12!\n\x0chip_features\x18\x02\x20\x03(\tR\x0bhipFea\
    tures\x12\x8d\x01\n\x12optimization_flags\x18\x03\x20\x03(\x0b2^.kymera_\
    mappings.HardwareAccelerationSystem.GPUAcceleration.ROCmSupport.Optimiza\
    tionFlagsEntryR\x11optimizationFlags\x126\n\x17infinity_fabric_enabled\
    \x18\x04\x20\x01(\x08R\x15infinityFabricEnabled\x1aD\n\x16OptimizationFl\
    agsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x80\x06\n\x10FPGAAcceleratio\
    n\x1a\xe9\x02\n\rHDLGeneration\x12#\n\rhdl_templates\x18\x01\x20\x03(\tR\
    \x0chdlTemplates\x12\x87\x01\n\x0fsynthesis_rules\x18\x02\x20\x03(\x0b2^\
    .kymera_mappings.HardwareAccelerationSystem.FPGAAcceleration.HDLGenerati\
    on.SynthesisRulesEntryR\x0esynthesisRules\x127\n\x17partial_reconfigurat\
    ion\x18\x03\x20\x01(\x08R\x16partialReconfiguration\x12-\n\x12timing_con\
    straints\x18\x04\x20\x03(\tR\x11timingConstraints\x1aA\n\x13SynthesisRul\
    esEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xff\x02\n\x13BitstreamManage\
    ment\x12+\n\x11bitstream_formats\x18\x01\x20\x03(\tR\x10bitstreamFormats\
    \x12\x96\x01\n\x12loading_strategies\x18\x02\x20\x03(\x0b2g.kymera_mappi\
    ngs.HardwareAccelerationSystem.FPGAAcceleration.BitstreamManagement.Load\
    ingStrategiesEntryR\x11loadingStrategies\x121\n\x14verification_enabled\
    \x18\x03\x20\x01(\x08R\x13verificationEnabled\x12)\n\x10fallback_configs\
    \x18\x04\x20\x03(\tR\x0ffallbackConfigs\x1aD\n\x16LoadingStrategiesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\xe7\x05\n\x10ASICOptimization\x1a\
    \xef\x02\n\x11CircuitGeneration\x12+\n\x11circuit_templates\x18\x01\x20\
    \x03(\tR\x10circuitTemplates\x12\x94\x01\n\x12optimization_rules\x18\x02\
    \x20\x03(\x0b2e.kymera_mappings.HardwareAccelerationSystem.ASICOptimizat\
    ion.CircuitGeneration.OptimizationRulesEntryR\x11optimizationRules\x12-\
    \n\x12power_optimization\x18\x03\x20\x01(\x08R\x11powerOptimization\x12!\
    \n\x0ctiming_rules\x18\x04\x20\x03(\tR\x0btimingRules\x1aD\n\x16Optimiza\
    tionRulesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05\
    value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xe0\x02\n\x0ePhysicalDe\
    sign\x121\n\x14placement_strategies\x18\x01\x20\x03(\tR\x13placementStra\
    tegies\x12\x82\x01\n\rrouting_rules\x18\x02\x20\x03(\x0b2].kymera_mappin\
    gs.HardwareAccelerationSystem.ASICOptimization.PhysicalDesign.RoutingRul\
    esEntryR\x0croutingRules\x120\n\x14clock_tree_synthesis\x18\x03\x20\x01(\
    \x08R\x12clockTreeSynthesis\x12#\n\rpower_domains\x18\x04\x20\x03(\tR\
    \x0cpowerDomains\x1a?\n\x11RoutingRulesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\xe3\x0c\n\x19AdaptiveCompilationSystem\x1a\xa4\x06\n\x14Compiler\
    Optimization\x1a\xf2\x02\n\x12OptimizationPasses\x12#\n\rpass_sequence\
    \x18\x01\x20\x03(\tR\x0cpassSequence\x12\x95\x01\n\x11pass_dependencies\
    \x18\x02\x20\x03(\x0b2h.kymera_mappings.AdaptiveCompilationSystem.Compil\
    erOptimization.OptimizationPasses.PassDependenciesEntryR\x10passDependen\
    cies\x12/\n\x13adaptive_scheduling\x18\x03\x20\x01(\x08R\x12adaptiveSche\
    duling\x12)\n\x10analysis_metrics\x18\x04\x20\x03(\tR\x0fanalysisMetrics\
    \x1aC\n\x15PassDependenciesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \x96\x03\n\x0eCodeGeneration\x121\n\x14target_architectures\x18\x01\x20\
    \x03(\tR\x13targetArchitectures\x12\x9d\x01\n\x15instruction_selection\
    \x18\x02\x20\x03(\x0b2h.kymera_mappings.AdaptiveCompilationSystem.Compil\
    erOptimization.CodeGeneration.InstructionSelectionEntryR\x14instructionS\
    election\x123\n\x15vectorization_enabled\x18\x03\x20\x01(\x08R\x14vector\
    izationEnabled\x123\n\x15scheduling_strategies\x18\x04\x20\x03(\tR\x14sc\
    hedulingStrategies\x1aG\n\x19InstructionSelectionEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a\x9e\x06\n\x13RuntimeOptimization\x1a\xfc\x02\n\x0eJITC\
    ompilation\x12,\n\x12hot_spot_detection\x18\x01\x20\x03(\tR\x10hotSpotDe\
    tection\x12\x99\x01\n\x14compilation_triggers\x18\x02\x20\x03(\x0b2f.kym\
    era_mappings.AdaptiveCompilationSystem.RuntimeOptimization.JITCompilatio\
    n.CompilationTriggersEntryR\x13compilationTriggers\x12%\n\x0eprofile_gui\
    ded\x18\x03\x20\x01(\x08R\rprofileGuided\x121\n\x14deoptimization_rules\
    \x18\x04\x20\x03(\tR\x13deoptimizationRules\x1aF\n\x18CompilationTrigger\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x87\x03\n\x14SpeculativeExec\
    ution\x121\n\x14speculation_patterns\x18\x01\x20\x03(\tR\x13speculationP\
    atterns\x12\x9c\x01\n\x13rollback_strategies\x18\x02\x20\x03(\x0b2k.kyme\
    ra_mappings.AdaptiveCompilationSystem.RuntimeOptimization.SpeculativeExe\
    cution.RollbackStrategiesEntryR\x12rollbackStrategies\x12+\n\x11branch_p\
    rediction\x18\x03\x20\x01(\x08R\x10branchPrediction\x12)\n\x10guard_cond\
    itions\x18\x04\x20\x03(\tR\x0fguardConditions\x1aE\n\x17RollbackStrategi\
    esEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x82\x0c\n\x1bSecurityEnhanceme\
    ntSystemV2\x1a\xe4\x05\n\x12FormalVerification\x1a\xf4\x02\n\x0fProofGen\
    eration\x12)\n\x10proof_strategies\x18\x01\x20\x03(\tR\x0fproofStrategie\
    s\x12\x95\x01\n\x12verification_rules\x18\x02\x20\x03(\x0b2f.kymera_mapp\
    ings.SecurityEnhancementSystemV2.FormalVerification.ProofGeneration.Veri\
    ficationRulesEntryR\x11verificationRules\x12+\n\x11automated_proving\x18\
    \x03\x20\x01(\x08R\x10automatedProving\x12+\n\x11theorem_templates\x18\
    \x04\x20\x03(\tR\x10theoremTemplates\x1aD\n\x16VerificationRulesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\xd6\x02\n\rModelChecking\x12\x1f\n\
    \x0bstate_space\x18\x01\x20\x03(\tR\nstateSpace\x12\x87\x01\n\x0etempora\
    l_logic\x18\x02\x20\x03(\x0b2`.kymera_mappings.SecurityEnhancementSystem\
    V2.FormalVerification.ModelChecking.TemporalLogicEntryR\rtemporalLogic\
    \x12+\n\x11liveness_checking\x18\x03\x20\x01(\x08R\x10livenessChecking\
    \x12+\n\x11safety_properties\x18\x04\x20\x03(\tR\x10safetyProperties\x1a\
    @\n\x12TemporalLogicEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xfb\x05\n\
    \x12CryptographicSuite\x1a\xeb\x02\n\x11QuantumResistance\x126\n\x17post\
    _quantum_algorithms\x18\x01\x20\x03(\tR\x15postQuantumAlgorithms\x12\x8b\
    \x01\n\x0ekey_generation\x18\x02\x20\x03(\x0b2d.kymera_mappings.Security\
    EnhancementSystemV2.CryptographicSuite.QuantumResistance.KeyGenerationEn\
    tryR\rkeyGeneration\x12%\n\x0ehybrid_schemes\x18\x03\x20\x01(\x08R\rhybr\
    idSchemes\x12'\n\x0fsecurity_levels\x18\x04\x20\x03(\tR\x0esecurityLevel\
    s\x1a@\n\x12KeyGenerationEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xf6\x02\
    \n\rZeroKnowledge\x12#\n\rproof_systems\x18\x01\x20\x03(\tR\x0cproofSyst\
    ems\x12\x99\x01\n\x14protocol_definitions\x18\x02\x20\x03(\x0b2f.kymera_\
    mappings.SecurityEnhancementSystemV2.CryptographicSuite.ZeroKnowledge.Pr\
    otocolDefinitionsEntryR\x13protocolDefinitions\x12-\n\x12interactive_pro\
    ofs\x18\x03\x20\x01(\x08R\x11interactiveProofs\x12-\n\x12witness_generat\
    ion\x18\x04\x20\x03(\tR\x11witnessGeneration\x1aF\n\x18ProtocolDefinitio\
    nsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xe6\x0b\n\x17MetaProgrammingSy\
    stemV2\x1a\xd9\x05\n\x0eCodeGeneration\x1a\xe9\x02\n\x0eTemplateEngine\
    \x12+\n\x11template_patterns\x18\x01\x20\x03(\tR\x10templatePatterns\x12\
    \x83\x01\n\x0fexpansion_rules\x18\x02\x20\x03(\x0b2Z.kymera_mappings.Met\
    aProgrammingSystemV2.CodeGeneration.TemplateEngine.ExpansionRulesEntryR\
    \x0eexpansionRules\x12.\n\x13type_safe_templates\x18\x03\x20\x01(\x08R\
    \x11typeSafeTemplates\x121\n\x14specialization_rules\x18\x04\x20\x03(\tR\
    \x13specializationRules\x1aA\n\x13ExpansionRulesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a\xda\x02\n\x0bMacroSystem\x12+\n\x11macro_definitions\
    \x18\x01\x20\x03(\tR\x10macroDefinitions\x12\x89\x01\n\x12expansion_poli\
    cies\x18\x02\x20\x03(\x0b2Z.kymera_mappings.MetaProgrammingSystemV2.Code\
    Generation.MacroSystem.ExpansionPoliciesEntryR\x11expansionPolicies\x12)\
    \n\x10hygiene_checking\x18\x03\x20\x01(\x08R\x0fhygieneChecking\x12!\n\
    \x0csyntax_rules\x18\x04\x20\x03(\tR\x0bsyntaxRules\x1aD\n\x16ExpansionP\
    oliciesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xee\x05\n\x10ReflectionSy\
    stem\x1a\xe4\x02\n\x11TypeIntrospection\x12#\n\rtype_patterns\x18\x01\
    \x20\x03(\tR\x0ctypePatterns\x12\x8b\x01\n\x10reflection_rules\x18\x02\
    \x20\x03(\x0b2`.kymera_mappings.MetaProgrammingSystemV2.ReflectionSystem\
    .TypeIntrospection.ReflectionRulesEntryR\x0freflectionRules\x12-\n\x12ru\
    ntime_reflection\x18\x03\x20\x01(\x08R\x11runtimeReflection\x12)\n\x10ty\
    pe_constraints\x18\x04\x20\x03(\tR\x0ftypeConstraints\x1aB\n\x14Reflecti\
    onRulesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05va\
    lue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xf2\x02\n\x12MetaObjectPr\
    otocol\x12)\n\x10protocol_methods\x18\x01\x20\x03(\tR\x0fprotocolMethods\
    \x12\x92\x01\n\x12intercession_rules\x18\x02\x20\x03(\x0b2c.kymera_mappi\
    ngs.MetaProgrammingSystemV2.ReflectionSystem.MetaObjectProtocol.Interces\
    sionRulesEntryR\x11intercessionRules\x12)\n\x10dynamic_dispatch\x18\x03\
    \x20\x01(\x08R\x0fdynamicDispatch\x12+\n\x11method_generation\x18\x04\
    \x20\x03(\tR\x10methodGeneration\x1aD\n\x16IntercessionRulesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\"\xb2\x0c\n\x1aIntelligentDebuggingSystem\
    \x1a\xe7\x05\n\x11AutomaticDebugger\x1a\xde\x02\n\x0cBugDetection\x12)\n\
    \x10pattern_matching\x18\x01\x20\x03(\tR\x0fpatternMatching\x12\x87\x01\
    \n\x0fheuristic_rules\x18\x02\x20\x03(\x0b2^.kymera_mappings.Intelligent\
    DebuggingSystem.AutomaticDebugger.BugDetection.HeuristicRulesEntryR\x0eh\
    euristicRules\x12-\n\x12runtime_monitoring\x18\x03\x20\x01(\x08R\x11runt\
    imeMonitoring\x12'\n\x0ffix_suggestions\x18\x04\x20\x03(\tR\x0efixSugges\
    tions\x1aA\n\x13HeuristicRulesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \xf0\x02\n\x11RootCauseAnalysis\x12/\n\x13analysis_strategies\x18\x01\
    \x20\x03(\tR\x12analysisStrategies\x12\x8f\x01\n\x10causal_inference\x18\
    \x02\x20\x03(\x0b2d.kymera_mappings.IntelligentDebuggingSystem.Automatic\
    Debugger.RootCauseAnalysis.CausalInferenceEntryR\x0fcausalInference\x12-\
    \n\x12symbolic_execution\x18\x03\x20\x01(\x08R\x11symbolicExecution\x12%\
    \n\x0etrace_analysis\x18\x04\x20\x03(\tR\rtraceAnalysis\x1aB\n\x14Causal\
    InferenceEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05\
    value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xa9\x06\n\x12DebuggingA\
    ssistant\x1a\xfd\x02\n\x11CodeUnderstanding\x12+\n\x11semantic_analysis\
    \x18\x01\x20\x03(\tR\x10semanticAnalysis\x12\x93\x01\n\x11context_infere\
    nce\x18\x02\x20\x03(\x0b2f.kymera_mappings.IntelligentDebuggingSystem.De\
    buggingAssistant.CodeUnderstanding.ContextInferenceEntryR\x10contextInfe\
    rence\x12)\n\x10natural_language\x18\x03\x20\x01(\x08R\x0fnaturalLanguag\
    e\x125\n\x16explanation_generation\x18\x04\x20\x03(\tR\x15explanationGen\
    eration\x1aC\n\x15ContextInferenceEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\
    \x1a\x92\x03\n\x14InteractiveDebugging\x12+\n\x11interaction_modes\x18\
    \x01\x20\x03(\tR\x10interactionModes\x12\x9c\x01\n\x13visualization_rule\
    s\x18\x02\x20\x03(\x0b2k.kymera_mappings.IntelligentDebuggingSystem.Debu\
    ggingAssistant.InteractiveDebugging.VisualizationRulesEntryR\x12visualiz\
    ationRules\x122\n\x15time_travel_debugging\x18\x03\x20\x01(\x08R\x13time\
    TravelDebugging\x123\n\x15breakpoint_strategies\x18\x04\x20\x03(\tR\x14b\
    reakpointStrategies\x1aE\n\x17VisualizationRulesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xc6\n\n\x19DynamicOptimizationSystem\x1a\xc2\x04\n\x19Pr\
    ofileGuidedOptimization\x12u\n\x08strategy\x18\x01\x20\x01(\x0e2Y.kymera\
    _mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.Optimizati\
    onStrategyR\x08strategy\x12!\n\x0cprofile_data\x18\x02\x20\x03(\tR\x0bpr\
    ofileData\x12\x90\x01\n\x14optimization_weights\x18\x03\x20\x03(\x0b2].k\
    ymera_mappings.DynamicOptimizationSystem.ProfileGuidedOptimization.Optim\
    izationWeightsEntryR\x13optimizationWeights\x12/\n\x13adaptive_threshold\
    s\x18\x04\x20\x01(\x08R\x12adaptiveThresholds\x12%\n\x0efeedback_loops\
    \x18\x05\x20\x03(\tR\rfeedbackLoops\x1aF\n\x18OptimizationWeightsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x02R\x05value:\x028\x01\"X\n\x14OptimizationStrategy\x12\x10\n\
    \x0cCONSERVATIVE\x10\0\x12\x0c\n\x08BALANCED\x10\x01\x12\x0e\n\nAGGRESSI\
    VE\x10\x02\x12\x10\n\x0cEXPERIMENTAL\x10\x03\x1a\xe3\x05\n\nAutoTuning\
    \x1a\xd5\x02\n\x13PerformanceModeling\x12/\n\x13performance_metrics\x18\
    \x01\x20\x03(\tR\x12performanceMetrics\x12z\n\x0bcost_models\x18\x02\x20\
    \x03(\x0b2Y.kymera_mappings.DynamicOptimizationSystem.AutoTuning.Perform\
    anceModeling.CostModelsEntryR\ncostModels\x12'\n\x0fonline_learning\x18\
    \x03\x20\x01(\x08R\x0eonlineLearning\x12)\n\x10adaptation_rules\x18\x04\
    \x20\x03(\tR\x0fadaptationRules\x1a=\n\x0fCostModelsEntry\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value:\x028\x01\x1a\xfc\x02\n\x12ConfigurationSpace\x12-\n\x12tunable_pa\
    rameters\x18\x01\x20\x03(\tR\x11tunableParameters\x12\x97\x01\n\x15param\
    eter_constraints\x18\x02\x20\x03(\x0b2b.kymera_mappings.DynamicOptimizat\
    ionSystem.AutoTuning.ConfigurationSpace.ParameterConstraintsEntryR\x14pa\
    rameterConstraints\x12'\n\x0fmulti_objective\x18\x03\x20\x01(\x08R\x0emu\
    ltiObjective\x12+\n\x11search_strategies\x18\x04\x20\x03(\tR\x10searchSt\
    rategies\x1aG\n\x19ParameterConstraintsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\xd5\x0b\n\x12VerificationSystem\x1a\xbc\x05\n\x0eStaticAnalysis\
    \x1a\xd9\x02\n\x0cTypeChecking\x12\x1d\n\ntype_rules\x18\x01\x20\x03(\tR\
    \ttypeRules\x12\x8b\x01\n\x14inference_algorithms\x18\x02\x20\x03(\x0b2X\
    .kymera_mappings.VerificationSystem.StaticAnalysis.TypeChecking.Inferenc\
    eAlgorithmsEntryR\x13inferenceAlgorithms\x12%\n\x0egradual_typing\x18\
    \x03\x20\x01(\x08R\rgradualTyping\x12-\n\x12constraint_solving\x18\x04\
    \x20\x03(\tR\x11constraintSolving\x1aF\n\x18InferenceAlgorithmsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\xcd\x02\n\x10DataFlowAnalysis\x12'\n\x0f\
    analysis_passes\x18\x01\x20\x03(\tR\x0eanalysisPasses\x12}\n\x0eflow_equ\
    ations\x18\x02\x20\x03(\x0b2V.kymera_mappings.VerificationSystem.StaticA\
    nalysis.DataFlowAnalysis.FlowEquationsEntryR\rflowEquations\x12(\n\x0fin\
    terprocedural\x18\x03\x20\x01(\x08R\x0finterprocedural\x12%\n\x0ealias_a\
    nalysis\x18\x04\x20\x03(\tR\raliasAnalysis\x1a@\n\x12FlowEquationsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\xff\x05\n\x0fDynamicAnalysis\x1a\x80\
    \x03\n\x13RuntimeVerification\x12+\n\x11monitoring_points\x18\x01\x20\
    \x03(\tR\x10monitoringPoints\x12\x9c\x01\n\x17verification_conditions\
    \x18\x02\x20\x03(\x0b2c.kymera_mappings.VerificationSystem.DynamicAnalys\
    is.RuntimeVerification.VerificationConditionsEntryR\x16verificationCondi\
    tions\x12'\n\x0fonline_checking\x18\x03\x20\x01(\x08R\x0eonlineChecking\
    \x12)\n\x10recovery_actions\x18\x04\x20\x03(\tR\x0frecoveryActions\x1aI\
    \n\x1bVerificationConditionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \xe8\x02\n\x13ConcurrencyAnalysis\x12#\n\rthread_safety\x18\x01\x20\x03(\
    \tR\x0cthreadSafety\x12\x8d\x01\n\x12deadlock_detection\x18\x02\x20\x03(\
    \x0b2^.kymera_mappings.VerificationSystem.DynamicAnalysis.ConcurrencyAna\
    lysis.DeadlockDetectionEntryR\x11deadlockDetection\x12%\n\x0erace_detect\
    ion\x18\x03\x20\x01(\x08R\rraceDetection\x12/\n\x13atomicity_violation\
    \x18\x04\x20\x03(\tR\x12atomicityViolation\x1aD\n\x16DeadlockDetectionEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\xb2\x02\n\x12NumericTypeMapping\
    \x12'\n\x0fsource_language\x18\x01\x20\x01(\tR\x0esourceLanguage\x12'\n\
    \x0ftarget_language\x18\x02\x20\x01(\tR\x0etargetLanguage\x12=\n\x0bsour\
    ce_type\x18\x03\x20\x01(\x0e2\x1c.kymera_mappings.NumericTypeR\nsourceTy\
    pe\x12=\n\x0btarget_type\x18\x04\x20\x01(\x0e2\x1c.kymera_mappings.Numer\
    icTypeR\ntargetType\x126\n\x17precision_loss_possible\x18\x05\x20\x01(\
    \x08R\x15precisionLossPossible\x12\x14\n\x05notes\x18\x06\x20\x01(\tR\
    \x05notes\"\x9d\x04\n\x11LanguageConstruct\x124\n\x04rust\x18\x01\x20\
    \x01(\x0e2\x1e.kymera_mappings.RustConstructH\0R\x04rust\x12:\n\x06pytho\
    n\x18\x02\x20\x01(\x0e2\x20.kymera_mappings.PythonConstructH\0R\x06pytho\
    n\x12>\n\njavascript\x18\x03\x20\x01(\x0e2\x1c.kymera_mappings.JSConstru\
    ctH\0R\njavascript\x12>\n\ntypescript\x18\x04\x20\x01(\x0e2\x1c.kymera_m\
    appings.TSConstructH\0R\ntypescript\x124\n\x04java\x18\x05\x20\x01(\x0e2\
    \x1e.kymera_mappings.JavaConstructH\0R\x04java\x12.\n\x02go\x18\x06\x20\
    \x01(\x0e2\x1c.kymera_mappings.GoConstructH\0R\x02go\x124\n\x04ruby\x18\
    \x07\x20\x01(\x0e2\x1e.kymera_mappings.RubyConstructH\0R\x04ruby\x121\n\
    \x03cpp\x18\x08\x20\x01(\x0e2\x1d.kymera_mappings.CPPConstructH\0R\x03cp\
    p\x12:\n\x06csharp\x18\t\x20\x01(\x0e2\x20.kymera_mappings.CSharpConstru\
    ctH\0R\x06csharpB\x0b\n\tconstruct\"\xb1\x02\n\x0fLanguageMapping\x12)\n\
    \x10source_construct\x18\x01\x20\x01(\tR\x0fsourceConstruct\x12)\n\x10ta\
    rget_construct\x18\x02\x20\x01(\tR\x0ftargetConstruct\x12%\n\x0edirect_m\
    apping\x18\x03\x20\x01(\x08R\rdirectMapping\x12\x18\n\x07caveats\x18\x04\
    \x20\x03(\tR\x07caveats\x12J\n\x08examples\x18\x05\x20\x03(\x0b2..kymera\
    _mappings.LanguageMapping.ExamplesEntryR\x08examples\x1a;\n\rExamplesEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\x8f\x06\n\x11ConstructMetadata\x12\
    \x18\n\x07version\x18\x01\x20\x01(\tR\x07version\x12!\n\x0clast_updated\
    \x18\x02\x20\x01(\tR\x0blastUpdated\x12\x1c\n\tchangelog\x18\x03\x20\x01\
    (\tR\tchangelog\x12Q\n\x12computational_cost\x18\x04\x20\x01(\x0e2\".kym\
    era_mappings.ComputationalCostR\x11computationalCost\x12N\n\x11memory_ma\
    nagement\x18\x05\x20\x01(\x0e2!.kymera_mappings.MemoryManagementR\x10mem\
    oryManagement\x12\x20\n\x0bdescription\x18\x06\x20\x01(\tR\x0bdescriptio\
    n\x12\x1a\n\x08examples\x18\x07\x20\x03(\tR\x08examples\x12e\n\x11langua\
    ge_mappings\x18\x08\x20\x03(\x0b28.kymera_mappings.ConstructMetadata.Lan\
    guageMappingsEntryR\x10languageMappings\x12N\n\x10numeric_mappings\x18\t\
    \x20\x03(\x0b2#.kymera_mappings.NumericTypeMappingR\x0fnumericMappings\
    \x12/\n\x13compatibility_notes\x18\n\x20\x03(\tR\x12compatibilityNotes\
    \x12R\n\nattributes\x18\x0b\x20\x03(\x0b22.kymera_mappings.ConstructMeta\
    data.AttributesEntryR\nattributes\x1aC\n\x15LanguageMappingsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a=\n\x0fAttributesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"\xe3\x04\n\x0bFileVersion\x12\x14\n\x05major\x18\x01\x20\
    \x01(\rR\x05major\x12\x14\n\x05minor\x18\x02\x20\x01(\rR\x05minor\x12\
    \x14\n\x05patch\x18\x03\x20\x01(\rR\x05patch\x12\x14\n\x05build\x18\x04\
    \x20\x01(\tR\x05build\x12%\n\x0eextended_notes\x18\x05\x20\x03(\tR\rexte\
    ndedNotes\x1a\x82\x01\n\x11VersionConstraint\x12\x1f\n\x0bmin_version\
    \x18\x01\x20\x01(\tR\nminVersion\x12\x1f\n\x0bmax_version\x18\x02\x20\
    \x01(\tR\nmaxVersion\x12+\n\x11excluded_versions\x18\x03\x20\x03(\tR\x10\
    excludedVersions\x1a\xcf\x02\n\x0fVersionMetadata\x12!\n\x0crelease_date\
    \x18\x01\x20\x01(\tR\x0breleaseDate\x12\x16\n\x06author\x18\x02\x20\x01(\
    \tR\x06author\x12\x18\n\x07changes\x18\x03\x20\x03(\tR\x07changes\x12)\n\
    \x10breaking_changes\x18\x04\x20\x03(\tR\x0fbreakingChanges\x12u\n\x13co\
    mpatibility_notes\x18\x05\x20\x03(\x0b2D.kymera_mappings.FileVersion.Ver\
    sionMetadata.CompatibilityNotesEntryR\x12compatibilityNotes\x1aE\n\x17Co\
    mpatibilityNotesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xcd\x04\n\x0cMa\
    ppingError\x12\x1d\n\nerror_code\x18\x01\x20\x01(\tR\terrorCode\x12\x20\
    \n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12'\n\x0fsuggested\
    _fixes\x18\x03\x20\x03(\tR\x0esuggestedFixes\x12G\n\x08severity\x18\x04\
    \x20\x01(\x0e2+.kymera_mappings.MappingError.ErrorSeverityR\x08severity\
    \x1a\x9f\x01\n\x0cErrorContext\x12'\n\x0fsource_language\x18\x01\x20\x01\
    (\tR\x0esourceLanguage\x12'\n\x0ftarget_language\x18\x02\x20\x01(\tR\x0e\
    targetLanguage\x12\x1c\n\tconstruct\x18\x03\x20\x01(\tR\tconstruct\x12\
    \x1f\n\x0bstack_trace\x18\x04\x20\x01(\tR\nstackTrace\x1a\x98\x01\n\x0fE\
    rrorResolution\x12\x14\n\x05steps\x18\x01\x20\x03(\tR\x05steps\x12-\n\
    \x12documentation_link\x18\x02\x20\x01(\tR\x11documentationLink\x12@\n\
    \x1crequires_manual_intervention\x18\x03\x20\x01(\x08R\x1arequiresManual\
    Intervention\"M\n\rErrorSeverity\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\
    \x07WARNING\x10\x01\x12\t\n\x05ERROR\x10\x02\x12\x0c\n\x08CRITICAL\x10\
    \x03\x12\t\n\x05FATAL\x10\x04\"\xae\x06\n\x14ConstructPerformance\x12E\n\
    \x0cruntime_cost\x18\x01\x20\x01(\x0e2\".kymera_mappings.ComputationalCo\
    stR\x0bruntimeCost\x12)\n\x10memory_footprint\x18\x02\x20\x01(\rR\x0fmem\
    oryFootprint\x12\x1c\n\tcacheable\x18\x03\x20\x01(\x08R\tcacheable\x1a\
    \xbf\x01\n\x12PerformanceMetrics\x124\n\x16average_execution_time\x18\
    \x01\x20\x01(\x01R\x14averageExecutionTime\x12\x1f\n\x0bmemory_peak\x18\
    \x02\x20\x01(\x04R\nmemoryPeak\x120\n\x14cpu_usage_percentage\x18\x03\
    \x20\x01(\rR\x12cpuUsagePercentage\x12\x20\n\x0bbottlenecks\x18\x04\x20\
    \x03(\tR\x0bbottlenecks\x1a\x8d\x02\n\x11OptimizationHints\x12\x20\n\x0b\
    suggestions\x18\x01\x20\x03(\tR\x0bsuggestions\x12q\n\x0ebest_practices\
    \x18\x02\x20\x03(\x0b2J.kymera_mappings.ConstructPerformance.Optimizatio\
    nHints.BestPracticesEntryR\rbestPractices\x12!\n\x0cknown_issues\x18\x03\
    \x20\x03(\tR\x0bknownIssues\x1a@\n\x12BestPracticesEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01\x1a\xb3\x01\n\x13ResourceUtilization\x12\x1f\n\x0bstack_u\
    sage\x18\x01\x20\x01(\rR\nstackUsage\x12'\n\x0fheap_allocation\x18\x02\
    \x20\x01(\rR\x0eheapAllocation\x12\x1f\n\x0bthread_safe\x18\x03\x20\x01(\
    \x08R\nthreadSafe\x121\n\x14resource_constraints\x18\x04\x20\x03(\tR\x13\
    resourceConstraints\"\xe4\x05\n\x0eValidationRule\x12\x17\n\x07rule_id\
    \x18\x01\x20\x01(\tR\x06ruleId\x12\x1c\n\tcondition\x18\x02\x20\x01(\tR\
    \tcondition\x12#\n\rerror_message\x18\x03\x20\x01(\tR\x0cerrorMessage\
    \x1a\xa8\x01\n\nConstraint\x12\x1d\n\nfield_name\x18\x01\x20\x01(\tR\tfi\
    eldName\x12)\n\x10validation_regex\x18\x02\x20\x01(\tR\x0fvalidationRege\
    x\x12%\n\x0eallowed_values\x18\x03\x20\x03(\tR\rallowedValues\x12)\n\x10\
    custom_validator\x18\x04\x20\x01(\tR\x0fcustomValidator\x1a\xb5\x02\n\
    \x11ValidationContext\x12$\n\rprerequisites\x18\x01\x20\x03(\tR\rprerequ\
    isites\x12\"\n\x0cdependencies\x18\x02\x20\x03(\tR\x0cdependencies\x12\
    \x89\x01\n\x18environment_requirements\x18\x03\x20\x03(\x0b2N.kymera_map\
    pings.ValidationRule.ValidationContext.EnvironmentRequirementsEntryR\x17\
    environmentRequirements\x1aJ\n\x1cEnvironmentRequirementsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a\x92\x01\n\x10ValidationResult\x12\x19\n\x08is_v\
    alid\x18\x01\x20\x01(\x08R\x07isValid\x12\x1e\n\nviolations\x18\x02\x20\
    \x03(\tR\nviolations\x12\x1a\n\x08warnings\x18\x03\x20\x03(\tR\x08warnin\
    gs\x12'\n\x0fvalidation_time\x18\x04\x20\x01(\tR\x0evalidationTime\"\xd4\
    \x05\n\x0fDeprecationInfo\x12#\n\ris_deprecated\x18\x01\x20\x01(\x08R\
    \x0cisDeprecated\x12#\n\rsince_version\x18\x02\x20\x01(\tR\x0csinceVersi\
    on\x12\x20\n\x0breplacement\x18\x03\x20\x01(\tR\x0breplacement\x12'\n\
    \x0fmigration_guide\x18\x04\x20\x01(\tR\x0emigrationGuide\x1a\xd3\x01\n\
    \x13DeprecationSchedule\x12+\n\x11announcement_date\x18\x01\x20\x01(\tR\
    \x10announcementDate\x122\n\x15soft_deprecation_date\x18\x02\x20\x01(\tR\
    \x13softDeprecationDate\x122\n\x15hard_deprecation_date\x18\x03\x20\x01(\
    \tR\x13hardDeprecationDate\x12'\n\x10end_of_life_date\x18\x04\x20\x01(\t\
    R\rendOfLifeDate\x1a\x8f\x01\n\rMigrationStep\x12\x1f\n\x0bstep_number\
    \x18\x01\x20\x01(\rR\nstepNumber\x12\x20\n\x0bdescription\x18\x02\x20\
    \x01(\tR\x0bdescription\x12!\n\x0ccode_example\x18\x03\x20\x01(\tR\x0bco\
    deExample\x12\x18\n\x07caveats\x18\x04\x20\x03(\tR\x07caveats\x1a\xc3\
    \x01\n\x12CompatibilityLayer\x125\n\x16provides_compatibility\x18\x01\
    \x20\x01(\x08R\x15providesCompatibility\x123\n\x15compatibility_version\
    \x18\x02\x20\x01(\tR\x14compatibilityVersion\x12\x20\n\x0blimitations\
    \x18\x03\x20\x03(\tR\x0blimitations\x12\x1f\n\x0bsunset_date\x18\x04\x20\
    \x01(\tR\nsunsetDate\"\xe1\x0e\n\x0eSafetyFeatures\x1a\xfb\x02\n\x15Back\
    wardCompatibility\x124\n\x16is_backward_compatible\x18\x01\x20\x01(\x08R\
    \x14isBackwardCompatible\x12)\n\x10breaking_changes\x18\x02\x20\x03(\tR\
    \x0fbreakingChanges\x12~\n\x13compatibility_fixes\x18\x03\x20\x03(\x0b2M\
    .kymera_mappings.SafetyFeatures.BackwardCompatibility.CompatibilityFixes\
    EntryR\x12compatibilityFixes\x12:\n\x19minimum_supported_version\x18\x04\
    \x20\x01(\tR\x17minimumSupportedVersion\x1aE\n\x17CompatibilityFixesEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\xf5\x03\n\x10Interoperability\x12/\n\
    \x13supported_platforms\x18\x01\x20\x03(\tR\x12supportedPlatforms\x12\
    \x83\x01\n\x17platform_specific_notes\x18\x02\x20\x03(\x0b2K.kymera_mapp\
    ings.SafetyFeatures.Interoperability.PlatformSpecificNotesEntryR\x15plat\
    formSpecificNotes\x12+\n\x11known_limitations\x18\x03\x20\x03(\tR\x10kno\
    wnLimitations\x1aH\n\x1aPlatformSpecificNotesEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a\xb2\x01\n\x14CrossLanguageSupport\x12'\n\x0fsource_languag\
    e\x18\x01\x20\x01(\tR\x0esourceLanguage\x12'\n\x0ftarget_language\x18\
    \x02\x20\x01(\tR\x0etargetLanguage\x12)\n\x10conversion_rules\x18\x03\
    \x20\x03(\tR\x0fconversionRules\x12\x1d\n\nedge_cases\x18\x04\x20\x03(\t\
    R\tedgeCases\x1a\x80\x04\n\x14SecurityImplications\x127\n\x17security_co\
    nsiderations\x18\x01\x20\x03(\tR\x16securityConsiderations\x12\x8f\x01\n\
    \x19vulnerability_mitigations\x18\x02\x20\x03(\x0b2R.kymera_mappings.Saf\
    etyFeatures.SecurityImplications.VulnerabilityMitigationsEntryR\x18vulne\
    rabilityMitigations\x126\n\x17security_best_practices\x18\x03\x20\x03(\t\
    R\x15securityBestPractices\x1aK\n\x1dVulnerabilityMitigationsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\x97\x01\n\rSecurityAudit\x12&\n\x0flast_\
    audit_date\x18\x01\x20\x01(\tR\rlastAuditDate\x12\x18\n\x07auditor\x18\
    \x02\x20\x01(\tR\x07auditor\x12\x1a\n\x08findings\x18\x03\x20\x03(\tR\
    \x08findings\x12(\n\x0frecommendations\x18\x04\x20\x03(\tR\x0frecommenda\
    tions\x1a\xd5\x03\n\x14TestingSpecification\x12%\n\x0erequired_tests\x18\
    \x01\x20\x03(\tR\rrequiredTests\x12\x90\x01\n\x1atest_coverage_requireme\
    nts\x18\x02\x20\x03(\x0b2R.kymera_mappings.SafetyFeatures.TestingSpecifi\
    cation.TestCoverageRequirementsEntryR\x18testCoverageRequirements\x12\
    \x1d\n\nedge_cases\x18\x03\x20\x03(\tR\tedgeCases\x1aK\n\x1dTestCoverage\
    RequirementsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x96\x01\n\x08TestCa\
    se\x12\x17\n\x07test_id\x18\x01\x20\x01(\tR\x06testId\x12\x20\n\x0bdescr\
    iption\x18\x02\x20\x01(\tR\x0bdescription\x12$\n\rprerequisites\x18\x03\
    \x20\x03(\tR\rprerequisites\x12)\n\x10expected_results\x18\x04\x20\x03(\
    \tR\x0fexpectedResults\"\xba\x07\n\x12PerformanceMetrics\x1a\x90\x02\n\
    \x0eRuntimeMetrics\x12*\n\x11execution_time_ns\x18\x01\x20\x01(\x04R\x0f\
    executionTimeNs\x12,\n\x12memory_usage_bytes\x18\x02\x20\x01(\x04R\x10me\
    moryUsageBytes\x12'\n\x0fcpu_utilization\x18\x03\x20\x01(\x01R\x0ecpuUti\
    lization\x12!\n\x0cthread_count\x18\x04\x20\x01(\rR\x0bthreadCount\x12*\
    \n\x11peak_memory_usage\x18\x05\x20\x01(\x04R\x0fpeakMemoryUsage\x12,\n\
    \x12average_latency_ms\x18\x06\x20\x01(\x01R\x10averageLatencyMs\x1a\xd6\
    \x02\n\rResourceUsage\x12\x1d\n\nstack_size\x18\x01\x20\x01(\x04R\tstack\
    Size\x12\x1b\n\theap_size\x18\x02\x20\x01(\x04R\x08heapSize\x12)\n\x10fi\
    le_descriptors\x18\x03\x20\x01(\rR\x0ffileDescriptors\x12/\n\x13network_\
    connections\x18\x04\x20\x01(\rR\x12networkConnections\x12k\n\x0ecustom_m\
    etrics\x18\x05\x20\x03(\x0b2D.kymera_mappings.PerformanceMetrics.Resourc\
    eUsage.CustomMetricsEntryR\rcustomMetrics\x1a@\n\x12CustomMetricsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x04R\x05value:\x028\x01\x1a\xb7\x02\n\x12PerformanceProfile\
    \x12\x1a\n\x08hotspots\x18\x01\x20\x03(\tR\x08hotspots\x121\n\x14optimiz\
    ation_targets\x18\x02\x20\x03(\tR\x13optimizationTargets\x12f\n\nbenchma\
    rks\x18\x03\x20\x03(\x0b2F.kymera_mappings.PerformanceMetrics.Performanc\
    eProfile.BenchmarksEntryR\nbenchmarks\x12+\n\x11performance_notes\x18\
    \x04\x20\x03(\tR\x10performanceNotes\x1a=\n\x0fBenchmarksEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \x01R\x05value:\x028\x01\"\xc8\x06\n\x10SecurityFeatures\x1a\x82\x03\n\r\
    SecurityCheck\x121\n\x14vulnerability_checks\x18\x01\x20\x03(\tR\x13vuln\
    erabilityChecks\x12r\n\x11security_policies\x18\x02\x20\x03(\x0b2E.kymer\
    a_mappings.SecurityFeatures.SecurityCheck.SecurityPoliciesEntryR\x10secu\
    rityPolicies\x12%\n\x0erequires_audit\x18\x03\x20\x01(\x08R\rrequiresAud\
    it\x127\n\x17compliance_requirements\x18\x04\x20\x03(\tR\x16complianceRe\
    quirements\x12%\n\x0esecurity_level\x18\x05\x20\x01(\tR\rsecurityLevel\
    \x1aC\n\x15SecurityPoliciesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \xcc\x01\n\rSecurityAudit\x12\x19\n\x08audit_id\x18\x01\x20\x01(\tR\x07a\
    uditId\x12\x18\n\x07auditor\x18\x02\x20\x01(\tR\x07auditor\x12\x1d\n\nau\
    dit_date\x18\x03\x20\x01(\tR\tauditDate\x12\x1a\n\x08findings\x18\x04\
    \x20\x03(\tR\x08findings\x12(\n\x0frecommendations\x18\x05\x20\x03(\tR\
    \x0frecommendations\x12!\n\x0cpassed_audit\x18\x06\x20\x01(\x08R\x0bpass\
    edAudit\x1a\xdf\x01\n\x0eSecurityPolicy\x12\x1b\n\tpolicy_id\x18\x01\x20\
    \x01(\tR\x08policyId\x12\x1f\n\x0bpolicy_name\x18\x02\x20\x01(\tR\npolic\
    yName\x12\x20\n\x0bdescription\x18\x03\x20\x01(\tR\x0bdescription\x12\"\
    \n\x0crequirements\x18\x04\x20\x03(\tR\x0crequirements\x12+\n\x11enforce\
    ment_rules\x18\x05\x20\x03(\tR\x10enforcementRules\x12\x1c\n\tmandatory\
    \x18\x06\x20\x01(\x08R\tmandatory\"\xbd\n\n\x0cTestingSuite\x1a\xc2\x02\
    \n\x0eTestDefinition\x12\x1b\n\ttest_name\x18\x01\x20\x01(\tR\x08testNam\
    e\x12\x1d\n\ntest_cases\x18\x02\x20\x03(\tR\ttestCases\x12l\n\x10expecte\
    d_results\x18\x03\x20\x03(\x0b2A.kymera_mappings.TestingSuite.TestDefini\
    tion.ExpectedResultsEntryR\x0fexpectedResults\x12$\n\rprerequisites\x18\
    \x04\x20\x03(\tR\rprerequisites\x12\x1c\n\tautomated\x18\x05\x20\x01(\
    \x08R\tautomated\x1aB\n\x14ExpectedResultsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1a\xe0\x02\n\x08TestCase\x12\x17\n\x07case_id\x18\x01\x20\x01(\tR\
    \x06caseId\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\
    \x12\x1d\n\ninput_data\x18\x03\x20\x03(\tR\tinputData\x12'\n\x0fexpected\
    _output\x18\x04\x20\x03(\tR\x0eexpectedOutput\x12c\n\x0ftest_parameters\
    \x18\x05\x20\x03(\x0b2:.kymera_mappings.TestingSuite.TestCase.TestParame\
    tersEntryR\x0etestParameters\x12)\n\x10validation_rules\x18\x06\x20\x03(\
    \tR\x0fvalidationRules\x1aA\n\x13TestParametersEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a\xa5\x02\n\x0bTestResults\x12\x17\n\x07test_id\x18\x01\
    \x20\x01(\tR\x06testId\x12\x16\n\x06passed\x18\x02\x20\x01(\x08R\x06pass\
    ed\x12\x1a\n\x08failures\x18\x03\x20\x03(\tR\x08failures\x12%\n\x0eexecu\
    tion_time\x18\x04\x20\x01(\tR\rexecutionTime\x12P\n\x07metrics\x18\x05\
    \x20\x03(\x0b26.kymera_mappings.TestingSuite.TestResults.MetricsEntryR\
    \x07metrics\x12\x14\n\x05notes\x18\x06\x20\x03(\tR\x05notes\x1a:\n\x0cMe\
    tricsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xdc\x02\n\x0cTestCoverage\
    \x12#\n\rline_coverage\x18\x01\x20\x01(\x01R\x0clineCoverage\x12'\n\x0fb\
    ranch_coverage\x18\x02\x20\x01(\x01R\x0ebranchCoverage\x12'\n\x0funcover\
    ed_areas\x18\x03\x20\x03(\tR\x0euncoveredAreas\x12j\n\x10coverage_metric\
    s\x18\x04\x20\x03(\x0b2?.kymera_mappings.TestingSuite.TestCoverage.Cover\
    ageMetricsEntryR\x0fcoverageMetrics\x12%\n\x0ecoverage_goals\x18\x05\x20\
    \x03(\tR\rcoverageGoals\x1aB\n\x14CoverageMetricsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05\
    value:\x028\x01\"\xd5\n\n\x13SecurityEnhancement\x1a\xa5\x04\n\x0fRuntim\
    eSecurity\x12-\n\x12sanitization_rules\x18\x01\x20\x03(\tR\x11sanitizati\
    onRules\x12}\n\x13security_boundaries\x18\x02\x20\x03(\x0b2L.kymera_mapp\
    ings.SecurityEnhancement.RuntimeSecurity.SecurityBoundariesEntryR\x12sec\
    urityBoundaries\x122\n\x15enforce_memory_safety\x18\x03\x20\x01(\x08R\
    \x13enforceMemorySafety\x12+\n\x11validation_checks\x18\x04\x20\x03(\tR\
    \x10validationChecks\x12w\n\x11security_policies\x18\x05\x20\x03(\x0b2J.\
    kymera_mappings.SecurityEnhancement.RuntimeSecurity.SecurityPoliciesEntr\
    yR\x10securityPolicies\x1aE\n\x17SecurityBoundariesEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01\x1aC\n\x15SecurityPoliciesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1a\xa4\x03\n\x15CrossLanguageSecurity\x12*\n\x11type_safety_rules\
    \x18\x01\x20\x03(\tR\x0ftypeSafetyRules\x12\x89\x01\n\x15conversion_safe\
    guards\x18\x02\x20\x03(\x0b2T.kymera_mappings.SecurityEnhancement.CrossL\
    anguageSecurity.ConversionSafeguardsEntryR\x14conversionSafeguards\x12/\
    \n\x13security_invariants\x18\x03\x20\x03(\tR\x12securityInvariants\x120\
    \n\x14strict_type_checking\x18\x04\x20\x01(\x08R\x12strictTypeChecking\
    \x12'\n\x0fboundary_checks\x18\x05\x20\x03(\tR\x0eboundaryChecks\x1aG\n\
    \x19ConversionSafeguardsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xee\x02\
    \n\x0fSecurityContext\x12+\n\x11execution_context\x18\x01\x20\x01(\tR\
    \x10executionContext\x12'\n\x0factive_policies\x18\x02\x20\x03(\tR\x0eac\
    tivePolicies\x12n\n\x0esecurity_state\x18\x03\x20\x03(\x0b2G.kymera_mapp\
    ings.SecurityEnhancement.SecurityContext.SecurityStateEntryR\rsecuritySt\
    ate\x12,\n\x12in_trusted_context\x18\x04\x20\x01(\x08R\x10inTrustedConte\
    xt\x12%\n\x0esecurity_stack\x18\x05\x20\x03(\tR\rsecurityStack\x1a@\n\
    \x12SecurityStateEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xf4\x0b\n\x17Pe\
    rformanceOptimization\x1a\x8b\x04\n\rCompilerHints\x12-\n\x12optimizatio\
    n_flags\x18\x01\x20\x03(\tR\x11optimizationFlags\x12j\n\x0cinline_hints\
    \x18\x02\x20\x03(\x0b2G.kymera_mappings.PerformanceOptimization.Compiler\
    Hints.InlineHintsEntryR\x0binlineHints\x12<\n\x1aallow_unsafe_optimizati\
    ons\x18\x03\x20\x01(\x08R\x18allowUnsafeOptimizations\x121\n\x14speciali\
    zation_hints\x18\x04\x20\x03(\tR\x13specializationHints\x12m\n\rcodegen_\
    hints\x18\x05\x20\x03(\x0b2H.kymera_mappings.PerformanceOptimization.Com\
    pilerHints.CodegenHintsEntryR\x0ccodegenHints\x1a>\n\x10InlineHintsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a?\n\x11CodegenHintsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a\x94\x03\n\x14RuntimeOptimizations\x12%\n\x0ecac\
    he_strategy\x18\x01\x20\x01(\rR\rcacheStrategy\x124\n\x16hot_path_optimi\
    zations\x18\x02\x20\x03(\tR\x14hotPathOptimizations\x12\x84\x01\n\x13mem\
    ory_layout_hints\x18\x03\x20\x03(\x0b2T.kymera_mappings.PerformanceOptim\
    ization.RuntimeOptimizations.MemoryLayoutHintsEntryR\x11memoryLayoutHint\
    s\x12\x1d\n\nenable_jit\x18\x04\x20\x01(\x08R\tenableJit\x123\n\x15optim\
    ization_barriers\x18\x05\x20\x03(\tR\x14optimizationBarriers\x1aD\n\x16M\
    emoryLayoutHintsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xb3\x04\n\x13\
    OptimizationProfile\x12%\n\x0ecritical_paths\x18\x01\x20\x03(\tR\rcritic\
    alPaths\x12\x85\x01\n\x13performance_targets\x18\x02\x20\x03(\x0b2T.kyme\
    ra_mappings.PerformanceOptimization.OptimizationProfile.PerformanceTarge\
    tsEntryR\x12performanceTargets\x129\n\x18optimization_constraints\x18\
    \x03\x20\x03(\tR\x17optimizationConstraints\x12%\n\x0eprofile_guided\x18\
    \x04\x20\x01(\x08R\rprofileGuided\x12\x7f\n\x11tuning_parameters\x18\x05\
    \x20\x03(\x0b2R.kymera_mappings.PerformanceOptimization.OptimizationProf\
    ile.TuningParametersEntryR\x10tuningParameters\x1aE\n\x17PerformanceTarg\
    etsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x01R\x05value:\x028\x01\x1aC\n\x15TuningParametersEntr\
    y\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\"\xc2\x0b\n\x12TestingEnhancement\x1a\
    \xd3\x03\n\x0fPropertyTesting\x12\x1e\n\ninvariants\x18\x01\x20\x03(\tR\
    \ninvariants\x12c\n\ngenerators\x18\x02\x20\x03(\x0b2C.kymera_mappings.T\
    estingEnhancement.PropertyTesting.GeneratorsEntryR\ngenerators\x12'\n\
    \x0ftest_iterations\x18\x03\x20\x01(\rR\x0etestIterations\x12\x1e\n\npro\
    perties\x18\x04\x20\x03(\tR\nproperties\x12p\n\x0fshrinking_rules\x18\
    \x05\x20\x03(\x0b2G.kymera_mappings.TestingEnhancement.PropertyTesting.S\
    hrinkingRulesEntryR\x0eshrinkingRules\x1a=\n\x0fGeneratorsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\x1aA\n\x13ShrinkingRulesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a\xdf\x03\n\x0bFuzzTesting\x12!\n\x0cfuzz_targets\x18\
    \x01\x20\x03(\tR\x0bfuzzTargets\x12x\n\x13mutation_strategies\x18\x02\
    \x20\x03(\x0b2G.kymera_mappings.TestingEnhancement.FuzzTesting.MutationS\
    trategiesEntryR\x12mutationStrategies\x12'\n\x0ffuzz_iterations\x18\x03\
    \x20\x01(\rR\x0efuzzIterations\x12\x16\n\x06corpus\x18\x04\x20\x03(\tR\
    \x06corpus\x12i\n\x0ecoverage_goals\x18\x05\x20\x03(\x0b2B.kymera_mappin\
    gs.TestingEnhancement.FuzzTesting.CoverageGoalsEntryR\rcoverageGoals\x1a\
    E\n\x17MutationStrategiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a@\n\x12C\
    overageGoalsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xf3\x03\n\nTestOrac\
    le\x12)\n\x10validation_rules\x18\x01\x20\x03(\tR\x0fvalidationRules\x12\
    t\n\x12expected_behaviors\x18\x02\x20\x03(\x0b2E.kymera_mappings.Testing\
    Enhancement.TestOracle.ExpectedBehaviorsEntryR\x11expectedBehaviors\x12)\
    \n\x10invariant_checks\x18\x03\x20\x03(\tR\x0finvariantChecks\x12+\n\x11\
    strict_validation\x18\x04\x20\x01(\x08R\x10strictValidation\x12e\n\rtest\
    _matrices\x18\x05\x20\x03(\x0b2@.kymera_mappings.TestingEnhancement.Test\
    Oracle.TestMatricesEntryR\x0ctestMatrices\x1aD\n\x16ExpectedBehaviorsEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a?\n\x11TestMatricesEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\"\x8b\x0b\n\x13LanguageIntegration\x1a\xfc\x03\n\
    \rFFIDefinition\x12-\n\x12abi_specifications\x18\x01\x20\x03(\tR\x11abiS\
    pecifications\x12i\n\rtype_mappings\x18\x02\x20\x03(\x0b2D.kymera_mappin\
    gs.LanguageIntegration.FFIDefinition.TypeMappingsEntryR\x0ctypeMappings\
    \x12/\n\x13calling_conventions\x18\x03\x20\x03(\tR\x12callingConventions\
    \x12#\n\rsafety_checks\x18\x04\x20\x01(\x08R\x0csafetyChecks\x12u\n\x11m\
    arshalling_rules\x18\x05\x20\x03(\x0b2H.kymera_mappings.LanguageIntegrat\
    ion.FFIDefinition.MarshallingRulesEntryR\x10marshallingRules\x1a?\n\x11T\
    ypeMappingsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aC\n\x15MarshallingRu\
    lesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x94\x04\n\x11InteropValidati\
    on\x121\n\x14compatibility_checks\x18\x01\x20\x03(\tR\x13compatibilityCh\
    ecks\x12v\n\x10conversion_rules\x18\x02\x20\x03(\x0b2K.kymera_mappings.L\
    anguageIntegration.InteropValidation.ConversionRulesEntryR\x0fconversion\
    Rules\x12+\n\x11strict_validation\x18\x03\x20\x01(\x08R\x10strictValidat\
    ion\x12'\n\x0fboundary_checks\x18\x04\x20\x03(\tR\x0eboundaryChecks\x12v\
    \n\x10validation_state\x18\x05\x20\x03(\x0b2K.kymera_mappings.LanguageIn\
    tegration.InteropValidation.ValidationStateEntryR\x0fvalidationState\x1a\
    B\n\x14ConversionRulesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aB\n\x14Val\
    idationStateEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xdd\x02\n\x12Integr\
    ationContext\x12'\n\x0fsource_language\x18\x01\x20\x01(\tR\x0esourceLang\
    uage\x12'\n\x0ftarget_language\x18\x02\x20\x01(\tR\x0etargetLanguage\x12\
    '\n\x0factive_bindings\x18\x03\x20\x03(\tR\x0eactiveBindings\x12n\n\rcon\
    text_state\x18\x04\x20\x03(\x0b2I.kymera_mappings.LanguageIntegration.In\
    tegrationContext.ContextStateEntryR\x0ccontextState\x12\x1b\n\tsafe_mode\
    \x18\x05\x20\x01(\x08R\x08safeMode\x1a?\n\x11ContextStateEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"\xee*\n\tFFISystem\x1a\xf2\x02\n\rFFIDefinition\
    \x12\x1f\n\x0babi_version\x18\x01\x20\x01(\tR\nabiVersion\x12/\n\x13supp\
    orted_languages\x18\x02\x20\x03(\tR\x12supportedLanguages\x12q\n\x13call\
    ing_conventions\x18\x03\x20\x03(\x0b2@.kymera_mappings.FFISystem.FFIDefi\
    nition.CallingConventionsEntryR\x12callingConventions\x122\n\x15safety_c\
    hecks_enabled\x18\x04\x20\x01(\x08R\x13safetyChecksEnabled\x12!\n\x0cffi\
    _features\x18\x05\x20\x03(\tR\x0bffiFeatures\x1aE\n\x17CallingConvention\
    sEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xec\x06\n\x0fLanguageBinding\
    \x12L\n\x04rust\x18\x01\x20\x01(\x0b26.kymera_mappings.FFISystem.Languag\
    eBinding.RustBindingH\0R\x04rust\x12R\n\x06python\x18\x02\x20\x01(\x0b28\
    .kymera_mappings.FFISystem.LanguageBinding.PythonBindingH\0R\x06python\
    \x1a\xc3\x02\n\x0bRustBinding\x12\x1d\n\ncrate_name\x18\x01\x20\x01(\tR\
    \tcrateName\x12#\n\rcrate_version\x18\x02\x20\x01(\tR\x0ccrateVersion\
    \x12)\n\x10exported_symbols\x18\x03\x20\x03(\tR\x0fexportedSymbols\x12m\
    \n\rtype_mappings\x18\x04\x20\x03(\x0b2H.kymera_mappings.FFISystem.Langu\
    ageBinding.RustBinding.TypeMappingsEntryR\x0ctypeMappings\x12\x15\n\x06n\
    o_std\x18\x05\x20\x01(\x08R\x05noStd\x1a?\n\x11TypeMappingsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\x1a\xe5\x02\n\rPythonBinding\x12\x1f\n\x0bmodule_\
    name\x18\x01\x20\x01(\tR\nmoduleName\x12%\n\x0emodule_version\x18\x02\
    \x20\x01(\tR\rmoduleVersion\x12-\n\x12exported_functions\x18\x03\x20\x03\
    (\tR\x11exportedFunctions\x12x\n\x10type_conversions\x18\x04\x20\x03(\
    \x0b2M.kymera_mappings.FFISystem.LanguageBinding.PythonBinding.TypeConve\
    rsionsEntryR\x0ftypeConversions\x12\x1f\n\x0bgil_release\x18\x05\x20\x01\
    (\x08R\ngilRelease\x1aB\n\x14TypeConversionsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01B\t\n\x07binding\x1a\x8a\x07\n\x13CrossLanguageMemory\x12f\n\
    \x0fmemory_strategy\x18\x01\x20\x01(\x0b2=.kymera_mappings.FFISystem.Cro\
    ssLanguageMemory.MemoryStrategyR\x0ememoryStrategy\x123\n\x15alignment_r\
    equirement\x18\x02\x20\x01(\rR\x14alignmentRequirement\x12+\n\x11protect\
    ed_regions\x18\x03\x20\x03(\tR\x10protectedRegions\x12%\n\x0eleak_detect\
    ion\x18\x04\x20\x01(\x08R\rleakDetection\x12k\n\x0fmemory_policies\x18\
    \x05\x20\x03(\x0b2B.kymera_mappings.FFISystem.CrossLanguageMemory.Memory\
    PoliciesEntryR\x0ememoryPolicies\x1a\xd1\x03\n\x0eMemoryStrategy\x12b\n\
    \x08strategy\x18\x01\x20\x01(\x0e2F.kymera_mappings.FFISystem.CrossLangu\
    ageMemory.MemoryStrategy.StrategyR\x08strategy\x12'\n\x0fbounds_checking\
    \x18\x02\x20\x01(\x08R\x0eboundsChecking\x12'\n\x0fownership_rules\x18\
    \x03\x20\x03(\tR\x0eownershipRules\x12t\n\rcleanup_hooks\x18\x04\x20\x03\
    (\x0b2O.kymera_mappings.FFISystem.CrossLanguageMemory.MemoryStrategy.Cle\
    anupHooksEntryR\x0ccleanupHooks\x1a?\n\x11CleanupHooksEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"R\n\x08Strategy\x12\x0b\n\x07UNKNOWN\x10\0\x12\x08\
    \n\x04COPY\x10\x01\x12\r\n\tZERO_COPY\x10\x02\x12\x11\n\rSHARED_MEMORY\
    \x10\x03\x12\r\n\tSMART_PTR\x10\x04\x1aA\n\x13MemoryPoliciesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\xad\x05\n\nTypeBridge\x12V\n\rtype_mappi\
    ngs\x18\x01\x20\x03(\x0b21.kymera_mappings.FFISystem.TypeBridge.TypeMapp\
    ingR\x0ctypeMappings\x12#\n\rstrict_typing\x18\x02\x20\x01(\x08R\x0cstri\
    ctTyping\x12%\n\x0ecoercion_rules\x18\x03\x20\x03(\tR\rcoercionRules\x12\
    \\\n\rtype_registry\x18\x04\x20\x03(\x0b27.kymera_mappings.FFISystem.Typ\
    eBridge.TypeRegistryEntryR\x0ctypeRegistry\x1a\xdb\x02\n\x0bTypeMapping\
    \x12\x1f\n\x0bkymera_type\x18\x01\x20\x01(\tR\nkymeraType\x12!\n\x0cfore\
    ign_type\x18\x02\x20\x01(\tR\x0bforeignType\x12/\n\x13requires_conversio\
    n\x18\x03\x20\x01(\x08R\x12requiresConversion\x12\x20\n\x0bconstraints\
    \x18\x04\x20\x03(\tR\x0bconstraints\x12q\n\x10conversion_rules\x18\x05\
    \x20\x03(\x0b2F.kymera_mappings.FFISystem.TypeBridge.TypeMapping.Convers\
    ionRulesEntryR\x0fconversionRules\x1aB\n\x14ConversionRulesEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\x1a?\n\x11TypeRegistryEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a\xfe\x03\n\x0bErrorBridge\x12Z\n\x0eerror_mappings\x18\x01\
    \x20\x03(\x0b23.kymera_mappings.FFISystem.ErrorBridge.ErrorMappingR\rerr\
    orMappings\x12*\n\x11catch_all_foreign\x18\x02\x20\x01(\x08R\x0fcatchAll\
    Foreign\x12%\n\x0eerror_handlers\x18\x03\x20\x03(\tR\rerrorHandlers\x12]\
    \n\rerror_context\x18\x04\x20\x03(\x0b28.kymera_mappings.FFISystem.Error\
    Bridge.ErrorContextEntryR\x0cerrorContext\x1a\x9f\x01\n\x0cErrorMapping\
    \x12!\n\x0ckymera_error\x18\x01\x20\x01(\tR\x0bkymeraError\x12#\n\rforei\
    gn_error\x18\x02\x20\x01(\tR\x0cforeignError\x12)\n\x10conversion_rules\
    \x18\x03\x20\x03(\tR\x0fconversionRules\x12\x1c\n\tpropagate\x18\x04\x20\
    \x01(\x08R\tpropagate\x1a?\n\x11ErrorContextEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a\xa3\x08\n\x10BuildIntegration\x12a\n\x0cdependencies\x18\
    \x01\x20\x01(\x0b2=.kymera_mappings.FFISystem.BuildIntegration.Dependenc\
    yManagerR\x0cdependencies\x12Z\n\x0cbuild_config\x18\x02\x20\x01(\x0b27.\
    kymera_mappings.FFISystem.BuildIntegration.BuildConfigR\x0bbuildConfig\
    \x12\x1f\n\x0bbuild_steps\x18\x03\x20\x03(\tR\nbuildSteps\x12\\\n\x0bbui\
    ld_cache\x18\x04\x20\x03(\x0b2;.kymera_mappings.FFISystem.BuildIntegrati\
    on.BuildCacheEntryR\nbuildCache\x12+\n\x11incremental_build\x18\x05\x20\
    \x01(\x08R\x10incrementalBuild\x1a\xcc\x02\n\x11DependencyManager\x12\
    \x1f\n\x0brust_crates\x18\x01\x20\x03(\tR\nrustCrates\x12'\n\x0fpython_p\
    ackages\x18\x02\x20\x03(\tR\x0epythonPackages\x12\x86\x01\n\x13version_c\
    onstraints\x18\x03\x20\x03(\x0b2U.kymera_mappings.FFISystem.BuildIntegra\
    tion.DependencyManager.VersionConstraintsEntryR\x12versionConstraints\
    \x12\x1d\n\nauto_fetch\x18\x04\x20\x01(\x08R\tautoFetch\x1aE\n\x17Versio\
    nConstraintsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x95\x02\n\x0bBuildC\
    onfig\x12#\n\rtarget_triple\x18\x01\x20\x01(\tR\x0ctargetTriple\x12\x1f\
    \n\x0bbuild_flags\x18\x02\x20\x03(\tR\nbuildFlags\x12_\n\x08env_vars\x18\
    \x03\x20\x03(\x0b2D.kymera_mappings.FFISystem.BuildIntegration.BuildConf\
    ig.EnvVarsEntryR\x07envVars\x12#\n\rdebug_symbols\x18\x04\x20\x01(\x08R\
    \x0cdebugSymbols\x1a:\n\x0cEnvVarsEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\
    \x1a=\n\x0fBuildCacheEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x98\x08\n\
    \x13RuntimeVerification\x12R\n\x06safety\x18\x01\x20\x01(\x0b2:.kymera_m\
    appings.FFISystem.RuntimeVerification.SafetyCheckR\x06safety\x12[\n\x07m\
    etrics\x18\x02\x20\x01(\x0b2A.kymera_mappings.FFISystem.RuntimeVerificat\
    ion.PerformanceMetricsR\x07metrics\x12-\n\x12verification_hooks\x18\x03\
    \x20\x03(\tR\x11verificationHooks\x12h\n\x0eruntime_checks\x18\x04\x20\
    \x03(\x0b2A.kymera_mappings.FFISystem.RuntimeVerification.RuntimeChecksE\
    ntryR\rruntimeChecks\x12\x1f\n\x0bstrict_mode\x18\x05\x20\x01(\x08R\nstr\
    ictMode\x1a\xa6\x02\n\x0bSafetyCheck\x12'\n\x0fboundary_checks\x18\x01\
    \x20\x03(\tR\x0eboundaryChecks\x12j\n\ninvariants\x18\x02\x20\x03(\x0b2J\
    .kymera_mappings.FFISystem.RuntimeVerification.SafetyCheck.InvariantsEnt\
    ryR\ninvariants\x12#\n\rnull_checking\x18\x03\x20\x01(\x08R\x0cnullCheck\
    ing\x12\x1e\n\nsanitizers\x18\x04\x20\x03(\tR\nsanitizers\x1a=\n\x0fInva\
    riantsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xaa\x02\n\x12PerformanceMe\
    trics\x12\x1b\n\thot_paths\x18\x01\x20\x03(\tR\x08hotPaths\x12q\n\nthres\
    holds\x18\x02\x20\x03(\x0b2Q.kymera_mappings.FFISystem.RuntimeVerificati\
    on.PerformanceMetrics.ThresholdsEntryR\nthresholds\x12\x1f\n\x0bprofile_\
    ffi\x18\x03\x20\x01(\x08R\nprofileFfi\x12$\n\roptimizations\x18\x04\x20\
    \x03(\tR\roptimizations\x1a=\n\x0fThresholdsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05valu\
    e:\x028\x01\x1a@\n\x12RuntimeChecksEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\xae]\n\x19IntelligentHardwareSystem\x12n\n\x13quality_integration\
    \x18\x08\x20\x01(\x0b2=.kymera_mappings.IntelligentHardwareSystem.Qualit\
    yIntegrationR\x12qualityIntegration\x1a\xcc\x04\n\x12QualityIntegration\
    \x12K\n\x0equality_system\x18\x01\x20\x01(\x0b2$.kymera_mappings.Quality\
    RatingSystemR\rqualitySystem\x12z\n\x0fhardware_scores\x18\x02\x20\x03(\
    \x0b2Q.kymera_mappings.IntelligentHardwareSystem.QualityIntegration.Hard\
    wareScoresEntryR\x0ehardwareScores\x121\n\x14optimization_targets\x18\
    \x03\x20\x03(\tR\x13optimizationTargets\x128\n\x18meets_hardware_standar\
    ds\x18\x04\x20\x01(\x08R\x16meetsHardwareStandards\x12z\n\x0fquality_met\
    rics\x18\x05\x20\x03(\x0b2Q.kymera_mappings.IntelligentHardwareSystem.Qu\
    alityIntegration.QualityMetricsEntryR\x0equalityMetrics\x1aA\n\x13Hardwa\
    reScoresEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\x01R\x05value:\x028\x01\x1aA\n\x13QualityMetricsEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a\xf1\x0b\n\x11HardwareAwareness\
    \x1a\xfe\x02\n\x0fSystemDetection\x12)\n\x10cpu_architecture\x18\x01\x20\
    \x01(\tR\x0fcpuArchitecture\x12!\n\x0ccpu_features\x18\x02\x20\x03(\tR\
    \x0bcpuFeatures\x12\x80\x01\n\x0ccpu_topology\x18\x03\x20\x03(\x0b2].kym\
    era_mappings.IntelligentHardwareSystem.HardwareAwareness.SystemDetection\
    .CpuTopologyEntryR\x0bcpuTopology\x12/\n\x13heterogeneous_cores\x18\x04\
    \x20\x01(\x08R\x12heterogeneousCores\x12)\n\x10instruction_sets\x18\x05\
    \x20\x03(\tR\x0finstructionSets\x1a>\n\x10CpuTopologyEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\rR\
    \x05value:\x028\x01\x1a\xb2\x04\n\x0fGPUCapabilities\x12\x1f\n\x0bgpu_de\
    vices\x18\x01\x20\x03(\tR\ngpuDevices\x12\x98\x01\n\x14compute_capabilit\
    ies\x18\x02\x20\x03(\x0b2e.kymera_mappings.IntelligentHardwareSystem.Har\
    dwareAwareness.GPUCapabilities.ComputeCapabilitiesEntryR\x13computeCapab\
    ilities\x12%\n\x0eunified_memory\x18\x03\x20\x01(\x08R\runifiedMemory\
    \x12!\n\x0cgpu_features\x18\x04\x20\x03(\tR\x0bgpuFeatures\x12\x8c\x01\n\
    \x10memory_hierarchy\x18\x05\x20\x03(\x0b2a.kymera_mappings.IntelligentH\
    ardwareSystem.HardwareAwareness.GPUCapabilities.MemoryHierarchyEntryR\
    \x0fmemoryHierarchy\x1aF\n\x18ComputeCapabilitiesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1aB\n\x14MemoryHierarchyEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x04R\x05value:\
    \x028\x01\x1a\xa5\x04\n\x12AcceleratorSupport\x12+\n\x11accelerator_type\
    s\x18\x01\x20\x03(\tR\x10acceleratorTypes\x12\x8f\x01\n\x10accelerator_c\
    aps\x18\x02\x20\x03(\x0b2d.kymera_mappings.IntelligentHardwareSystem.Har\
    dwareAwareness.AcceleratorSupport.AcceleratorCapsEntryR\x0facceleratorCa\
    ps\x12#\n\rneural_engine\x18\x03\x20\x01(\x08R\x0cneuralEngine\x12!\n\
    \x0ccustom_asics\x18\x04\x20\x03(\tR\x0bcustomAsics\x12\x83\x01\n\x0cfpg\
    a_configs\x18\x05\x20\x03(\x0b2`.kymera_mappings.IntelligentHardwareSyst\
    em.HardwareAwareness.AcceleratorSupport.FpgaConfigsEntryR\x0bfpgaConfigs\
    \x1aB\n\x14AcceleratorCapsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10\
    FpgaConfigsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x9b\t\n\x10ComputeF\
    ramework\x1a\xfd\x02\n\x0fCUDAIntegration\x12!\n\x0ccuda_version\x18\x01\
    \x20\x01(\rR\x0bcudaVersion\x12+\n\x11cuda_capabilities\x18\x02\x20\x03(\
    \tR\x10cudaCapabilities\x12\x85\x01\n\x0ecuda_libraries\x18\x03\x20\x03(\
    \x0b2^.kymera_mappings.IntelligentHardwareSystem.ComputeFramework.CUDAIn\
    tegration.CudaLibrariesEntryR\rcudaLibraries\x12!\n\x0ctensor_cores\x18\
    \x04\x20\x01(\x08R\x0btensorCores\x12-\n\x12cuda_optimizations\x18\x05\
    \x20\x03(\tR\x11cudaOptimizations\x1a@\n\x12CudaLibrariesEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a\xf9\x02\n\x0fROCmIntegration\x12!\n\x0crocm_ver\
    sion\x18\x01\x20\x01(\rR\x0brocmVersion\x12!\n\x0chip_features\x18\x02\
    \x20\x03(\tR\x0bhipFeatures\x12\x85\x01\n\x0erocm_libraries\x18\x03\x20\
    \x03(\x0b2^.kymera_mappings.IntelligentHardwareSystem.ComputeFramework.R\
    OCmIntegration.RocmLibrariesEntryR\rrocmLibraries\x12'\n\x0finfinity_fab\
    ric\x18\x04\x20\x01(\x08R\x0einfinityFabric\x12-\n\x12rocm_optimizations\
    \x18\x05\x20\x03(\tR\x11rocmOptimizations\x1a@\n\x12RocmLibrariesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\x8a\x03\n\rVulkanCompute\x12%\n\x0ev\
    ulkan_version\x18\x01\x20\x01(\rR\rvulkanVersion\x12)\n\x10compute_featu\
    res\x18\x02\x20\x03(\tR\x0fcomputeFeatures\x12\x92\x01\n\x13shader_capab\
    ilities\x18\x03\x20\x03(\x0b2a.kymera_mappings.IntelligentHardwareSystem\
    .ComputeFramework.VulkanCompute.ShaderCapabilitiesEntryR\x12shaderCapabi\
    lities\x12\x1e\n\nraytracing\x18\x04\x20\x01(\x08R\nraytracing\x12+\n\
    \x11vulkan_extensions\x18\x05\x20\x03(\tR\x10vulkanExtensions\x1aE\n\x17\
    ShaderCapabilitiesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xa6\r\n\x10Lo\
    wLatencySystem\x1a\xa9\x04\n\x13LatencyOptimization\x12&\n\x0fzero_copy_\
    paths\x18\x01\x20\x03(\tR\rzeroCopyPaths\x12\x8c\x01\n\x0flatency_target\
    s\x18\x02\x20\x03(\x0b2c.kymera_mappings.IntelligentHardwareSystem.LowLa\
    tencySystem.LatencyOptimization.LatencyTargetsEntryR\x0elatencyTargets\
    \x12#\n\rkernel_bypass\x18\x03\x20\x01(\x08R\x0ckernelBypass\x12!\n\x0cd\
    ma_channels\x18\x04\x20\x03(\tR\x0bdmaChannels\x12\x8c\x01\n\x0fmemory_p\
    olicies\x18\x05\x20\x03(\x0b2c.kymera_mappings.IntelligentHardwareSystem\
    .LowLatencySystem.LatencyOptimization.MemoryPoliciesEntryR\x0ememoryPoli\
    cies\x1aA\n\x13LatencyTargetsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\rR\x05value:\x028\x01\x1aA\n\
    \x13MemoryPoliciesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xb9\x04\n\x12\
    RealTimeScheduling\x12#\n\rrt_priorities\x18\x01\x20\x03(\tR\x0crtPriori\
    ties\x12\x94\x01\n\x12scheduling_classes\x18\x02\x20\x03(\x0b2e.kymera_m\
    appings.IntelligentHardwareSystem.LowLatencySystem.RealTimeScheduling.Sc\
    hedulingClassesEntryR\x11schedulingClasses\x12-\n\x12preemption_control\
    \x18\x03\x20\x01(\x08R\x11preemptionControl\x12%\n\x0eaffinity_masks\x18\
    \x04\x20\x03(\tR\raffinityMasks\x12\x88\x01\n\x0ert_constraints\x18\x05\
    \x20\x03(\x0b2a.kymera_mappings.IntelligentHardwareSystem.LowLatencySyst\
    em.RealTimeScheduling.RtConstraintsEntryR\rrtConstraints\x1aD\n\x16Sched\
    ulingClassesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\rR\x05value:\x028\x01\x1a@\n\x12RtConstraints\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a\xa9\x04\n\x0fAsyncProcessing\x12\
    !\n\x0casync_queues\x18\x01\x20\x03(\tR\x0basyncQueues\x12\x85\x01\n\x0e\
    queue_policies\x18\x02\x20\x03(\x0b2^.kymera_mappings.IntelligentHardwar\
    eSystem.LowLatencySystem.AsyncProcessing.QueuePoliciesEntryR\rqueuePolic\
    ies\x12*\n\x11zero_latency_mode\x18\x03\x20\x01(\x08R\x0fzeroLatencyMode\
    \x12'\n\x0fasync_callbacks\x18\x04\x20\x03(\tR\x0easyncCallbacks\x12\x8e\
    \x01\n\x11completion_tokens\x18\x05\x20\x03(\x0b2a.kymera_mappings.Intel\
    ligentHardwareSystem.LowLatencySystem.AsyncProcessing.CompletionTokensEn\
    tryR\x10completionTokens\x1a@\n\x12QueuePoliciesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1aC\n\x15CompletionTokensEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1a\xc0\r\n\x11ConcurrencyEngine\x1a\xb7\x04\n\x14WorkloadDistribu\
    tion\x12\x1f\n\x0bwork_groups\x18\x01\x20\x03(\tR\nworkGroups\x12\x8b\
    \x01\n\x0eload_balancing\x18\x02\x20\x03(\x0b2d.kymera_mappings.Intellig\
    entHardwareSystem.ConcurrencyEngine.WorkloadDistribution.LoadBalancingEn\
    tryR\rloadBalancing\x12'\n\x0fdynamic_scaling\x18\x03\x20\x01(\x08R\x0ed\
    ynamicScaling\x12-\n\x12distribution_rules\x18\x04\x20\x03(\tR\x11distri\
    butionRules\x12\x91\x01\n\x10workload_metrics\x18\x05\x20\x03(\x0b2f.kym\
    era_mappings.IntelligentHardwareSystem.ConcurrencyEngine.WorkloadDistrib\
    ution.WorkloadMetricsEntryR\x0fworkloadMetrics\x1a@\n\x12LoadBalancingEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\rR\x05value:\x028\x01\x1aB\n\x14WorkloadMetricsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\xb5\x04\n\x11ParallelExecution\x12'\n\
    \x0fexecution_units\x18\x01\x20\x03(\tR\x0eexecutionUnits\x12\x91\x01\n\
    \x11parallel_patterns\x18\x02\x20\x03(\x0b2d.kymera_mappings.Intelligent\
    HardwareSystem.ConcurrencyEngine.ParallelExecution.ParallelPatternsEntry\
    R\x10parallelPatterns\x12$\n\rvectorization\x18\x03\x20\x01(\x08R\rvecto\
    rization\x12'\n\x0fsimd_operations\x18\x04\x20\x03(\tR\x0esimdOperations\
    \x12\x8b\x01\n\x0fthreading_model\x18\x05\x20\x03(\x0b2b.kymera_mappings\
    .IntelligentHardwareSystem.ConcurrencyEngine.ParallelExecution.Threading\
    ModelEntryR\x0ethreadingModel\x1aC\n\x15ParallelPatternsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1aA\n\x13ThreadingModelEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a\xb8\x04\n\x19SynchronizationPrimitives\x12'\n\x0fsync_mech\
    anisms\x18\x01\x20\x03(\tR\x0esyncMechanisms\x12\x8d\x01\n\rbarrier_type\
    s\x18\x02\x20\x03(\x0b2h.kymera_mappings.IntelligentHardwareSystem.Concu\
    rrencyEngine.SynchronizationPrimitives.BarrierTypesEntryR\x0cbarrierType\
    s\x12\x1b\n\tlock_free\x18\x03\x20\x01(\x08R\x08lockFree\x12+\n\x11atomi\
    c_operations\x18\x04\x20\x03(\tR\x10atomicOperations\x12\x93\x01\n\x0fme\
    mory_ordering\x18\x05\x20\x03(\x0b2j.kymera_mappings.IntelligentHardware\
    System.ConcurrencyEngine.SynchronizationPrimitives.MemoryOrderingEntryR\
    \x0ememoryOrdering\x1a?\n\x11BarrierTypesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1aA\n\x13MemoryOrderingEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \xb2\x0c\n\x0cMemorySystem\x1a\xf0\x03\n\x0fMemoryHierarchy\x12!\n\x0cca\
    che_levels\x18\x01\x20\x03(\tR\x0bcacheLevels\x12{\n\x0cmemory_sizes\x18\
    \x02\x20\x03(\x0b2X.kymera_mappings.IntelligentHardwareSystem.MemorySyst\
    em.MemoryHierarchy.MemorySizesEntryR\x0bmemorySizes\x12\x1d\n\nnuma_awar\
    e\x18\x03\x20\x01(\x08R\tnumaAware\x12!\n\x0cmemory_types\x18\x04\x20\
    \x03(\tR\x0bmemoryTypes\x12{\n\x0cmemory_zones\x18\x05\x20\x03(\x0b2X.ky\
    mera_mappings.IntelligentHardwareSystem.MemorySystem.MemoryHierarchy.Mem\
    oryZonesEntryR\x0bmemoryZones\x1a>\n\x10MemorySizesEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x04R\
    \x05value:\x028\x01\x1a>\n\x10MemoryZonesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1a\xa7\x04\n\x12MemoryOptimization\x123\n\x15allocation_strategie\
    s\x18\x01\x20\x03(\tR\x14allocationStrategies\x12\x87\x01\n\x0fpooling_c\
    onfigs\x18\x02\x20\x03(\x0b2^.kymera_mappings.IntelligentHardwareSystem.\
    MemorySystem.MemoryOptimization.PoolingConfigsEntryR\x0epoolingConfigs\
    \x12'\n\x0fzero_allocation\x18\x03\x20\x01(\x08R\x0ezeroAllocation\x12'\
    \n\x0fdefrag_policies\x18\x04\x20\x03(\tR\x0edefragPolicies\x12}\n\x0bco\
    mpression\x18\x05\x20\x03(\x0b2[.kymera_mappings.IntelligentHardwareSyst\
    em.MemorySystem.MemoryOptimization.CompressionEntryR\x0bcompression\x1aA\
    \n\x13PoolingConfigsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10Com\
    pressionEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x84\x04\n\x0cDataTransfe\
    r\x12%\n\x0etransfer_modes\x18\x01\x20\x03(\tR\rtransferModes\x12u\n\x0b\
    dma_configs\x18\x02\x20\x03(\x0b2T.kymera_mappings.IntelligentHardwareSy\
    stem.MemorySystem.DataTransfer.DmaConfigsEntryR\ndmaConfigs\x12\x1f\n\
    \x0bpeer_access\x18\x03\x20\x01(\x08R\npeerAccess\x12'\n\x0ftransfer_que\
    ues\x18\x04\x20\x03(\tR\x0etransferQueues\x12\x87\x01\n\x11bandwidth_con\
    trol\x18\x05\x20\x03(\x0b2Z.kymera_mappings.IntelligentHardwareSystem.Me\
    morySystem.DataTransfer.BandwidthControlEntryR\x10bandwidthControl\x1a=\
    \n\x0fDmaConfigsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aC\n\x15Bandwid\
    thControlEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05\
    value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xae\r\n\x0fAutoIntegrat\
    ion\x1a\xc5\x04\n\x12PlatformAdaptation\x12+\n\x11platform_profiles\x18\
    \x01\x20\x03(\tR\x10platformProfiles\x12\x8d\x01\n\x10adaptation_rules\
    \x18\x02\x20\x03(\x0b2b.kymera_mappings.IntelligentHardwareSystem.AutoIn\
    tegration.PlatformAdaptation.AdaptationRulesEntryR\x0fadaptationRules\
    \x127\n\x17dynamic_reconfiguration\x18\x03\x20\x01(\x08R\x16dynamicRecon\
    figuration\x12%\n\x0ehardware_paths\x18\x04\x20\x03(\tR\rhardwarePaths\
    \x12\x8a\x01\n\x0fdriver_mappings\x18\x05\x20\x03(\x0b2a.kymera_mappings\
    .IntelligentHardwareSystem.AutoIntegration.PlatformAdaptation.DriverMapp\
    ingsEntryR\x0edriverMappings\x1aB\n\x14AdaptationRulesEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1aA\n\x13DriverMappingsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a\xaf\x04\n\x14OptimizationPipeline\x12/\n\x13optimization_p\
    asses\x18\x01\x20\x03(\tR\x12optimizationPasses\x12\x89\x01\n\x0ecompile\
    r_flags\x18\x02\x20\x03(\x0b2b.kymera_mappings.IntelligentHardwareSystem\
    .AutoIntegration.OptimizationPipeline.CompilerFlagsEntryR\rcompilerFlags\
    \x12%\n\x0eprofile_guided\x18\x03\x20\x01(\x08R\rprofileGuided\x12'\n\
    \x0ftarget_specific\x18\x04\x20\x03(\tR\x0etargetSpecific\x12\x86\x01\n\
    \rtuning_params\x18\x05\x20\x03(\x0b2a.kymera_mappings.IntelligentHardwa\
    reSystem.AutoIntegration.OptimizationPipeline.TuningParamsEntryR\x0ctuni\
    ngParams\x1a@\n\x12CompilerFlagsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    ?\n\x11TuningParamsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xa0\x04\n\x11\
    RuntimeAdaptation\x12#\n\rruntime_hooks\x18\x01\x20\x03(\tR\x0cruntimeHo\
    oks\x12\x8f\x01\n\x11feature_detection\x18\x02\x20\x03(\x0b2b.kymera_map\
    pings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.Featur\
    eDetectionEntryR\x10featureDetection\x12\x1d\n\nhot_reload\x18\x03\x20\
    \x01(\x08R\thotReload\x12%\n\x0efallback_paths\x18\x04\x20\x03(\tR\rfall\
    backPaths\x12\x86\x01\n\x0eruntime_config\x18\x05\x20\x03(\x0b2_.kymera_\
    mappings.IntelligentHardwareSystem.AutoIntegration.RuntimeAdaptation.Run\
    timeConfigEntryR\rruntimeConfig\x1aC\n\x15FeatureDetectionEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\x1a@\n\x12RuntimeConfigEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a\xed\r\n\x12PerformanceMonitor\x1a\xdc\x04\n\x0fHardwareMet\
    rics\x121\n\x14performance_counters\x18\x01\x20\x03(\tR\x13performanceCo\
    unters\x12\x96\x01\n\x13utilization_metrics\x18\x02\x20\x03(\x0b2e.kymer\
    a_mappings.IntelligentHardwareSystem.PerformanceMonitor.HardwareMetrics.\
    UtilizationMetricsEntryR\x12utilizationMetrics\x12)\n\x10power_monitorin\
    g\x18\x03\x20\x01(\x08R\x0fpowerMonitoring\x12'\n\x0fthermal_metrics\x18\
    \x04\x20\x03(\tR\x0ethermalMetrics\x12\x99\x01\n\x14bottleneck_detection\
    \x18\x05\x20\x03(\x0b2f.kymera_mappings.IntelligentHardwareSystem.Perfor\
    manceMonitor.HardwareMetrics.BottleneckDetectionEntryR\x13bottleneckDete\
    ction\x1aE\n\x17UtilizationMetricsEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01\
    \x1aF\n\x18BottleneckDetectionEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \xc9\x04\n\x10WorkloadAnalysis\x12+\n\x11workload_patterns\x18\x01\x20\
    \x03(\tR\x10workloadPatterns\x12\x88\x01\n\x0eresource_usage\x18\x02\x20\
    \x03(\x0b2a.kymera_mappings.IntelligentHardwareSystem.PerformanceMonitor\
    .WorkloadAnalysis.ResourceUsageEntryR\rresourceUsage\x12/\n\x13predictiv\
    e_analysis\x18\x03\x20\x01(\x08R\x12predictiveAnalysis\x12-\n\x12optimiz\
    ation_hints\x18\x04\x20\x03(\tR\x11optimizationHints\x12\x94\x01\n\x12pe\
    rformance_models\x18\x05\x20\x03(\x0b2e.kymera_mappings.IntelligentHardw\
    areSystem.PerformanceMonitor.WorkloadAnalysis.PerformanceModelsEntryR\
    \x11performanceModels\x1a@\n\x12ResourceUsageEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1aD\n\x16PerformanceModelsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\x1a\xab\x04\n\x0eAdaptiveTuning\x12+\n\x11tuning_parameters\x18\x01\
    \x20\x03(\tR\x10tuningParameters\x12\x8c\x01\n\x10feedback_metrics\x18\
    \x02\x20\x03(\x0b2a.kymera_mappings.IntelligentHardwareSystem.Performanc\
    eMonitor.AdaptiveTuning.FeedbackMetricsEntryR\x0ffeedbackMetrics\x12\x1f\
    \n\x0bauto_tuning\x18\x03\x20\x01(\x08R\nautoTuning\x12)\n\x10adaptation\
    _rules\x18\x04\x20\x03(\tR\x0fadaptationRules\x12\x89\x01\n\x0ftuning_po\
    licies\x18\x05\x20\x03(\x0b2`.kymera_mappings.IntelligentHardwareSystem.\
    PerformanceMonitor.AdaptiveTuning.TuningPoliciesEntryR\x0etuningPolicies\
    \x1aB\n\x14FeedbackMetricsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05value:\x028\x01\x1aA\n\
    \x13TuningPoliciesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x8a1\n\x13Quali\
    tyRatingSystem\x12R\n\x10language_prompts\x18\x08\x20\x01(\x0b2'.kymera_\
    mappings.LanguageQualityPromptsR\x0flanguagePrompts\x1a\xf1\x03\n\x0eQua\
    lityMetrics\x12#\n\rquality_score\x18\x01\x20\x01(\x01R\x0cqualityScore\
    \x12s\n\x10component_scores\x18\x02\x20\x03(\x0b2H.kymera_mappings.Quali\
    tyRatingSystem.QualityMetrics.ComponentScoresEntryR\x0fcomponentScores\
    \x12+\n\x11improvement_areas\x18\x03\x20\x03(\tR\x10improvementAreas\x12\
    '\n\x0fmeets_standards\x18\x04\x20\x01(\x08R\x0emeetsStandards\x12j\n\rq\
    uality_notes\x18\x05\x20\x03(\x0b2E.kymera_mappings.QualityRatingSystem.\
    QualityMetrics.QualityNotesEntryR\x0cqualityNotes\x1aB\n\x14ComponentSco\
    resEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\x01R\x05value:\x028\x01\x1a?\n\x11QualityNotesEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1a\x8f\x03\n\x10ModularityChecks\x124\n\
    \x16unused_imports_removed\x18\x01\x20\x01(\x08R\x14unusedImportsRemoved\
    \x12)\n\x10dependency_graph\x18\x02\x20\x03(\tR\x0fdependencyGraph\x12r\
    \n\x0finterface_specs\x18\x03\x20\x03(\x0b2I.kymera_mappings.QualityRati\
    ngSystem.ModularityChecks.InterfaceSpecsEntryR\x0einterfaceSpecs\x124\n\
    \x16circular_deps_resolved\x18\x04\x20\x01(\x08R\x14circularDepsResolved\
    \x12-\n\x12modular_boundaries\x18\x05\x20\x03(\tR\x11modularBoundaries\
    \x1aA\n\x13InterfaceSpecsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x9a\x04\
    \n\rErrorHandling\x12%\n\x0eerror_patterns\x18\x01\x20\x03(\tR\rerrorPat\
    terns\x12{\n\x13recovery_strategies\x18\x02\x20\x03(\x0b2J.kymera_mappin\
    gs.QualityRatingSystem.ErrorHandling.RecoveryStrategiesEntryR\x12recover\
    yStrategies\x125\n\x16comprehensive_handling\x18\x03\x20\x01(\x08R\x15co\
    mprehensiveHandling\x12#\n\rsafety_checks\x18\x04\x20\x03(\tR\x0csafetyC\
    hecks\x12{\n\x13error_documentation\x18\x05\x20\x03(\x0b2J.kymera_mappin\
    gs.QualityRatingSystem.ErrorHandling.ErrorDocumentationEntryR\x12errorDo\
    cumentation\x1aE\n\x17RecoveryStrategiesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1aE\n\x17ErrorDocumentationEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\
    \x1a\xf4\x03\n\x11PerformanceChecks\x12\x1a\n\x08hotspots\x18\x01\x20\
    \x03(\tR\x08hotspots\x12f\n\nbenchmarks\x18\x02\x20\x03(\x0b2F.kymera_ma\
    ppings.QualityRatingSystem.PerformanceChecks.BenchmarksEntryR\nbenchmark\
    s\x12-\n\x12optimized_critical\x18\x03\x20\x01(\x08R\x11optimizedCritica\
    l\x12-\n\x12optimization_notes\x18\x04\x20\x03(\tR\x11optimizationNotes\
    \x12y\n\x11perf_requirements\x18\x05\x20\x03(\x0b2L.kymera_mappings.Qual\
    ityRatingSystem.PerformanceChecks.PerfRequirementsEntryR\x10perfRequirem\
    ents\x1a=\n\x0fBenchmarksEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05value:\x028\x01\x1aC\n\
    \x15PerfRequirementsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xd1\x02\n\
    \x13DocumentationChecks\x12+\n\x11public_documented\x18\x01\x20\x01(\x08\
    R\x10publicDocumented\x12!\n\x0cdoc_coverage\x18\x02\x20\x03(\tR\x0bdocC\
    overage\x12`\n\x08api_docs\x18\x03\x20\x03(\x0b2E.kymera_mappings.Qualit\
    yRatingSystem.DocumentationChecks.ApiDocsEntryR\x07apiDocs\x12+\n\x11exa\
    mples_provided\x18\x04\x20\x01(\x08R\x10examplesProvided\x12\x1f\n\x0bdo\
    c_quality\x18\x05\x20\x03(\tR\ndocQuality\x1a:\n\x0cApiDocsEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value:\x028\x01\x1a\xf7\x08\n\x14ImplementationChecks\x1a\x93\x03\
    \n\x0eSecurityChecks\x12'\n\x0finput_validated\x18\x01\x20\x01(\x08R\x0e\
    inputValidated\x12+\n\x11security_measures\x18\x02\x20\x03(\tR\x10securi\
    tyMeasures\x12\x91\x01\n\x13vulnerability_fixes\x18\x03\x20\x03(\x0b2`.k\
    ymera_mappings.QualityRatingSystem.ImplementationChecks.SecurityChecks.V\
    ulnerabilityFixesEntryR\x12vulnerabilityFixes\x12'\n\x0fsecure_defaults\
    \x18\x04\x20\x01(\x08R\x0esecureDefaults\x12'\n\x0fsecurity_review\x18\
    \x05\x20\x03(\tR\x0esecurityReview\x1aE\n\x17VulnerabilityFixesEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\xea\x02\n\rTestingChecks\x12/\n\x13compr\
    ehensive_tests\x18\x01\x20\x01(\x08R\x12comprehensiveTests\x12#\n\rtest_\
    coverage\x18\x02\x20\x03(\tR\x0ctestCoverage\x12u\n\ntest_cases\x18\x03\
    \x20\x03(\x0b2V.kymera_mappings.QualityRatingSystem.ImplementationChecks\
    .TestingChecks.TestCasesEntryR\ttestCases\x12+\n\x11integration_tests\
    \x18\x04\x20\x01(\x08R\x10integrationTests\x12!\n\x0ctest_quality\x18\
    \x05\x20\x03(\tR\x0btestQuality\x1a<\n\x0eTestCasesEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01\x1a\xdb\x02\n\x0bCodeQuality\x12#\n\rfollows_style\x18\
    \x01\x20\x01(\x08R\x0cfollowsStyle\x12!\n\x0ccode_metrics\x18\x02\x20\
    \x03(\tR\x0bcodeMetrics\x12y\n\x0creview_notes\x18\x03\x20\x03(\x0b2V.ky\
    mera_mappings.QualityRatingSystem.ImplementationChecks.CodeQuality.Revie\
    wNotesEntryR\x0breviewNotes\x12\"\n\x0cmaintainable\x18\x04\x20\x01(\x08\
    R\x0cmaintainable\x12%\n\x0equality_checks\x18\x05\x20\x03(\tR\rqualityC\
    hecks\x1a>\n\x10ReviewNotesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    \xbe\x08\n\x0eLanguageChecks\x1a\xe4\x02\n\nRustChecks\x12+\n\x11ownersh\
    ip_correct\x18\x01\x20\x01(\x08R\x10ownershipCorrect\x12)\n\x10unsafe_ju\
    stified\x18\x02\x20\x03(\tR\x0funsafeJustified\x12r\n\x0ctrait_bounds\
    \x18\x03\x20\x03(\x0b2O.kymera_mappings.QualityRatingSystem.LanguageChec\
    ks.RustChecks.TraitBoundsEntryR\x0btraitBounds\x12)\n\x10lifetime_elisio\
    n\x18\x04\x20\x01(\x08R\x0flifetimeElision\x12\x1f\n\x0brust_idioms\x18\
    \x05\x20\x03(\tR\nrustIdioms\x1a>\n\x10TraitBoundsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\x1a\xe1\x02\n\x10TypeScriptChecks\x12\x1f\n\x0btype_safety\
    \x18\x01\x20\x01(\x08R\ntypeSafety\x12#\n\rtype_coverage\x18\x02\x20\x03\
    (\tR\x0ctypeCoverage\x12\x81\x01\n\x0finterface_usage\x18\x03\x20\x03(\
    \x0b2X.kymera_mappings.QualityRatingSystem.LanguageChecks.TypeScriptChec\
    ks.InterfaceUsageEntryR\x0einterfaceUsage\x12\x1f\n\x0bstrict_mode\x18\
    \x04\x20\x01(\x08R\nstrictMode\x12\x1f\n\x0bts_features\x18\x05\x20\x03(\
    \tR\ntsFeatures\x1aA\n\x13InterfaceUsageEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\x1a\xe0\x02\n\x0cPythonChecks\x12\x1d\n\ntype_hints\x18\x01\x20\
    \x01(\x08R\ttypeHints\x12\x1a\n\x08pythonic\x18\x02\x20\x03(\tR\x08pytho\
    nic\x12z\n\x0epep_compliance\x18\x03\x20\x03(\x0b2S.kymera_mappings.Qual\
    ityRatingSystem.LanguageChecks.PythonChecks.PepComplianceEntryR\rpepComp\
    liance\x12#\n\rasync_correct\x18\x04\x20\x01(\x08R\x0casyncCorrect\x122\
    \n\x15python_best_practices\x18\x05\x20\x03(\tR\x13pythonBestPractices\
    \x1a@\n\x12PepComplianceEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xf5\x0c\
    \n\x12QualityEnforcement\x1a\x9b\x04\n\x0fAutomatedChecks\x12!\n\x0clint\
    er_rules\x18\x01\x20\x03(\tR\x0blinterRules\x12~\n\rquality_gates\x18\
    \x02\x20\x03(\x0b2Y.kymera_mappings.QualityRatingSystem.QualityEnforceme\
    nt.AutomatedChecks.QualityGatesEntryR\x0cqualityGates\x12%\n\x0eci_integ\
    ration\x18\x03\x20\x01(\x08R\rciIntegration\x12+\n\x11automated_metrics\
    \x18\x04\x20\x03(\tR\x10automatedMetrics\x12\x8a\x01\n\x11enforcement_ru\
    les\x18\x05\x20\x03(\x0b2].kymera_mappings.QualityRatingSystem.QualityEn\
    forcement.AutomatedChecks.EnforcementRulesEntryR\x10enforcementRules\x1a\
    ?\n\x11QualityGatesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1aC\n\x15Enforce\
    mentRulesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05\
    value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\x83\x04\n\x0cManualRevi\
    ew\x12)\n\x10review_checklist\x18\x01\x20\x03(\tR\x0freviewChecklist\x12\
    ~\n\x0ereviewer_notes\x18\x02\x20\x03(\x0b2W.kymera_mappings.QualityRati\
    ngSystem.QualityEnforcement.ManualReview.ReviewerNotesEntryR\rreviewerNo\
    tes\x12#\n\rpeer_reviewed\x18\x03\x20\x01(\x08R\x0cpeerReviewed\x12'\n\
    \x0freview_findings\x18\x04\x20\x03(\tR\x0ereviewFindings\x12x\n\x0cacti\
    on_items\x18\x05\x20\x03(\x0b2U.kymera_mappings.QualityRatingSystem.Qual\
    ityEnforcement.ManualReview.ActionItemsEntryR\x0bactionItems\x1a@\n\x12R\
    eviewerNotesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a>\n\x10ActionItemsEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a\xba\x04\n\x15ContinuousImproveme\
    nt\x12/\n\x13improvement_metrics\x18\x01\x20\x03(\tR\x12improvementMetri\
    cs\x12\x84\x01\n\rfeedback_loop\x18\x02\x20\x03(\x0b2_.kymera_mappings.Q\
    ualityRatingSystem.QualityEnforcement.ContinuousImprovement.FeedbackLoop\
    EntryR\x0cfeedbackLoop\x12+\n\x11trending_positive\x18\x03\x20\x01(\x08R\
    \x10trendingPositive\x12'\n\x0flearning_points\x18\x04\x20\x03(\tR\x0ele\
    arningPoints\x12\x8d\x01\n\x10improvement_plan\x18\x05\x20\x03(\x0b2b.ky\
    mera_mappings.QualityRatingSystem.QualityEnforcement.ContinuousImproveme\
    nt.ImprovementPlanEntryR\x0fimprovementPlan\x1a?\n\x11FeedbackLoopEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\tR\x05value:\x028\x01\x1aB\n\x14ImprovementPlanEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"\xf2\x18\n\x16LanguageQualityPrompts\x1a\xfa\x04\n\
    \x0cKymeraPrompt\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x1c\
    \n\tobjective\x18\x02\x20\x01(\tR\tobjective\x1a\x93\x01\n\x10Modularity\
    Checks\x12.\n\x13unused_refs_removed\x18\x01\x20\x01(\x08R\x11unusedRefs\
    Removed\x12*\n\x11auto_deps_managed\x18\x02\x20\x01(\x08R\x0fautoDepsMan\
    aged\x12#\n\rcleanup_tasks\x18\x03\x20\x03(\tR\x0ccleanupTasks\x1a\x86\
    \x01\n\rErrorHandling\x12!\n\x0ccustom_types\x18\x01\x20\x01(\x08R\x0bcu\
    stomTypes\x12%\n\x0eerror_patterns\x18\x02\x20\x03(\tR\rerrorPatterns\
    \x12+\n\x11graceful_handling\x18\x03\x20\x01(\x08R\x10gracefulHandling\
    \x1a\x91\x01\n\x17PerformanceOptimization\x12#\n\rai_generation\x18\x01\
    \x20\x01(\x08R\x0caiGeneration\x12$\n\roptimizations\x18\x02\x20\x03(\tR\
    \roptimizations\x12+\n\x11hotspot_optimized\x18\x03\x20\x01(\x08R\x10hot\
    spotOptimized\x1a\x82\x01\n\rDocumentation\x12'\n\x0fstructured_docs\x18\
    \x01\x20\x01(\x08R\x0estructuredDocs\x12\x1b\n\tdoc_items\x18\x02\x20\
    \x03(\tR\x08docItems\x12+\n\x11coverage_complete\x18\x03\x20\x01(\x08R\
    \x10coverageComplete\x1a\xc9\x03\n\nRustPrompt\x12\x14\n\x05title\x18\
    \x01\x20\x01(\tR\x05title\x12\x1c\n\tobjective\x18\x02\x20\x01(\tR\tobje\
    ctive\x1a\x86\x01\n\x10ModularityChecks\x12#\n\rcargo_updates\x18\x01\
    \x20\x01(\x08R\x0ccargoUpdates\x12\"\n\x0cdependencies\x18\x02\x20\x03(\
    \tR\x0cdependencies\x12)\n\x10cleanup_complete\x18\x03\x20\x01(\x08R\x0f\
    cleanupComplete\x1a\x86\x01\n\rErrorHandling\x12#\n\rcustom_errors\x18\
    \x01\x20\x01(\x08R\x0ccustomErrors\x12%\n\x0eerror_patterns\x18\x02\x20\
    \x03(\tR\rerrorPatterns\x12)\n\x10clarity_achieved\x18\x03\x20\x01(\x08R\
    \x0fclarityAchieved\x1au\n\x0bPerformance\x12\x1e\n\nbenchmarks\x18\x01\
    \x20\x01(\x08R\nbenchmarks\x12$\n\roptimizations\x18\x02\x20\x03(\tR\rop\
    timizations\x12\x20\n\x0bconcurrency\x18\x03\x20\x01(\x08R\x0bconcurrenc\
    y\x1a\xbc\x03\n\x10TypeScriptPrompt\x12\x14\n\x05title\x18\x01\x20\x01(\
    \tR\x05title\x12\x1c\n\tobjective\x18\x02\x20\x01(\tR\tobjective\x1a|\n\
    \x10DependencyChecks\x12\x1b\n\tnpm_audit\x18\x01\x20\x01(\x08R\x08npmAu\
    dit\x12(\n\x0fvulnerabilities\x18\x02\x20\x03(\tR\x0fvulnerabilities\x12\
    !\n\x0cdeps_updated\x18\x03\x20\x01(\x08R\x0bdepsUpdated\x1a|\n\x0cError\
    Logging\x12\x1e\n\nstructured\x18\x01\x20\x01(\x08R\nstructured\x12\x1f\
    \n\x0berror_types\x18\x02\x20\x03(\tR\nerrorTypes\x12+\n\x11handlers_com\
    plete\x18\x03\x20\x01(\x08R\x10handlersComplete\x1ax\n\x0bPerformance\
    \x12\x1c\n\tprofiling\x18\x01\x20\x01(\x08R\tprofiling\x12$\n\roptimizat\
    ions\x18\x02\x20\x03(\tR\roptimizations\x12%\n\x0ecritical_paths\x18\x03\
    \x20\x01(\x08R\rcriticalPaths\x1a\x8b\x03\n\x0cPythonPrompt\x12\x14\n\
    \x05title\x18\x01\x20\x01(\tR\x05title\x12\x1c\n\tobjective\x18\x02\x20\
    \x01(\tR\tobjective\x1ak\n\x10DependencyChecks\x12\"\n\x0crequirements\
    \x18\x01\x20\x01(\x08R\x0crequirements\x12\x12\n\x04deps\x18\x02\x20\x03\
    (\tR\x04deps\x12\x1f\n\x0bpip_updated\x18\x03\x20\x01(\x08R\npipUpdated\
    \x1ae\n\rErrorHandling\x12\x18\n\x07logging\x18\x01\x20\x01(\x08R\x07log\
    ging\x12\x1a\n\x08handlers\x18\x02\x20\x03(\tR\x08handlers\x12\x1e\n\nex\
    ceptions\x18\x03\x20\x01(\x08R\nexceptions\x1as\n\x0bPerformance\x12\x1c\
    \n\tprofiling\x18\x01\x20\x01(\x08R\tprofiling\x12$\n\roptimizations\x18\
    \x02\x20\x03(\tR\roptimizations\x12\x20\n\x0bexpressions\x18\x03\x20\x01\
    (\x08R\x0bexpressions\x1a\xa8\x03\n\x0eProtobufPrompt\x12\x14\n\x05title\
    \x18\x01\x20\x01(\tR\x05title\x12\x1c\n\tobjective\x18\x02\x20\x01(\tR\t\
    objective\x1ay\n\x0cSchemaChecks\x12\"\n\x0corganization\x18\x01\x20\x01\
    (\x08R\x0corganization\x12\x1a\n\x08messages\x18\x02\x20\x03(\tR\x08mess\
    ages\x12)\n\x10numeric_ordering\x18\x03\x20\x01(\x08R\x0fnumericOrdering\
    \x1am\n\rErrorHandling\x12\x1e\n\nvalidation\x18\x01\x20\x01(\x08R\nvali\
    dation\x12\x1a\n\x08handling\x18\x02\x20\x03(\tR\x08handling\x12\x20\n\
    \x0bdefinitions\x18\x03\x20\x01(\x08R\x0bdefinitions\x1ax\n\x0bPerforman\
    ce\x12\x1a\n\x08repeated\x18\x01\x20\x01(\x08R\x08repeated\x12$\n\rcompa\
    tibility\x18\x02\x20\x03(\tR\rcompatibility\x12'\n\x0ffield_numbering\
    \x18\x03\x20\x01(\x08R\x0efieldNumbering\x1a\xfe\x02\n\x10JavaScriptProm\
    pt\x12\x14\n\x05title\x18\x01\x20\x01(\tR\x05title\x12\x1c\n\tobjective\
    \x18\x02\x20\x01(\tR\tobjective\x1ag\n\x10DependencyChecks\x12\"\n\x0cor\
    ganization\x18\x01\x20\x01(\x08R\x0corganization\x12\x12\n\x04deps\x18\
    \x02\x20\x03(\tR\x04deps\x12\x1b\n\tnpm_audit\x18\x03\x20\x01(\x08R\x08n\
    pmAudit\x1ab\n\rErrorHandling\x12\x1b\n\ttry_catch\x18\x01\x20\x01(\x08R\
    \x08tryCatch\x12\x1a\n\x08handlers\x18\x02\x20\x03(\tR\x08handlers\x12\
    \x18\n\x07logging\x18\x03\x20\x01(\x08R\x07logging\x1ai\n\x0bPerformance\
    \x12\x1c\n\tprofiling\x18\x01\x20\x01(\x08R\tprofiling\x12$\n\roptimizat\
    ions\x18\x02\x20\x03(\tR\roptimizations\x12\x16\n\x06memory\x18\x03\x20\
    \x01(\x08R\x06memory\x1a\x95\x03\n\x0eAgnosticPrompt\x12\x14\n\x05title\
    \x18\x01\x20\x01(\tR\x05title\x12\x1c\n\tobjective\x18\x02\x20\x01(\tR\t\
    objective\x1ao\n\x10ModularityChecks\x12%\n\x0eunused_removed\x18\x01\
    \x20\x01(\x08R\runusedRemoved\x12\x12\n\x04deps\x18\x02\x20\x03(\tR\x04d\
    eps\x12\x20\n\x0blightweight\x18\x03\x20\x01(\x08R\x0blightweight\x1as\n\
    \rErrorHandling\x12$\n\robservability\x18\x01\x20\x01(\x08R\robservabili\
    ty\x12\x1a\n\x08handlers\x18\x02\x20\x03(\tR\x08handlers\x12\x20\n\x0bdi\
    agnostics\x18\x03\x20\x01(\x08R\x0bdiagnostics\x1ai\n\x0bPerformance\x12\
    \x20\n\x0bbottlenecks\x18\x01\x20\x01(\x08R\x0bbottlenecks\x12\x18\n\x07\
    caching\x18\x02\x20\x03(\tR\x07caching\x12\x1e\n\nmonitoring\x18\x03\x20\
    \x01(\x08R\nmonitoring\"\x97#\n\x0fExampleMappings\x12Z\n\rrust_examples\
    \x18\x01\x20\x01(\x0b25.kymera_mappings.ExampleMappings.KymeraToRustExam\
    plesR\x0crustExamples\x12`\n\x0fpython_examples\x18\x02\x20\x01(\x0b27.k\
    ymera_mappings.ExampleMappings.KymeraToPythonExamplesR\x0epythonExamples\
    \x12l\n\x13typescript_examples\x18\x03\x20\x01(\x0b2;.kymera_mappings.Ex\
    ampleMappings.KymeraToTypeScriptExamplesR\x12typescriptExamples\x1a\xff\
    \x04\n\x0fFunctionMapping\x12?\n\x0cbase_mapping\x18\x01\x20\x01(\x0b2\
    \x1c.kymera_mappings.BaseMappingR\x0bbaseMapping\x12T\n\x08examples\x18\
    \x02\x20\x03(\x0b28.kymera_mappings.ExampleMappings.FunctionMapping.Exam\
    pleR\x08examples\x12>\n\x08metadata\x18\x03\x20\x01(\x0b2\".kymera_mappi\
    ngs.ConstructMetadataR\x08metadata\x12N\n\x10numeric_mappings\x18\x04\
    \x20\x03(\x0b2#.kymera_mappings.NumericTypeMappingR\x0fnumericMappings\
    \x12/\n\x13compatibility_notes\x18\x05\x20\x03(\tR\x12compatibilityNotes\
    \x1a\x93\x02\n\x07Example\x12\x1f\n\x0bkymera_code\x18\x01\x20\x01(\tR\n\
    kymeraCode\x12\x1f\n\x0btarget_code\x18\x02\x20\x01(\tR\ntargetCode\x12\
    \x14\n\x05notes\x18\x03\x20\x03(\tR\x05notes\x12o\n\rtype_mappings\x18\
    \x04\x20\x03(\x0b2J.kymera_mappings.ExampleMappings.FunctionMapping.Exam\
    ple.TypeMappingsEntryR\x0ctypeMappings\x1a?\n\x11TypeMappingsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\xdd\x03\n\x0bTypeMapping\x12Y\n\rtype_ex\
    amples\x18\x01\x20\x03(\x0b24.kymera_mappings.ExampleMappings.TypeMappin\
    g.ExampleR\x0ctypeExamples\x12i\n\x0fcommon_patterns\x18\x02\x20\x03(\
    \x0b2@.kymera_mappings.ExampleMappings.TypeMapping.CommonPatternsEntryR\
    \x0ecommonPatterns\x12%\n\x0ebest_practices\x18\x03\x20\x03(\tR\rbestPra\
    ctices\x1a\x9d\x01\n\x07Example\x12\x1f\n\x0bkymera_type\x18\x01\x20\x01\
    (\tR\nkymeraType\x12\x1f\n\x0btarget_type\x18\x02\x20\x01(\tR\ntargetTyp\
    e\x12%\n\x0edirect_mapping\x18\x03\x20\x01(\x08R\rdirectMapping\x12)\n\
    \x10conversion_notes\x18\x04\x20\x03(\tR\x0fconversionNotes\x1aA\n\x13Co\
    mmonPatternsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\xf5\x03\n\x14ErrorH\
    andlingExample\x12d\n\x0eerror_examples\x18\x01\x20\x03(\x0b2=.kymera_ma\
    ppings.ExampleMappings.ErrorHandlingExample.ExampleR\rerrorExamples\x12o\
    \n\x0eerror_patterns\x18\x02\x20\x03(\x0b2H.kymera_mappings.ExampleMappi\
    ngs.ErrorHandlingExample.ErrorPatternsEntryR\rerrorPatterns\x12\x1e\n\ng\
    uidelines\x18\x03\x20\x03(\tR\nguidelines\x1a\xa3\x01\n\x07Example\x12!\
    \n\x0ckymera_error\x18\x01\x20\x01(\tR\x0bkymeraError\x12!\n\x0ctarget_e\
    rror\x18\x02\x20\x01(\tR\x0btargetError\x12+\n\x11handling_strategy\x18\
    \x03\x20\x01(\tR\x10handlingStrategy\x12%\n\x0erecovery_steps\x18\x04\
    \x20\x03(\tR\rrecoverySteps\x1a@\n\x12ErrorPatternsEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05v\
    alue:\x028\x01\x1a\x9e\x04\n\nFFIExample\x12V\n\x0cffi_examples\x18\x01\
    \x20\x03(\x0b23.kymera_mappings.ExampleMappings.FFIExample.ExampleR\x0bf\
    fiExamples\x12I\n\nffi_config\x18\x02\x20\x01(\x0b2*.kymera_mappings.Exa\
    mpleMappings.FFIConfigR\tffiConfig\x12+\n\x11integration_notes\x18\x03\
    \x20\x03(\tR\x10integrationNotes\x1a\xbf\x02\n\x07Example\x12)\n\x10kyme\
    ra_interface\x18\x01\x20\x01(\tR\x0fkymeraInterface\x12+\n\x11foreign_in\
    terface\x18\x02\x20\x01(\tR\x10foreignInterface\x12#\n\rbinding_steps\
    \x18\x03\x20\x03(\tR\x0cbindingSteps\x12s\n\x10type_conversions\x18\x04\
    \x20\x03(\x0b2H.kymera_mappings.ExampleMappings.FFIExample.Example.TypeC\
    onversionsEntryR\x0ftypeConversions\x1aB\n\x14TypeConversionsEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1a\xb4\x01\n\tFFIConfig\x12\x1f\n\x0babi_ve\
    rsion\x18\x01\x20\x01(\tR\nabiVersion\x12/\n\x13supported_languages\x18\
    \x02\x20\x03(\tR\x12supportedLanguages\x122\n\x15safety_checks_enabled\
    \x18\x03\x20\x01(\x08R\x13safetyChecksEnabled\x12!\n\x0cffi_features\x18\
    \x04\x20\x03(\tR\x0bffiFeatures\x1a\x88\x05\n\x0bTestExample\x12Y\n\rtes\
    t_examples\x18\x01\x20\x03(\x0b24.kymera_mappings.ExampleMappings.TestEx\
    ample.ExampleR\x0ctestExamples\x12L\n\x0btest_config\x18\x02\x20\x01(\
    \x0b2+.kymera_mappings.ExampleMappings.TestConfigR\ntestConfig\x12-\n\
    \x12testing_guidelines\x18\x03\x20\x03(\tR\x11testingGuidelines\x1a\xa0\
    \x03\n\x07Example\x12\x1b\n\ttest_case\x18\x01\x20\x01(\tR\x08testCase\
    \x12X\n\x06inputs\x18\x02\x20\x03(\x0b2@.kymera_mappings.ExampleMappings\
    .TestExample.Example.InputsEntryR\x06inputs\x12t\n\x10expected_outputs\
    \x18\x03\x20\x03(\x0b2I.kymera_mappings.ExampleMappings.TestExample.Exam\
    ple.ExpectedOutputsEntryR\x0fexpectedOutputs\x12)\n\x10validation_steps\
    \x18\x04\x20\x03(\tR\x0fvalidationSteps\x1a9\n\x0bInputsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1aB\n\x14ExpectedOutputsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\x1a\x97\x02\n\nTestConfig\x12\x1b\n\ttest_name\x18\x01\x20\x01\
    (\tR\x08testName\x12\x1d\n\ntest_cases\x18\x02\x20\x03(\tR\ttestCases\
    \x12k\n\x10expected_results\x18\x03\x20\x03(\x0b2@.kymera_mappings.Examp\
    leMappings.TestConfig.ExpectedResultsEntryR\x0fexpectedResults\x12\x1c\n\
    \tautomated\x18\x04\x20\x01(\x08R\tautomated\x1aB\n\x14ExpectedResultsEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\x1a\xa6\x02\n\x14KymeraToRustExample\
    s\x12]\n\x11function_examples\x18\x01\x20\x01(\x0b20.kymera_mappings.Exa\
    mpleMappings.FunctionMappingR\x10functionExamples\x12Q\n\rtype_examples\
    \x18\x02\x20\x01(\x0b2,.kymera_mappings.ExampleMappings.TypeMappingR\x0c\
    typeExamples\x12\\\n\x0eerror_examples\x18\x03\x20\x01(\x0b25.kymera_map\
    pings.ExampleMappings.ErrorHandlingExampleR\rerrorExamples\x1a\xa8\x02\n\
    \x16KymeraToPythonExamples\x12]\n\x11function_examples\x18\x01\x20\x01(\
    \x0b20.kymera_mappings.ExampleMappings.FunctionMappingR\x10functionExamp\
    les\x12Q\n\rtype_examples\x18\x02\x20\x01(\x0b2,.kymera_mappings.Example\
    Mappings.TypeMappingR\x0ctypeExamples\x12\\\n\x0eerror_examples\x18\x03\
    \x20\x01(\x0b25.kymera_mappings.ExampleMappings.ErrorHandlingExampleR\re\
    rrorExamples\x1a\xac\x02\n\x1aKymeraToTypeScriptExamples\x12]\n\x11funct\
    ion_examples\x18\x01\x20\x01(\x0b20.kymera_mappings.ExampleMappings.Func\
    tionMappingR\x10functionExamples\x12Q\n\rtype_examples\x18\x02\x20\x01(\
    \x0b2,.kymera_mappings.ExampleMappings.TypeMappingR\x0ctypeExamples\x12\
    \\\n\x0eerror_examples\x18\x03\x20\x01(\x0b25.kymera_mappings.ExampleMap\
    pings.ErrorHandlingExampleR\rerrorExamples*I\n\x11ComputationalCost\x12\
    \x07\n\x03CCU\x10\0\x12\x07\n\x03CCZ\x10\x01\x12\x07\n\x03CCL\x10\x02\
    \x12\x07\n\x03CCM\x10\x03\x12\x07\n\x03CCH\x10\x04\x12\x07\n\x03CCV\x10\
    \x05*W\n\x10MemoryManagement\x12\x07\n\x03MMU\x10\0\x12\n\n\x06MMSTAT\
    \x10\x01\x12\n\n\x06MMSTAK\x10\x02\x12\n\n\x06MMHEAP\x10\x03\x12\n\n\x06\
    MMBRWD\x10\x04\x12\n\n\x06MMSHRD\x10\x05*\xeaJ\n\x0fKymeraConstruct\x12\
    \x1c\n\x18KYMERA_UNKNOWN_CONSTRUCT\x10\0\x12\xca\x01\n\x03des\x10\x01\
    \x1a\xc0\x01\x8a\xb5\x18\xbb\x01\n8\n\x0cImport\x20usage\x12(des\x20core\
    :>{math};\x20|>\x20normal\x20doc\x20<|\x20|>\x20?x\x12/Used\x20to\x20imp\
    ort\x20modules\x20or\x20items\x20within\x20modules.\x12NHidden\x20VERX\
    \x20trigger\x20occurs\x20if\x20you\x20place\x20'|>\x20doc\x20<|\x20|>\
    \x20?x'\x20after\x20the\x20statement.\x12\xd3\x01\n\x05SPACS\x10\x02\x1a\
    \xc7\x01\x8a\xb5\x18\xc2\x01\n=\n\x10Scope\x20resolution\x12)core:>math:\
    >add(5,\x203);\x20|>\x20scoper\x20<|\x20|>\x20?x\x12ANavigates\x20module\
    s/submodules.\x20E.g.,\x20module:>submodule:>function()\x12>Combine\x20'\
    |>\x20scoper\x20<|\x20|>\x20?x'\x20to\x20secretly\x20trace\x20calls\x20v\
    ia\x20VERX.\x12\xf1\x01\n\x05forma\x10\x03\x1a\xe5\x01\x8a\xb5\x18\xe0\
    \x01\nU\n\x14Structure\x20definition\x12=forma\x20Persona\x20{\x20nombre\
    :\x20Strng,\x20edad:\x20i32\x20}\x20|>\x20struct\x20<|\x20|>\x20?x\x12<D\
    efines\x20a\x20user\x20type\x20with\x20fields.\x20Similar\x20to\x20Rust'\
    s\x20'struct'.\x12IIf\x20'|>\x20struct\x20<|\x20|>\x20?x'\x20is\x20prese\
    nt,\x20triggers\x20memory\x20layout\x20debug\x20in\x20VERX.\x12\xea\x01\
    \n\x04enum\x10\x04\x1a\xdf\x01\x8a\xb5\x18\xda\x01\nL\n\x16Enumeration\
    \x20definition\x122enum\x20Color\x20{\x20Rojo,\x20Verde,\x20Azul\x20}\
    \x20|>\x20color\x20<|\x20|>\x20?x\x12CDefines\x20a\x20set\x20of\x20varia\
    nts.\x20Equivalent\x20to\x20'enum'\x20in\x20other\x20languages.\x12EHidd\
    en\x20command\x20'|>\x20color\x20<|\x20|>\x20?x'\x20does\x20completeness\
    \x20checks\x20via\x20VERX.\x12\xee\x01\n\x03imp\x10\x05\x1a\xe4\x01\x8a\
    \xb5\x18\xdf\x01\n_\n\x14Implementation\x20block\x12Gimp\x20Persona\x20{\
    \x20fnc\x20get_edad(&soy)\x20->\x20i32\x20{\x20soy.edad\x20}\x20}\x20|>\
    \x20impl\x20<|\x20|>\x20?x\x12=Similar\x20to\x20Rust's\x20'impl'\x20bloc\
    ks\x20for\x20adding\x20methods\x20to\x20a\x20type.\x12=Use\x20'|>\x20imp\
    l\x20<|\x20|>\x20?x'\x20to\x20get\x20method\x20flow\x20analysis\x20from\
    \x20VERX.\x12\xdf\x01\n\x03fnc\x10\x06\x1a\xd5\x01\x8a\xb5\x18\xd0\x01\n\
    P\n\x13Function\x20definition\x129fnc\x20add(a:\x20i32,\x20b:\x20i32)\
    \x20->\x20i32\x20{\x20a\x20+\x20b\x20}\x20|>\x20func\x20<|\x20|>\x20?x\
    \x128Defines\x20a\x20function\x20with\x20optional\x20return\x20type\x20a\
    nnotation.\x12BHidden\x20trigger:\x20'|>\x20func\x20<|\x20|>\x20?x'\x20f\
    or\x20control-flow\x20check\x20in\x20VERX.\x12\xda\x01\n\x03soy\x10\x07\
    \x1a\xd0\x01\x8a\xb5\x18\xcb\x01\ne\n\x14Self\x20reference\x20usage\x12M\
    fnc\x20set_name(soy,\x20new_name:\x20Strng)\x20{\x20soy.pingu\x20=\x20ne\
    w_name;\x20}\x20|>\x20self\x20<|\x20|>\x20?x\x12*Acts\x20like\x20'this'\
    \x20or\x20'self'\x20in\x20other\x20langs.\x126Use\x20'|>\x20self\x20<|\
    \x20|>\x20?x'\x20to\x20verify\x20references\x20with\x20VERX.\x12\xd6\x01\
    \n\x03SNC\x10\x08\x1a\xcc\x01\x8a\xb5\x18\xc7\x01\n>\n\x10Synchronous\
    \x20call\x12*sn>\x20some_sync_function();\x20|>\x20sync\x20<|\x20|>\x20?\
    x\x12<For\x20explicitly\x20synchronous\x20calls,\x20blocking\x20until\
    \x20completion.\x12GHidden\x20pattern\x20'|>\x20sync\x20<|\x20|>\x20?x'\
    \x20can\x20check\x20blocking\x20overhead\x20via\x20VERX.\x12\xd0\x01\n\
    \x03XNC\x10\t\x1a\xc6\x01\x8a\xb5\x18\xc1\x01\n>\n\nAsync\x20call\x120xn\
    >\x20fetch_data_from_network();\x20|>\x20async\x20<|\x20|>\x20?x\x12FInv\
    okes\x20asynchronous\x20operations,\x20returning\x20future/promise-like\
    \x20values.\x127Use\x20'|>\x20async\x20<|\x20|>\x20?x'\x20to\x20trace\
    \x20concurrency\x20with\x20VERX.\x12\xd5\x01\n\x04SPRO\x10\n\x1a\xca\x01\
    \x8a\xb5\x18\xc5\x01\n1\n\x0bAwait\x20usage\x12\"w>?\x20future_value;\
    \x20|>\x20wait\x20<|\x20|>\x20?x\x12OSimilar\x20to\x20'await'\x20in\x20R\
    ust/JS/Python\x20async\x20code.\x20Suspends\x20until\x20value\x20is\x20r\
    eady.\x12?Combine\x20'|>\x20wait\x20<|\x20|>\x20?x'\x20to\x20gather\x20s\
    cheduling\x20info\x20from\x20VERX.\x12\xef\x01\n\x03Res\x10\x0b\x1a\xe5\
    \x01\x8a\xb5\x18\xe0\x01\n]\n\x11Result\x20type\x20usage\x12Hfnc\x20divi\
    de(a:\x20i32,\x20b:\x20i32)\x20->\x20Res<i32,\x20Strng>\x20{\x20...\x20}\
    \x20|>\x20result\x20<|\x20|>\x20?x\x126Wraps\x20success/failure.\x20Simi\
    lar\x20to\x20Rust's\x20Result<T,\x20E>.\x12GHidden\x20pattern\x20'|>\x20\
    result\x20<|\x20|>\x20?x'\x20triggers\x20error\x20path\x20checks\x20in\
    \x20VERX.\x12\xb3\x01\n\x03djq\x10\x0c\x1a\xa9\x01\x8a\xb5\x18\xa4\x01\n\
    7\n\x14Variable\x20declaration\x12\x1fdjq\x20count\x20=\x2010;\x20|>\x20\
    var\x20<|\x20|>\x20?x\x124Used\x20to\x20declare\x20variables.\x20Similar\
    \x20to\x20'let'\x20in\x20Rust.\x123Add\x20'|>\x20var\x20<|\x20|>\x20?x'\
    \x20for\x20auto-scope\x20debug\x20in\x20VERX.\x12\xcd\x01\n\x03ret\x10\r\
    \x1a\xc3\x01\x8a\xb5\x18\xbe\x01\n0\n\x0cReturn\x20usage\x12\x20ret\x20s\
    ome_value;\x20|>\x20exit\x20<|\x20|>\x20?x\x12KExits\x20current\x20funct\
    ion\x20with\x20a\x20value.\x20Similar\x20to\x20'return'\x20in\x20many\
    \x20languages.\x12=Use\x20'|>\x20exit\x20<|\x20|>\x20?x'\x20to\x20see\
    \x20function-end\x20analytics\x20in\x20VERX.\x12\xeb\x01\n\x03REV\x10\
    \x0e\x1a\xe1\x01\x8a\xb5\x18\xdc\x01\nQ\n\x11Error\x20propagation\x12<at\
    e\x20{\x20operation()?;\x20}\x20rev\x20err\x20{\x20ret\x20err;\x20}\x20|\
    >\x20error\x20<|\x20|>\x20?x\x12<Like\x20Rust's\x20'?'\x20for\x20error\
    \x20propagation\x20or\x20custom\x20error\x20block.\x12IHidden\x20call\
    \x20'|>\x20error\x20<|\x20|>\x20?x'\x20triggers\x20advanced\x20error\x20\
    analysis\x20in\x20VERX.\x12\xd1\x01\n\x03wyo\x10\x0f\x1a\xc7\x01\x8a\xb5\
    \x18\xc2\x01\nC\n\x10While\x20loop\x20usage\x12/wyo\x20count\x20<\x2010\
    \x20{\x20count\x20+=\x201;\x20}\x20|>\x20loop\x20<|\x20|>\x20?x\x125Repe\
    ats\x20until\x20condition\x20is\x20false.\x20Similar\x20to\x20'while'.\
    \x12DEmbed\x20'|>\x20loop\x20<|\x20|>\x20?x'\x20to\x20measure\x20iterati\
    on\x20performance\x20with\x20VERX.\x12\xe4\x01\n\x03ate\x10\x10\x1a\xda\
    \x01\x8a\xb5\x18\xd5\x01\nS\n\x0fTry/catch\x20usage\x12@ate\x20{\x20risk\
    y()\x20}\x20rev\x20e\x20{\x20prnt!(\"Error:\x20\",\x20e);\x20}\x20|>\x20\
    catch\x20<|\x20|>\x20?x\x12>Handles\x20exceptions\x20or\x20errors\x20in\
    \x20a\x20block.\x20Similar\x20to\x20try/catch.\x12>Hidden\x20'|>\x20catc\
    h\x20<|\x20|>\x20?x'\x20can\x20do\x20root-cause\x20analysis\x20in\x20VER\
    X.\x12\xcc\x01\n\x03MTH\x10\x11\x1a\xc2\x01\x8a\xb5\x18\xbd\x01\nU\n\x0b\
    Match\x20usage\x12Fm>\x20value\x20{\x200\x20=>\x20prnt!(\"Zero\"),\x20_\
    \x20=>\x20prnt!(\"Other\")\x20}\x20|>\x20match\x20<|\x20|>\x20?x\x12)Pat\
    tern\x20matching,\x20akin\x20to\x20Rust's\x20'match'.\x129Use\x20'|>\x20\
    match\x20<|\x20|>\x20?x'\x20for\x20completeness\x20checks\x20via\x20VERX\
    .\x12\xda\x01\n\x03SPA\x10\x12\x1a\xd0\x01\x8a\xb5\x18\xcb\x01\nH\n\x0eF\
    or\x20loop\x20usage\x1264>\x20item\x20in\x20collection\x20{\x20prnt!(ite\
    m);\x20}\x20|>\x20for\x20<|\x20|>\x20?x\x127Iterates\x20over\x20sequence\
    s.\x20Similar\x20to\x20'for'\x20or\x20'foreach'.\x12FHidden\x20'|>\x20fo\
    r\x20<|\x20|>\x20?x'\x20triggers\x20iteration\x20and\x20memory\x20checks\
    \x20in\x20VERX.\x12\xce\x01\n\x04Optn\x10\x13\x1a\xc3\x01\x8a\xb5\x18\
    \xbe\x01\nN\n\x0cOption\x20usage\x12>fnc\x20find_user(id:\x20i32)\x20->\
    \x20Optn<User>\x20{\x20...\x20}\x20|>\x20maybe\x20<|\x20|>\x20?x\x122Wra\
    ps\x20an\x20optional\x20value,\x20akin\x20to\x20Rust's\x20Option<T>.\x12\
    8Use\x20'|>\x20maybe\x20<|\x20|>\x20?x'\x20for\x20nil-safety\x20analysis\
    \x20in\x20VERX.\x12\xe9\x01\n\x05Stilo\x10\x14\x1a\xdd\x01\x8a\xb5\x18\
    \xd8\x01\nT\n\x1cImmutable\x20string\x20slice\x20usage\x124fnc\x20read_s\
    lice(txt:\x20Stilo)\x20{\x20...\x20}\x20|>\x20slice\x20<|\x20|>\x20?x\
    \x12BSimilar\x20to\x20'&str'\x20in\x20Rust:\x20reference\x20to\x20an\x20\
    immutable\x20string\x20slice.\x12<Hidden\x20'|>\x20slice\x20<|\x20|>\x20\
    ?x'\x20can\x20do\x20lifetime\x20tracking\x20in\x20VERX.\x12\xcc\x01\n\
    \x05Strng\x10\x15\x1a\xc0\x01\x8a\xb5\x18\xbb\x01\nF\n\x14Mutable\x20str\
    ing\x20usage\x12.djq\x20greeting:\x20Strng\x20=\x20\"Hello\";\x20|>\x20s\
    tr\x20<|\x20|>\x20?x\x127Owned,\x20dynamically\x20growable\x20string.\
    \x20Like\x20Rust's\x20String.\x128Embed\x20'|>\x20str\x20<|\x20|>\x20?x'\
    \x20to\x20check\x20memory\x20usage\x20with\x20VERX.\x12\xe3\x01\n\x04MUT\
    A\x10\x16\x1a\xd8\x01\x8a\xb5\x18\xd3\x01\nS\n\x15Mutability\x20annotati\
    on\x12:fnc\x20increment(~count:\x20i32)\x20{\x20count\x20+=\x201;\x20}\
    \x20|>\x20mut\x20<|\x20|>\x20?x\x129Marks\x20parameter\x20or\x20variable\
    \x20as\x20mutable.\x20Similar\x20to\x20'mut'.\x12AHidden\x20'|>\x20mut\
    \x20<|\x20|>\x20?x'\x20triggers\x20mutation-safety\x20checks\x20in\x20VE\
    RX.\x12\xef\x01\n\x04NMUT\x10\x17\x1a\xe4\x01\x8a\xb5\x18\xdf\x01\nQ\n\
    \x13Immutable\x20reference\x12:fnc\x20print_value(&val:\x20i32)\x20{\x20\
    prnt!(val);\x20}\x20|>\x20imm\x20<|\x20|>\x20?x\x12AMarks\x20parameter\
    \x20or\x20variable\x20as\x20an\x20immutable\x20reference.\x20Like\x20'&T\
    '.\x12GThe\x20'|>\x20imm\x20<|\x20|>\x20?x'\x20pattern\x20triggers\x20re\
    ference-safety\x20checks\x20in\x20VERX.\x12\xd2\x01\n\x04IDIT\x10\x18\
    \x1a\xc7\x01\x8a\xb5\x18\xc2\x01\n9\n\x10Identifier\x20usage\x12%djq\x20\
    <myVar?>\x20=\x20100;\x20|>\x20ident\x20<|\x20|>\x20?x\x12>Custom\x20syn\
    tax\x20for\x20an\x20identifier,\x20for\x20pattern-based\x20references.\
    \x12EHidden\x20'|>\x20ident\x20<|\x20|>\x20?x'\x20used\x20to\x20confirm\
    \x20naming\x20collisions\x20in\x20VERX.\x12\xec\x01\n\x03IFZ\x10\x19\x1a\
    \xe2\x01\x8a\xb5\x18\xdd\x01\nT\n\x14Interface\x20definition\x12<[=-]\
    \x20Logger\x20{\x20fnc\x20log(&soy,\x20msg:\x20Strng);\x20}\x20|>\x20ifa\
    ce\x20<|\x20|>\x20?x\x12FDeclares\x20a\x20contract\x20of\x20methods/prop\
    erties.\x20Like\x20an\x20interface\x20or\x20trait.\x12=Use\x20'|>\x20ifa\
    ce\x20<|\x20|>\x20?x'\x20for\x20method\x20compliance\x20checks\x20in\x20\
    VERX.\x12\xa9\x01\n\x02i8\x10\x1a\x1a\xa0\x01\x8a\xb5\x18\x9b\x01\n8\n\
    \x08i8\x20usage\x12,djq\x20small_num:\x20i8\x20=\x20127;\x20|>\x20numeri\
    c\x20<|\x20|>\x20?x\x12&Signed\x208-bit\x20integer\x20range:\x20-128..12\
    7.\x127Hidden\x20'|>\x20numeric\x20<|\x20|>\x20?x'\x20checks\x20overflow\
    \x20with\x20VERX.\x12\xb3\x01\n\x03i16\x10\x1b\x1a\xa9\x01\x8a\xb5\x18\
    \xa4\x01\n=\n\ti16\x20usage\x120djq\x20medium_num:\x20i16\x20=\x2030000;\
    \x20|>\x20numeric\x20<|\x20|>\x20?x\x12+Signed\x2016-bit\x20integer\x20r\
    ange:\x20-32768..32767.\x126Use\x20'|>\x20numeric\x20<|\x20|>\x20?x'\x20\
    for\x20overflow\x20checks\x20in\x20VERX.\x12\xc1\x01\n\x03i32\x10\x1c\
    \x1a\xb7\x01\x8a\xb5\x18\xb2\x01\n?\n\ti32\x20usage\x122djq\x20regular_n\
    um:\x20i32\x20=\x20100000;\x20|>\x20numeric\x20<|\x20|>\x20?x\x123Signed\
    \x2032-bit\x20integer.\x20Common\x20default\x20integer\x20type.\x12:Hidd\
    en\x20'|>\x20numeric\x20<|\x20|>\x20?x'\x20for\x20integer\x20analysis\
    \x20in\x20VERX.\x12\xd1\x01\n\x03i64\x10\x1d\x1a\xc7\x01\x8a\xb5\x18\xc2\
    \x01\nD\n\ti64\x20usage\x127djq\x20large_num:\x20i64\x20=\x2012345678901\
    23;\x20|>\x20numeric\x20<|\x20|>\x20?x\x12-Signed\x2064-bit\x20integer.\
    \x20Good\x20for\x20large\x20ranges.\x12KCombining\x20'|>\x20numeric\x20<\
    |\x20|>\x20?x'\x20can\x20track\x20large\x20integer\x20boundaries\x20in\
    \x20VERX.\x12\xd8\x01\n\x04i128\x10\x1e\x1a\xcd\x01\x8a\xb5\x18\xc8\x01\
    \n_\n\ni128\x20usage\x12Qdjq\x20huge_num:\x20i128\x20=\x2034028236692093\
    8463463374607431768211455;\x20|>\x20numeric\x20<|\x20|>\x20?x\x12.Signed\
    \x20128-bit\x20integer,\x20extremely\x20large\x20range.\x125Use\x20'|>\
    \x20numeric\x20<|\x20|>\x20?x'\x20for\x20big-int\x20checks\x20in\x20VERX\
    .\x12\xd5\x01\n\x04ISZE\x10\x1f\x1a\xca\x01\x8a\xb5\x18\xc5\x01\n8\n\tis\
    #\x20usage\x12+djq\x20arch_num:\x20is#\x20=\x2042;\x20|>\x20numeric\x20<\
    |\x20|>\x20?x\x12DSigned\x20integer\x20sized\x20by\x20the\x20underlying\
    \x20architecture\x20(32\x20or\x2064\x20bits).\x12CHidden\x20'|>\x20numer\
    ic\x20<|\x20|>\x20?x'\x20checks\x20platform\x20compatibility\x20in\x20VE\
    RX.\x12\xb1\x01\n\x02u8\x10\x20\x1a\xa8\x01\x8a\xb5\x18\xa3\x01\n=\n\x08\
    u8\x20usage\x121djq\x20small_unsigned:\x20u8\x20=\x20255;\x20|>\x20numer\
    ic\x20<|\x20|>\x20?x\x12\x1eUnsigned\x208-bit.\x20Range:\x200..255.\x12B\
    Hidden\x20'|>\x20numeric\x20<|\x20|>\x20?x'\x20triggers\x20boundary\x20v\
    alidation\x20in\x20VERX.\x12\xae\x01\n\x03u16\x10!\x1a\xa4\x01\x8a\xb5\
    \x18\x9f\x01\nB\n\tu16\x20usage\x125djq\x20medium_unsigned:\x20u16\x20=\
    \x2065535;\x20|>\x20numeric\x20<|\x20|>\x20?x\x12!Unsigned\x2016-bit.\
    \x20Range:\x200..65535.\x126Use\x20'|>\x20numeric\x20<|\x20|>\x20?x'\x20\
    for\x20overflow\x20checks\x20in\x20VERX.\x12\xb8\x01\n\x03u32\x10\"\x1a\
    \xae\x01\x8a\xb5\x18\xa9\x01\nD\n\tu32\x20usage\x127djq\x20reg_unsigned:\
    \x20u32\x20=\x204000000000;\x20|>\x20numeric\x20<|\x20|>\x20?x\x12&Unsig\
    ned\x2032-bit.\x20Range:\x200..4294967295.\x129Hidden\x20'|>\x20numeric\
    \x20<|\x20|>\x20?x'\x20for\x20boundary\x20checks\x20in\x20VERX.\x12\xc6\
    \x01\n\x03u64\x10#\x1a\xbc\x01\x8a\xb5\x18\xb7\x01\nP\n\tu64\x20usage\
    \x12Cdjq\x20large_unsigned:\x20u64\x20=\x2018446744073709551615;\x20|>\
    \x20numeric\x20<|\x20|>\x20?x\x12\"Unsigned\x2064-bit.\x20Range:\x200..2\
    ^64-1.\x12?Combine\x20'|>\x20numeric\x20<|\x20|>\x20?x'\x20for\x20large\
    \x20range\x20analysis\x20in\x20VERX.\x12\xde\x01\n\x04u128\x10$\x1a\xd3\
    \x01\x8a\xb5\x18\xce\x01\nd\n\nu128\x20usage\x12Vdjq\x20huge_unsigned:\
    \x20u128\x20=\x20340282366920938463463374607431768211455;\x20|>\x20numer\
    ic\x20<|\x20|>\x20?x\x12(Unsigned\x20128-bit.\x20Extremely\x20large\x20r\
    ange.\x12<Use\x20'|>\x20numeric\x20<|\x20|>\x20?x'\x20for\x20big-range\
    \x20validations\x20in\x20VERX.\x12\xcb\x01\n\x04USZE\x10%\x1a\xc0\x01\
    \x8a\xb5\x18\xbb\x01\n8\n\tus#\x20usage\x12+djq\x20arch_uns:\x20us#\x20=\
    \x2042;\x20|>\x20numeric\x20<|\x20|>\x20?x\x12:Unsigned\x20integer\x20si\
    zed\x20by\x20architecture.\x20Like\x20Rust's\x20usize.\x12CHidden\x20'|>\
    \x20numeric\x20<|\x20|>\x20?x'\x20checks\x20pointer-size\x20alignment\
    \x20in\x20VERX.\x12\xab\x01\n\x03f32\x10&\x1a\xa1\x01\x8a\xb5\x18\x9c\
    \x01\n9\n\tf32\x20usage\x12,djq\x20float_val:\x20f32\x20=\x203.14;\x20|>\
    \x20float\x20<|\x20|>\x20?x\x12\x1f32-bit\x20IEEE\x20754\x20floating\x20\
    point.\x12>Using\x20'|>\x20float\x20<|\x20|>\x20?x'\x20triggers\x20preci\
    sion\x20analysis\x20in\x20VERX.\x12\xba\x01\n\x03f64\x10'\x1a\xb0\x01\
    \x8a\xb5\x18\xab\x01\nC\n\tf64\x20usage\x126djq\x20double_val:\x20f64\
    \x20=\x203.14159265359;\x20|>\x20float\x20<|\x20|>\x20?x\x12\x1f64-bit\
    \x20IEEE\x20754\x20floating\x20point.\x12CHidden\x20'|>\x20float\x20<|\
    \x20|>\x20?x'\x20can\x20track\x20floating\x20inaccuracies\x20in\x20VERX.\
    \x12\xad\x01\n\x04PRNT\x10(\x1a\xa2\x01\x8a\xb5\x18\x9d\x01\n5\n\x0bPrin\
    t\x20usage\x12&Prnt!(\"Hello\x20Kymera\");\x20|>\x20log\x20<|\x20|>\x20?\
    x\x12(Basic\x20print\x20macro\x20for\x20logging\x20to\x20stdout.\x12:Use\
    \x20'|>\x20log\x20<|\x20|>\x20?x'\x20to\x20gather\x20console\x20analytic\
    s\x20in\x20VERX.\x12\xfd\x01\n\x03CMT\x10)\x1a\xf3\x01\x8a\xb5\x18\xee\
    \x01\n?\n\x13Single\x20line\x20comment\x12(|>\x20This\x20is\x20a\x20comm\
    ent\x20line,\x20no\x20closing\x20<|\x12ZUsed\x20for\x20single-line\x20co\
    mmentary.\x20If\x20you\x20append\x20'|>\x20?x'\x20at\x20the\x20end,\x20t\
    riggers\x20debug\x20context.\x12OOften\x20used\x20for\x20quick\x20notes\
    \x20or\x20hidden\x20triggers\x20if\x20combined\x20with\x20<|\x20at\x20an\
    y\x20point.\x12\xbd\x01\n\x03BMT\x10*\x1a\xb3\x01\x8a\xb5\x18\xae\x01\nB\
    \n\rBlock\x20comment\x121|>\x20This\x20is\x20a\x20multiline\x20comment..\
    .\\n\x20...closing\x20<|\x12#Encloses\x20comments\x20in\x20'|>'\x20and\
    \x20'<|'.\x12CCombine\x20'|>\x20comment\x20<|\x20|>\x20?x'\x20to\x20stea\
    lthily\x20activate\x20VERX\x20analysis.\x12\xbc\x01\n\x03DMT\x10+\x1a\
    \xb2\x01\x8a\xb5\x18\xad\x01\n0\n\x11Doc\x20comment\x20usage\x12\x1b|D>\
    \x20This\x20function\x20does\x20X\x20<|\x120Used\x20for\x20generating\
    \x20documentation\x20automatically.\x12GPlacing\x20'|D>\x20doc\x20<|\x20\
    |>\x20?x'\x20anywhere\x20toggles\x20doc-based\x20analysis\x20in\x20VERX.\
    \x12\xe2\x01\n\x04AICG\x10,\x1a\xd7\x01\x8a\xb5\x18\xd2\x01\nG\n\x18AI\
    \x20code\x20generation\x20usage\x12+|A>\x20generate\x20sorting\x20fn\x20\
    <I|\x20|>\x20gen\x20<|\x20|>\x20?x\x127Harnesses\x20AI\x20to\x20generate\
    \x20boilerplate\x20or\x20entire\x20methods.\x12NThe\x20snippet\x20'|>\
    \x20gen\x20<|\x20|>\x20?x'\x20triggers\x20advanced\x20code-generation\
    \x20debug\x20in\x20VERX.\x12\xc7\x01\n\x04VERX\x10-\x1a\xbc\x01\x8a\xb5\
    \x18\xb7\x01\n(\n\x11VERX\x20direct\x20usage\x12\x13<v?x>\x20debug_comma\
    nd\x12LExplicit\x20AI\x20debugger\x20invocation.\x20Typically\x20hidden\
    \x20behind\x20the\x20comment\x20combos.\x12=Use\x20directly\x20as\x20'<v\
    ?x>'\x20or\x20stealthily\x20with\x20'|>\x20...\x20<|\x20|>\x20?x'.*\xa7\
    \x05\n\rRustConstruct\x12\x1a\n\x16RUST_UNKNOWN_CONSTRUCT\x10\0\x12\x0c\
    \n\x08RUST_USE\x10\x01\x12\x0e\n\nRUST_SCOPE\x10\x02\x12\x0f\n\x0bRUST_S\
    TRUCT\x10\x03\x12\r\n\tRUST_ENUM\x10\x04\x12\r\n\tRUST_IMPL\x10\x05\x12\
    \x0f\n\x0bRUST_METHOD\x10\x06\x12\x0b\n\x07RUST_FN\x10\x07\x12\x0e\n\nRU\
    ST_AWAIT\x10\x08\x12\x0c\n\x08RUST_LET\x10\t\x12\x0f\n\x0bRUST_RESULT\
    \x10\n\x12\x0f\n\x0bRUST_RETURN\x10\x0b\x12\x0e\n\nRUST_CATCH\x10\x0c\
    \x12\r\n\tRUST_SELF\x10\r\x12\x0e\n\nRUST_WHILE\x10\x0e\x12\x0c\n\x08RUS\
    T_TRY\x10\x0f\x12\x0e\n\nRUST_MATCH\x10\x10\x12\x0c\n\x08RUST_FOR\x10\
    \x11\x12\x0e\n\nRUST_TUPLE\x10\x12\x12\x0f\n\x0bRUST_OPTION\x10\x13\x12\
    \x0c\n\x08RUST_STR\x10\x14\x12\x0f\n\x0bRUST_STRING\x10\x15\x12\x0b\n\
    \x07RUST_I8\x10\x16\x12\x0c\n\x08RUST_I16\x10\x17\x12\x0c\n\x08RUST_I32\
    \x10\x18\x12\x0c\n\x08RUST_I64\x10\x19\x12\r\n\tRUST_I128\x10\x1a\x12\
    \x0e\n\nRUST_ISIZE\x10\x1b\x12\x0b\n\x07RUST_U8\x10\x1c\x12\x0c\n\x08RUS\
    T_U16\x10\x1d\x12\x0c\n\x08RUST_U32\x10\x1e\x12\x0c\n\x08RUST_U64\x10\
    \x1f\x12\r\n\tRUST_U128\x10\x20\x12\x0e\n\nRUST_USIZE\x10!\x12\x0c\n\x08\
    RUST_F32\x10\"\x12\x0c\n\x08RUST_F64\x10#\x12\x0e\n\nRUST_IDENT\x10$\x12\
    \x0e\n\nRUST_TRAIT\x10%\x12\x0c\n\x08RUST_MUT\x10&\x12\x10\n\x0cRUST_COM\
    MENT\x10'\x12\x16\n\x12RUST_BLOCK_COMMENT\x10(\x12\x14\n\x10RUST_DOC_COM\
    MENT\x10)*\xef\x04\n\x0fPythonConstruct\x12\x1c\n\x18PYTHON_UNKNOWN_CONS\
    TRUCT\x10\0\x12\x11\n\rPYTHON_IMPORT\x10\x01\x12\x0e\n\nPYTHON_DOT\x10\
    \x02\x12\x10\n\x0cPYTHON_CLASS\x10\x03\x12\x0f\n\x0bPYTHON_ENUM\x10\x04\
    \x12\x14\n\x10PYTHON_DECORATOR\x10\x05\x12\x11\n\rPYTHON_METHOD\x10\x06\
    \x12\x0e\n\nPYTHON_DEF\x10\x07\x12\x10\n\x0cPYTHON_AWAIT\x10\x08\x12\x11\
    \n\rPYTHON_ASSIGN\x10\t\x12\x13\n\x0fPYTHON_OPTIONAL\x10\n\x12\x11\n\rPY\
    THON_RETURN\x10\x0b\x12\x11\n\rPYTHON_EXCEPT\x10\x0c\x12\x0f\n\x0bPYTHON\
    _SELF\x10\r\x12\x10\n\x0cPYTHON_WHILE\x10\x0e\x12\x0e\n\nPYTHON_TRY\x10\
    \x0f\x12\x10\n\x0cPYTHON_MATCH\x10\x10\x12\x0e\n\nPYTHON_FOR\x10\x11\x12\
    \x10\n\x0cPYTHON_TUPLE\x10\x12\x12\x18\n\x14PYTHON_OPTIONAL_TYPE\x10\x13\
    \x12\x0e\n\nPYTHON_STR\x10\x14\x12\x11\n\rPYTHON_STRING\x10\x15\x12\x0e\
    \n\nPYTHON_INT\x10\x16\x12\x10\n\x0cPYTHON_FLOAT\x10\x17\x12\x15\n\x11PY\
    THON_IDENTIFIER\x10$\x12\x13\n\x0fPYTHON_PROTOCOL\x10%\x12\x10\n\x0cPYTH\
    ON_FINAL\x10&\x12\x12\n\x0ePYTHON_COMMENT\x10'\x12\x18\n\x14PYTHON_BLOCK\
    _COMMENT\x10(\x12\x14\n\x10PYTHON_DOCSTRING\x10)\x12\x17\n\x13PYTHON_TYP\
    E_COMMENT\x10**\x80\x04\n\x0bTSConstruct\x12\x18\n\x14TS_UNKNOWN_CONSTRU\
    CT\x10\0\x12\r\n\tTS_IMPORT\x10\x01\x12\x10\n\x0cTS_NAMESPACE\x10\x02\
    \x12\x0c\n\x08TS_CLASS\x10\x03\x12\x0b\n\x07TS_ENUM\x10\x04\x12\x0b\n\
    \x07TS_IMPL\x10\x05\x12\r\n\tTS_METHOD\x10\x06\x12\x0f\n\x0bTS_FUNCTION\
    \x10\x07\x12\x0c\n\x08TS_AWAIT\x10\x08\x12\n\n\x06TS_LET\x10\t\x12\x0e\n\
    \nTS_PROMISE\x10\n\x12\r\n\tTS_RETURN\x10\x0b\x12\x0c\n\x08TS_CATCH\x10\
    \x0c\x12\x0b\n\x07TS_THIS\x10\r\x12\x0c\n\x08TS_WHILE\x10\x0e\x12\n\n\
    \x06TS_TRY\x10\x0f\x12\r\n\tTS_SWITCH\x10\x10\x12\n\n\x06TS_FOR\x10\x11\
    \x12\x0c\n\x08TS_TUPLE\x10\x12\x12\x0f\n\x0bTS_OPTIONAL\x10\x13\x12\x15\
    \n\x11TS_STRING_LITERAL\x10\x14\x12\r\n\tTS_STRING\x10\x15\x12\r\n\tTS_N\
    UMBER\x10\x16\x12\r\n\tTS_BIGINT\x10\x17\x12\x11\n\rTS_IDENTIFIER\x10$\
    \x12\x10\n\x0cTS_INTERFACE\x10%\x12\x0f\n\x0bTS_READONLY\x10&\x12\x0e\n\
    \nTS_COMMENT\x10'\x12\x14\n\x10TS_BLOCK_COMMENT\x10(\x12\x12\n\x0eTS_DOC\
    _COMMENT\x10)\x12\x12\n\x0eTS_JSX_COMMENT\x10**\xec\x03\n\x0bJSConstruct\
    \x12\x18\n\x14JS_UNKNOWN_CONSTRUCT\x10\0\x12\r\n\tJS_IMPORT\x10\x01\x12\
    \n\n\x06JS_DOT\x10\x02\x12\x0c\n\x08JS_CLASS\x10\x03\x12\r\n\tJS_OBJECT\
    \x10\x04\x12\x0e\n\nJS_EXTENDS\x10\x05\x12\r\n\tJS_METHOD\x10\x06\x12\
    \x0f\n\x0bJS_FUNCTION\x10\x07\x12\x0c\n\x08JS_AWAIT\x10\x08\x12\n\n\x06J\
    S_LET\x10\t\x12\x0e\n\nJS_PROMISE\x10\n\x12\r\n\tJS_RETURN\x10\x0b\x12\
    \x0c\n\x08JS_CATCH\x10\x0c\x12\x0b\n\x07JS_THIS\x10\r\x12\x0c\n\x08JS_WH\
    ILE\x10\x0e\x12\n\n\x06JS_TRY\x10\x0f\x12\r\n\tJS_SWITCH\x10\x10\x12\n\n\
    \x06JS_FOR\x10\x11\x12\x0c\n\x08JS_ARRAY\x10\x12\x12\x0f\n\x0bJS_NULLABL\
    E\x10\x13\x12\x17\n\x13JS_TEMPLATE_LITERAL\x10\x14\x12\r\n\tJS_STRING\
    \x10\x15\x12\r\n\tJS_NUMBER\x10\x16\x12\r\n\tJS_BIGINT\x10\x17\x12\x11\n\
    \rJS_IDENTIFIER\x10$\x12\x0c\n\x08JS_CONST\x10&\x12\x0e\n\nJS_COMMENT\
    \x10'\x12\x14\n\x10JS_BLOCK_COMMENT\x10(\x12\x12\n\x0eJS_DOC_COMMENT\x10\
    )\x12\x12\n\x0eJS_JSX_COMMENT\x10**\xf0\x04\n\rJavaConstruct\x12\x1a\n\
    \x16JAVA_UNKNOWN_CONSTRUCT\x10\0\x12\x0f\n\x0bJAVA_IMPORT\x10\x01\x12\
    \x0c\n\x08JAVA_DOT\x10\x02\x12\x0e\n\nJAVA_CLASS\x10\x03\x12\r\n\tJAVA_E\
    NUM\x10\x04\x12\x13\n\x0fJAVA_IMPLEMENTS\x10\x05\x12\x0f\n\x0bJAVA_METHO\
    D\x10\x06\x12\x11\n\rJAVA_FUNCTION\x10\x07\x12\x0e\n\nJAVA_AWAIT\x10\x08\
    \x12\x0c\n\x08JAVA_VAR\x10\t\x12\x11\n\rJAVA_OPTIONAL\x10\n\x12\x0f\n\
    \x0bJAVA_RETURN\x10\x0b\x12\x0e\n\nJAVA_CATCH\x10\x0c\x12\r\n\tJAVA_THIS\
    \x10\r\x12\x0e\n\nJAVA_WHILE\x10\x0e\x12\x0c\n\x08JAVA_TRY\x10\x0f\x12\
    \x0f\n\x0bJAVA_SWITCH\x10\x10\x12\x0c\n\x08JAVA_FOR\x10\x11\x12\x0e\n\nJ\
    AVA_TUPLE\x10\x12\x12\x16\n\x12JAVA_OPTIONAL_TYPE\x10\x13\x12\x16\n\x12J\
    AVA_CHAR_SEQUENCE\x10\x14\x12\x0f\n\x0bJAVA_STRING\x10\x15\x12\r\n\tJAVA\
    _BYTE\x10\x16\x12\x0e\n\nJAVA_SHORT\x10\x17\x12\x0c\n\x08JAVA_INT\x10\
    \x18\x12\r\n\tJAVA_LONG\x10\x19\x12\x13\n\x0fJAVA_BIGINTEGER\x10\x1a\x12\
    \x13\n\x0fJAVA_IDENTIFIER\x10$\x12\x12\n\x0eJAVA_INTERFACE\x10%\x12\x0e\
    \n\nJAVA_FINAL\x10&\x12\x10\n\x0cJAVA_COMMENT\x10'\x12\x16\n\x12JAVA_BLO\
    CK_COMMENT\x10(\x12\x14\n\x10JAVA_DOC_COMMENT\x10)\x12\x13\n\x0fJAVA_ANN\
    OTATION\x10**\x99\x04\n\x0bGoConstruct\x12\x18\n\x14GO_UNKNOWN_CONSTRUCT\
    \x10\0\x12\r\n\tGO_IMPORT\x10\x01\x12\n\n\x06GO_DOT\x10\x02\x12\r\n\tGO_\
    STRUCT\x10\x03\x12\x0b\n\x07GO_IOTA\x10\x04\x12\x11\n\rGO_IMPLEMENTS\x10\
    \x05\x12\r\n\tGO_METHOD\x10\x06\x12\x0b\n\x07GO_FUNC\x10\x07\x12\t\n\x05\
    GO_GO\x10\x08\x12\n\n\x06GO_VAR\x10\t\x12\x0c\n\x08GO_ERROR\x10\n\x12\r\
    \n\tGO_RETURN\x10\x0b\x12\x0e\n\nGO_RECOVER\x10\x0c\x12\x0f\n\x0bGO_RECE\
    IVER\x10\r\x12\n\n\x06GO_FOR\x10\x0e\x12\x0c\n\x08GO_DEFER\x10\x0f\x12\r\
    \n\tGO_SWITCH\x10\x10\x12\x0c\n\x08GO_RANGE\x10\x11\x12\x0c\n\x08GO_SLIC\
    E\x10\x12\x12\x0e\n\nGO_POINTER\x10\x13\x12\x0b\n\x07GO_RUNE\x10\x14\x12\
    \r\n\tGO_STRING\x10\x15\x12\x0b\n\x07GO_INT8\x10\x16\x12\x0c\n\x08GO_INT\
    16\x10\x17\x12\x0c\n\x08GO_INT32\x10\x18\x12\x0c\n\x08GO_INT64\x10\x19\
    \x12\n\n\x06GO_INT\x10\x1a\x12\x11\n\rGO_IDENTIFIER\x10$\x12\x10\n\x0cGO\
    _INTERFACE\x10%\x12\x0c\n\x08GO_CONST\x10&\x12\x0e\n\nGO_COMMENT\x10'\
    \x12\x14\n\x10GO_BLOCK_COMMENT\x10(\x12\x12\n\x0eGO_DOC_COMMENT\x10)\x12\
    \x14\n\x10GO_BUILD_COMMENT\x10**\xa5\x04\n\rRubyConstruct\x12\x1a\n\x16R\
    UBY_UNKNOWN_CONSTRUCT\x10\0\x12\x10\n\x0cRUBY_REQUIRE\x10\x01\x12\x0e\n\
    \nRUBY_SCOPE\x10\x02\x12\x0e\n\nRUBY_CLASS\x10\x03\x12\x0f\n\x0bRUBY_MOD\
    ULE\x10\x04\x12\x10\n\x0cRUBY_INCLUDE\x10\x05\x12\x0f\n\x0bRUBY_METHOD\
    \x10\x06\x12\x0c\n\x08RUBY_DEF\x10\x07\x12\x0e\n\nRUBY_ASYNC\x10\x08\x12\
    \x0c\n\x08RUBY_VAR\x10\t\x12\x0e\n\nRUBY_MAYBE\x10\n\x12\x0f\n\x0bRUBY_R\
    ETURN\x10\x0b\x12\x0f\n\x0bRUBY_RESCUE\x10\x0c\x12\r\n\tRUBY_SELF\x10\r\
    \x12\x0e\n\nRUBY_WHILE\x10\x0e\x12\x0e\n\nRUBY_BEGIN\x10\x0f\x12\r\n\tRU\
    BY_CASE\x10\x10\x12\r\n\tRUBY_EACH\x10\x11\x12\x0e\n\nRUBY_ARRAY\x10\x12\
    \x12\x10\n\x0cRUBY_NILABLE\x10\x13\x12\x0f\n\x0bRUBY_SYMBOL\x10\x14\x12\
    \x0f\n\x0bRUBY_STRING\x10\x15\x12\x10\n\x0cRUBY_INTEGER\x10\x16\x12\x0e\
    \n\nRUBY_FLOAT\x10\x17\x12\x13\n\x0fRUBY_IDENTIFIER\x10$\x12\x0e\n\nRUBY\
    _MIXIN\x10%\x12\x0f\n\x0bRUBY_FROZEN\x10&\x12\x10\n\x0cRUBY_COMMENT\x10'\
    \x12\x12\n\x0eRUBY_BEGIN_END\x10(\x12\r\n\tRUBY_RDOC\x10)\x12\x16\n\x12R\
    UBY_MAGIC_COMMENT\x10**\xc9\x04\n\x0cCPPConstruct\x12\x19\n\x15CPP_UNKNO\
    WN_CONSTRUCT\x10\0\x12\x0f\n\x0bCPP_INCLUDE\x10\x01\x12\r\n\tCPP_SCOPE\
    \x10\x02\x12\x0e\n\nCPP_STRUCT\x10\x03\x12\x0c\n\x08CPP_ENUM\x10\x04\x12\
    \x13\n\x0fCPP_INHERITANCE\x10\x05\x12\x0e\n\nCPP_METHOD\x10\x06\x12\x10\
    \n\x0cCPP_FUNCTION\x10\x07\x12\x10\n\x0cCPP_CO_AWAIT\x10\x08\x12\x0c\n\
    \x08CPP_AUTO\x10\t\x12\x10\n\x0cCPP_EXPECTED\x10\n\x12\x0e\n\nCPP_RETURN\
    \x10\x0b\x12\r\n\tCPP_CATCH\x10\x0c\x12\x0c\n\x08CPP_THIS\x10\r\x12\r\n\
    \tCPP_WHILE\x10\x0e\x12\x0b\n\x07CPP_TRY\x10\x0f\x12\x0e\n\nCPP_SWITCH\
    \x10\x10\x12\x0b\n\x07CPP_FOR\x10\x11\x12\r\n\tCPP_TUPLE\x10\x12\x12\x10\
    \n\x0cCPP_OPTIONAL\x10\x13\x12\x13\n\x0fCPP_STRING_VIEW\x10\x14\x12\x0e\
    \n\nCPP_STRING\x10\x15\x12\x0c\n\x08CPP_INT8\x10\x16\x12\r\n\tCPP_INT16\
    \x10\x17\x12\r\n\tCPP_INT32\x10\x18\x12\r\n\tCPP_INT64\x10\x19\x12\x0e\n\
    \nCPP_INT128\x10\x1a\x12\x12\n\x0eCPP_IDENTIFIER\x10$\x12\x10\n\x0cCPP_A\
    BSTRACT\x10%\x12\r\n\tCPP_CONST\x10&\x12\x0f\n\x0bCPP_COMMENT\x10'\x12\
    \x15\n\x11CPP_BLOCK_COMMENT\x10(\x12\x13\n\x0fCPP_DOC_COMMENT\x10)\x12\
    \x0e\n\nCPP_PRAGMA\x10**\xa3\x05\n\x0fCSharpConstruct\x12\x1c\n\x18CSHAR\
    P_UNKNOWN_CONSTRUCT\x10\0\x12\x10\n\x0cCSHARP_USING\x10\x01\x12\x0e\n\nC\
    SHARP_DOT\x10\x02\x12\x10\n\x0cCSHARP_CLASS\x10\x03\x12\x0f\n\x0bCSHARP_\
    ENUM\x10\x04\x12\x15\n\x11CSHARP_IMPLEMENTS\x10\x05\x12\x11\n\rCSHARP_ME\
    THOD\x10\x06\x12\x13\n\x0fCSHARP_FUNCTION\x10\x07\x12\x10\n\x0cCSHARP_AW\
    AIT\x10\x08\x12\x0e\n\nCSHARP_VAR\x10\t\x12\x0f\n\x0bCSHARP_TASK\x10\n\
    \x12\x11\n\rCSHARP_RETURN\x10\x0b\x12\x10\n\x0cCSHARP_CATCH\x10\x0c\x12\
    \x0f\n\x0bCSHARP_THIS\x10\r\x12\x10\n\x0cCSHARP_WHILE\x10\x0e\x12\x0e\n\
    \nCSHARP_TRY\x10\x0f\x12\x11\n\rCSHARP_SWITCH\x10\x10\x12\x12\n\x0eCSHAR\
    P_FOREACH\x10\x11\x12\x10\n\x0cCSHARP_TUPLE\x10\x12\x12\x13\n\x0fCSHARP_\
    NULLABLE\x10\x13\x12\x0f\n\x0bCSHARP_SPAN\x10\x14\x12\x11\n\rCSHARP_STRI\
    NG\x10\x15\x12\x10\n\x0cCSHARP_SBYTE\x10\x16\x12\x10\n\x0cCSHARP_SHORT\
    \x10\x17\x12\x0e\n\nCSHARP_INT\x10\x18\x12\x0f\n\x0bCSHARP_LONG\x10\x19\
    \x12\x15\n\x11CSHARP_BIGINTEGER\x10\x1a\x12\x15\n\x11CSHARP_IDENTIFIER\
    \x10$\x12\x14\n\x10CSHARP_INTERFACE\x10%\x12\x13\n\x0fCSHARP_READONLY\
    \x10&\x12\x12\n\x0eCSHARP_COMMENT\x10'\x12\x18\n\x14CSHARP_BLOCK_COMMENT\
    \x10(\x12\x12\n\x0eCSHARP_XML_DOC\x10)\x12\x11\n\rCSHARP_PRAGMA\x10**\
    \xcc\x01\n\x0bNumericType\x12\x13\n\x0fNUMERIC_UNKNOWN\x10\0\x12\x08\n\
    \x04INT8\x10\x01\x12\t\n\x05INT16\x10\x02\x12\t\n\x05INT32\x10\x03\x12\t\
    \n\x05INT64\x10\x04\x12\n\n\x06INT128\x10\x05\x12\x0c\n\x08INT_ARCH\x10\
    \x06\x12\t\n\x05UINT8\x10\x07\x12\n\n\x06UINT16\x10\x08\x12\n\n\x06UINT3\
    2\x10\t\x12\n\n\x06UINT64\x10\n\x12\x0b\n\x07UINT128\x10\x0b\x12\r\n\tUI\
    NT_ARCH\x10\x0c\x12\x0b\n\x07FLOAT32\x10\r\x12\x0b\n\x07FLOAT64\x10\x0e:\
    `\n\x07example\x18\xd1\x86\x03\x20\x01(\x0b2\x1e.kymera_mappings.Example\
    Option\x12!.google.protobuf.EnumValueOptionsR\x07example\x88\x01\x01b\
    \x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(248);
            messages.push(TestConfig::generated_message_descriptor_data());
            messages.push(TestExample::generated_message_descriptor_data());
            messages.push(BaseMapping::generated_message_descriptor_data());
            messages.push(ExampleOption::generated_message_descriptor_data());
            messages.push(AIASystemV2::generated_message_descriptor_data());
            messages.push(QuantumEnhancedSystem::generated_message_descriptor_data());
            messages.push(NeuralArchitectureSystem::generated_message_descriptor_data());
            messages.push(HardwareAccelerationSystem::generated_message_descriptor_data());
            messages.push(AdaptiveCompilationSystem::generated_message_descriptor_data());
            messages.push(SecurityEnhancementSystemV2::generated_message_descriptor_data());
            messages.push(MetaProgrammingSystemV2::generated_message_descriptor_data());
            messages.push(IntelligentDebuggingSystem::generated_message_descriptor_data());
            messages.push(DynamicOptimizationSystem::generated_message_descriptor_data());
            messages.push(VerificationSystem::generated_message_descriptor_data());
            messages.push(NumericTypeMapping::generated_message_descriptor_data());
            messages.push(LanguageConstruct::generated_message_descriptor_data());
            messages.push(LanguageMapping::generated_message_descriptor_data());
            messages.push(ConstructMetadata::generated_message_descriptor_data());
            messages.push(FileVersion::generated_message_descriptor_data());
            messages.push(MappingError::generated_message_descriptor_data());
            messages.push(ConstructPerformance::generated_message_descriptor_data());
            messages.push(ValidationRule::generated_message_descriptor_data());
            messages.push(DeprecationInfo::generated_message_descriptor_data());
            messages.push(SafetyFeatures::generated_message_descriptor_data());
            messages.push(PerformanceMetrics::generated_message_descriptor_data());
            messages.push(SecurityFeatures::generated_message_descriptor_data());
            messages.push(TestingSuite::generated_message_descriptor_data());
            messages.push(SecurityEnhancement::generated_message_descriptor_data());
            messages.push(PerformanceOptimization::generated_message_descriptor_data());
            messages.push(TestingEnhancement::generated_message_descriptor_data());
            messages.push(LanguageIntegration::generated_message_descriptor_data());
            messages.push(FFISystem::generated_message_descriptor_data());
            messages.push(IntelligentHardwareSystem::generated_message_descriptor_data());
            messages.push(QualityRatingSystem::generated_message_descriptor_data());
            messages.push(LanguageQualityPrompts::generated_message_descriptor_data());
            messages.push(ExampleMappings::generated_message_descriptor_data());
            messages.push(example_option::ExamplesEntry::generated_message_descriptor_data());
            messages.push(aiasystem_v2::CoreAIEngine::generated_message_descriptor_data());
            messages.push(aiasystem_v2::AdvancedGeneration::generated_message_descriptor_data());
            messages.push(aiasystem_v2::core_aiengine::ModelArchitecture::generated_message_descriptor_data());
            messages.push(aiasystem_v2::core_aiengine::DistributedCompute::generated_message_descriptor_data());
            messages.push(aiasystem_v2::core_aiengine::OptimizationEngine::generated_message_descriptor_data());
            messages.push(aiasystem_v2::advanced_generation::CodeSynthesis::generated_message_descriptor_data());
            messages.push(aiasystem_v2::advanced_generation::SecurityAwareness::generated_message_descriptor_data());
            messages.push(quantum_enhanced_system::QuantumProcessor::generated_message_descriptor_data());
            messages.push(quantum_enhanced_system::HybridAlgorithms::generated_message_descriptor_data());
            messages.push(quantum_enhanced_system::quantum_processor::Architecture::generated_message_descriptor_data());
            messages.push(quantum_enhanced_system::quantum_processor::QuantumCompiler::generated_message_descriptor_data());
            messages.push(quantum_enhanced_system::hybrid_algorithms::QuantumClassicalInterface::generated_message_descriptor_data());
            messages.push(quantum_enhanced_system::hybrid_algorithms::OptimizationStrategies::generated_message_descriptor_data());
            messages.push(neural_architecture_system::AdvancedNetworks::generated_message_descriptor_data());
            messages.push(neural_architecture_system::AutoML::generated_message_descriptor_data());
            messages.push(neural_architecture_system::advanced_networks::LayerDefinitions::generated_message_descriptor_data());
            messages.push(neural_architecture_system::advanced_networks::TrainingSystem::generated_message_descriptor_data());
            messages.push(neural_architecture_system::advanced_networks::MetaLearning::generated_message_descriptor_data());
            messages.push(neural_architecture_system::auto_ml::ArchitectureSearch::generated_message_descriptor_data());
            messages.push(neural_architecture_system::auto_ml::HyperparameterOptimization::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::GPUAcceleration::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::FPGAAcceleration::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::ASICOptimization::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::gpuacceleration::CUDAIntegration::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::gpuacceleration::ROCmSupport::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::fpgaacceleration::HDLGeneration::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::fpgaacceleration::BitstreamManagement::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::asicoptimization::CircuitGeneration::generated_message_descriptor_data());
            messages.push(hardware_acceleration_system::asicoptimization::PhysicalDesign::generated_message_descriptor_data());
            messages.push(adaptive_compilation_system::CompilerOptimization::generated_message_descriptor_data());
            messages.push(adaptive_compilation_system::RuntimeOptimization::generated_message_descriptor_data());
            messages.push(adaptive_compilation_system::compiler_optimization::OptimizationPasses::generated_message_descriptor_data());
            messages.push(adaptive_compilation_system::compiler_optimization::CodeGeneration::generated_message_descriptor_data());
            messages.push(adaptive_compilation_system::runtime_optimization::JITCompilation::generated_message_descriptor_data());
            messages.push(adaptive_compilation_system::runtime_optimization::SpeculativeExecution::generated_message_descriptor_data());
            messages.push(security_enhancement_system_v2::FormalVerification::generated_message_descriptor_data());
            messages.push(security_enhancement_system_v2::CryptographicSuite::generated_message_descriptor_data());
            messages.push(security_enhancement_system_v2::formal_verification::ProofGeneration::generated_message_descriptor_data());
            messages.push(security_enhancement_system_v2::formal_verification::ModelChecking::generated_message_descriptor_data());
            messages.push(security_enhancement_system_v2::cryptographic_suite::QuantumResistance::generated_message_descriptor_data());
            messages.push(security_enhancement_system_v2::cryptographic_suite::ZeroKnowledge::generated_message_descriptor_data());
            messages.push(meta_programming_system_v2::CodeGeneration::generated_message_descriptor_data());
            messages.push(meta_programming_system_v2::ReflectionSystem::generated_message_descriptor_data());
            messages.push(meta_programming_system_v2::code_generation::TemplateEngine::generated_message_descriptor_data());
            messages.push(meta_programming_system_v2::code_generation::MacroSystem::generated_message_descriptor_data());
            messages.push(meta_programming_system_v2::reflection_system::TypeIntrospection::generated_message_descriptor_data());
            messages.push(meta_programming_system_v2::reflection_system::MetaObjectProtocol::generated_message_descriptor_data());
            messages.push(intelligent_debugging_system::AutomaticDebugger::generated_message_descriptor_data());
            messages.push(intelligent_debugging_system::DebuggingAssistant::generated_message_descriptor_data());
            messages.push(intelligent_debugging_system::automatic_debugger::BugDetection::generated_message_descriptor_data());
            messages.push(intelligent_debugging_system::automatic_debugger::RootCauseAnalysis::generated_message_descriptor_data());
            messages.push(intelligent_debugging_system::debugging_assistant::CodeUnderstanding::generated_message_descriptor_data());
            messages.push(intelligent_debugging_system::debugging_assistant::InteractiveDebugging::generated_message_descriptor_data());
            messages.push(dynamic_optimization_system::ProfileGuidedOptimization::generated_message_descriptor_data());
            messages.push(dynamic_optimization_system::AutoTuning::generated_message_descriptor_data());
            messages.push(dynamic_optimization_system::auto_tuning::PerformanceModeling::generated_message_descriptor_data());
            messages.push(dynamic_optimization_system::auto_tuning::ConfigurationSpace::generated_message_descriptor_data());
            messages.push(verification_system::StaticAnalysis::generated_message_descriptor_data());
            messages.push(verification_system::DynamicAnalysis::generated_message_descriptor_data());
            messages.push(verification_system::static_analysis::TypeChecking::generated_message_descriptor_data());
            messages.push(verification_system::static_analysis::DataFlowAnalysis::generated_message_descriptor_data());
            messages.push(verification_system::dynamic_analysis::RuntimeVerification::generated_message_descriptor_data());
            messages.push(verification_system::dynamic_analysis::ConcurrencyAnalysis::generated_message_descriptor_data());
            messages.push(file_version::VersionConstraint::generated_message_descriptor_data());
            messages.push(file_version::VersionMetadata::generated_message_descriptor_data());
            messages.push(mapping_error::ErrorContext::generated_message_descriptor_data());
            messages.push(mapping_error::ErrorResolution::generated_message_descriptor_data());
            messages.push(construct_performance::PerformanceMetrics::generated_message_descriptor_data());
            messages.push(construct_performance::OptimizationHints::generated_message_descriptor_data());
            messages.push(construct_performance::ResourceUtilization::generated_message_descriptor_data());
            messages.push(validation_rule::Constraint::generated_message_descriptor_data());
            messages.push(validation_rule::ValidationContext::generated_message_descriptor_data());
            messages.push(validation_rule::ValidationResult::generated_message_descriptor_data());
            messages.push(deprecation_info::DeprecationSchedule::generated_message_descriptor_data());
            messages.push(deprecation_info::MigrationStep::generated_message_descriptor_data());
            messages.push(deprecation_info::CompatibilityLayer::generated_message_descriptor_data());
            messages.push(safety_features::BackwardCompatibility::generated_message_descriptor_data());
            messages.push(safety_features::Interoperability::generated_message_descriptor_data());
            messages.push(safety_features::SecurityImplications::generated_message_descriptor_data());
            messages.push(safety_features::TestingSpecification::generated_message_descriptor_data());
            messages.push(safety_features::interoperability::CrossLanguageSupport::generated_message_descriptor_data());
            messages.push(safety_features::security_implications::SecurityAudit::generated_message_descriptor_data());
            messages.push(safety_features::testing_specification::TestCase::generated_message_descriptor_data());
            messages.push(performance_metrics::RuntimeMetrics::generated_message_descriptor_data());
            messages.push(performance_metrics::ResourceUsage::generated_message_descriptor_data());
            messages.push(performance_metrics::PerformanceProfile::generated_message_descriptor_data());
            messages.push(security_features::SecurityCheck::generated_message_descriptor_data());
            messages.push(security_features::SecurityAudit::generated_message_descriptor_data());
            messages.push(security_features::SecurityPolicy::generated_message_descriptor_data());
            messages.push(testing_suite::TestDefinition::generated_message_descriptor_data());
            messages.push(testing_suite::TestCase::generated_message_descriptor_data());
            messages.push(testing_suite::TestResults::generated_message_descriptor_data());
            messages.push(testing_suite::TestCoverage::generated_message_descriptor_data());
            messages.push(security_enhancement::RuntimeSecurity::generated_message_descriptor_data());
            messages.push(security_enhancement::CrossLanguageSecurity::generated_message_descriptor_data());
            messages.push(security_enhancement::SecurityContext::generated_message_descriptor_data());
            messages.push(performance_optimization::CompilerHints::generated_message_descriptor_data());
            messages.push(performance_optimization::RuntimeOptimizations::generated_message_descriptor_data());
            messages.push(performance_optimization::OptimizationProfile::generated_message_descriptor_data());
            messages.push(testing_enhancement::PropertyTesting::generated_message_descriptor_data());
            messages.push(testing_enhancement::FuzzTesting::generated_message_descriptor_data());
            messages.push(testing_enhancement::TestOracle::generated_message_descriptor_data());
            messages.push(language_integration::FFIDefinition::generated_message_descriptor_data());
            messages.push(language_integration::InteropValidation::generated_message_descriptor_data());
            messages.push(language_integration::IntegrationContext::generated_message_descriptor_data());
            messages.push(ffisystem::FFIDefinition::generated_message_descriptor_data());
            messages.push(ffisystem::LanguageBinding::generated_message_descriptor_data());
            messages.push(ffisystem::CrossLanguageMemory::generated_message_descriptor_data());
            messages.push(ffisystem::TypeBridge::generated_message_descriptor_data());
            messages.push(ffisystem::ErrorBridge::generated_message_descriptor_data());
            messages.push(ffisystem::BuildIntegration::generated_message_descriptor_data());
            messages.push(ffisystem::RuntimeVerification::generated_message_descriptor_data());
            messages.push(ffisystem::language_binding::RustBinding::generated_message_descriptor_data());
            messages.push(ffisystem::language_binding::PythonBinding::generated_message_descriptor_data());
            messages.push(ffisystem::cross_language_memory::MemoryStrategy::generated_message_descriptor_data());
            messages.push(ffisystem::type_bridge::TypeMapping::generated_message_descriptor_data());
            messages.push(ffisystem::error_bridge::ErrorMapping::generated_message_descriptor_data());
            messages.push(ffisystem::build_integration::DependencyManager::generated_message_descriptor_data());
            messages.push(ffisystem::build_integration::BuildConfig::generated_message_descriptor_data());
            messages.push(ffisystem::runtime_verification::SafetyCheck::generated_message_descriptor_data());
            messages.push(ffisystem::runtime_verification::PerformanceMetrics::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::QualityIntegration::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::HardwareAwareness::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::ComputeFramework::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::LowLatencySystem::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::ConcurrencyEngine::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::MemorySystem::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::AutoIntegration::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::PerformanceMonitor::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::hardware_awareness::SystemDetection::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::hardware_awareness::GPUCapabilities::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::hardware_awareness::AcceleratorSupport::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::compute_framework::CUDAIntegration::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::compute_framework::ROCmIntegration::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::compute_framework::VulkanCompute::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::low_latency_system::LatencyOptimization::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::low_latency_system::RealTimeScheduling::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::low_latency_system::AsyncProcessing::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::concurrency_engine::WorkloadDistribution::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::concurrency_engine::ParallelExecution::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::concurrency_engine::SynchronizationPrimitives::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::memory_system::MemoryHierarchy::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::memory_system::MemoryOptimization::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::memory_system::DataTransfer::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::auto_integration::PlatformAdaptation::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::auto_integration::OptimizationPipeline::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::auto_integration::RuntimeAdaptation::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::performance_monitor::HardwareMetrics::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::performance_monitor::WorkloadAnalysis::generated_message_descriptor_data());
            messages.push(intelligent_hardware_system::performance_monitor::AdaptiveTuning::generated_message_descriptor_data());
            messages.push(quality_rating_system::QualityMetrics::generated_message_descriptor_data());
            messages.push(quality_rating_system::ModularityChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::ErrorHandling::generated_message_descriptor_data());
            messages.push(quality_rating_system::PerformanceChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::DocumentationChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::ImplementationChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::LanguageChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::QualityEnforcement::generated_message_descriptor_data());
            messages.push(quality_rating_system::implementation_checks::SecurityChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::implementation_checks::TestingChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::implementation_checks::CodeQuality::generated_message_descriptor_data());
            messages.push(quality_rating_system::language_checks::RustChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::language_checks::TypeScriptChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::language_checks::PythonChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::quality_enforcement::AutomatedChecks::generated_message_descriptor_data());
            messages.push(quality_rating_system::quality_enforcement::ManualReview::generated_message_descriptor_data());
            messages.push(quality_rating_system::quality_enforcement::ContinuousImprovement::generated_message_descriptor_data());
            messages.push(language_quality_prompts::KymeraPrompt::generated_message_descriptor_data());
            messages.push(language_quality_prompts::RustPrompt::generated_message_descriptor_data());
            messages.push(language_quality_prompts::TypeScriptPrompt::generated_message_descriptor_data());
            messages.push(language_quality_prompts::PythonPrompt::generated_message_descriptor_data());
            messages.push(language_quality_prompts::ProtobufPrompt::generated_message_descriptor_data());
            messages.push(language_quality_prompts::JavaScriptPrompt::generated_message_descriptor_data());
            messages.push(language_quality_prompts::AgnosticPrompt::generated_message_descriptor_data());
            messages.push(language_quality_prompts::kymera_prompt::ModularityChecks::generated_message_descriptor_data());
            messages.push(language_quality_prompts::kymera_prompt::ErrorHandling::generated_message_descriptor_data());
            messages.push(language_quality_prompts::kymera_prompt::PerformanceOptimization::generated_message_descriptor_data());
            messages.push(language_quality_prompts::kymera_prompt::Documentation::generated_message_descriptor_data());
            messages.push(language_quality_prompts::rust_prompt::ModularityChecks::generated_message_descriptor_data());
            messages.push(language_quality_prompts::rust_prompt::ErrorHandling::generated_message_descriptor_data());
            messages.push(language_quality_prompts::rust_prompt::Performance::generated_message_descriptor_data());
            messages.push(language_quality_prompts::type_script_prompt::DependencyChecks::generated_message_descriptor_data());
            messages.push(language_quality_prompts::type_script_prompt::ErrorLogging::generated_message_descriptor_data());
            messages.push(language_quality_prompts::type_script_prompt::Performance::generated_message_descriptor_data());
            messages.push(language_quality_prompts::python_prompt::DependencyChecks::generated_message_descriptor_data());
            messages.push(language_quality_prompts::python_prompt::ErrorHandling::generated_message_descriptor_data());
            messages.push(language_quality_prompts::python_prompt::Performance::generated_message_descriptor_data());
            messages.push(language_quality_prompts::protobuf_prompt::SchemaChecks::generated_message_descriptor_data());
            messages.push(language_quality_prompts::protobuf_prompt::ErrorHandling::generated_message_descriptor_data());
            messages.push(language_quality_prompts::protobuf_prompt::Performance::generated_message_descriptor_data());
            messages.push(language_quality_prompts::java_script_prompt::DependencyChecks::generated_message_descriptor_data());
            messages.push(language_quality_prompts::java_script_prompt::ErrorHandling::generated_message_descriptor_data());
            messages.push(language_quality_prompts::java_script_prompt::Performance::generated_message_descriptor_data());
            messages.push(language_quality_prompts::agnostic_prompt::ModularityChecks::generated_message_descriptor_data());
            messages.push(language_quality_prompts::agnostic_prompt::ErrorHandling::generated_message_descriptor_data());
            messages.push(language_quality_prompts::agnostic_prompt::Performance::generated_message_descriptor_data());
            messages.push(example_mappings::FunctionMapping::generated_message_descriptor_data());
            messages.push(example_mappings::TypeMapping::generated_message_descriptor_data());
            messages.push(example_mappings::ErrorHandlingExample::generated_message_descriptor_data());
            messages.push(example_mappings::FFIExample::generated_message_descriptor_data());
            messages.push(example_mappings::FFIConfig::generated_message_descriptor_data());
            messages.push(example_mappings::TestExample::generated_message_descriptor_data());
            messages.push(example_mappings::TestConfig::generated_message_descriptor_data());
            messages.push(example_mappings::KymeraToRustExamples::generated_message_descriptor_data());
            messages.push(example_mappings::KymeraToPythonExamples::generated_message_descriptor_data());
            messages.push(example_mappings::KymeraToTypeScriptExamples::generated_message_descriptor_data());
            messages.push(example_mappings::function_mapping::Example::generated_message_descriptor_data());
            messages.push(example_mappings::type_mapping::Example::generated_message_descriptor_data());
            messages.push(example_mappings::error_handling_example::Example::generated_message_descriptor_data());
            messages.push(example_mappings::ffiexample::Example::generated_message_descriptor_data());
            messages.push(example_mappings::test_example::Example::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(17);
            enums.push(ComputationalCost::generated_enum_descriptor_data());
            enums.push(MemoryManagement::generated_enum_descriptor_data());
            enums.push(KymeraConstruct::generated_enum_descriptor_data());
            enums.push(RustConstruct::generated_enum_descriptor_data());
            enums.push(PythonConstruct::generated_enum_descriptor_data());
            enums.push(TSConstruct::generated_enum_descriptor_data());
            enums.push(JSConstruct::generated_enum_descriptor_data());
            enums.push(JavaConstruct::generated_enum_descriptor_data());
            enums.push(GoConstruct::generated_enum_descriptor_data());
            enums.push(RubyConstruct::generated_enum_descriptor_data());
            enums.push(CPPConstruct::generated_enum_descriptor_data());
            enums.push(CSharpConstruct::generated_enum_descriptor_data());
            enums.push(NumericType::generated_enum_descriptor_data());
            enums.push(aiasystem_v2::core_aiengine::optimization_engine::OptimizationLevel::generated_enum_descriptor_data());
            enums.push(dynamic_optimization_system::profile_guided_optimization::OptimizationStrategy::generated_enum_descriptor_data());
            enums.push(mapping_error::ErrorSeverity::generated_enum_descriptor_data());
            enums.push(ffisystem::cross_language_memory::memory_strategy::Strategy::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
